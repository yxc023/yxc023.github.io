<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://blog.yangxiaochen.com</link>
    <atom:link href="http://blog.yangxiaochen.com/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Sat, 16 Feb 2019 15:38:04 +0000</pubDate>
    <lastBuildDate>Sat, 16 Feb 2019 15:38:04 +0000</lastBuildDate>

    <item>
      <title>在 windows 系统下适用 linux 命令行做开发</title>
      <link>http://blog.yangxiaochen.com/blog/tools/linux-in-windows.html</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/tools/linux-in-windows.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_manjaro_deepin&quot;&gt;2. manjaro &amp;amp; deepin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_虚拟机&quot;&gt;3. 虚拟机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_ubuntu_子系统&quot;&gt;4. ubuntu 子系统&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_安装&quot;&gt;4.1. 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用&quot;&gt;4.2. 使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我的开发主力机器是一台2014年的13寸 macbook pro. 几年来一直战斗力良好. 但是平时上班比较远, 有时候加班晚点, 回家的时候就不想背这个电脑.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有时回到家中想干点什么, 家里一台老旧的神舟战神笔记本被封存已久, 每次拿出来都要翻箱倒柜, 还要在收拾回去, 而且, 性能也比较落后, 摆到桌子上也占地方.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;年前就把这个笔记本咸鱼出手了, 自己 DIY 了一个小型台式机, 放到桌子下面, 配合我去年买的显示器, 作为家中的常备电脑, 偶尔还能打打游戏.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是习惯了 macOS 下的开发体验, 很多操作习惯用命令行来做, 又很依赖 oh-my-zsh, 装一些开发工具也方便. 在 window 下没有了熟悉的命令行怎么办.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_manjaro_deepin&quot;&gt;2. manjaro &amp;amp; deepin&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先想到的是装 linux 系统, 试用了比较流行的 manjaro 和 deepin, 开始感觉还不错, 但是要装一些沟通工具时, 总会出现这样那样的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这么多年来, 每次想要使用一个 linux 发行版来做开发环境, 最终的结果都是折腾两天然后删掉分区..&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_虚拟机&quot;&gt;3. 虚拟机&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;windows 上装 linux 虚拟机, 使用 windows 的沟通工具, 在 linux 下做开发, 体验不如原生, 且切换麻烦, 有一点微妙的卡顿, 让我在虚拟机里下载 idea 做开发, 想想都卡. 数据交换也是问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_ubuntu_子系统&quot;&gt;4. ubuntu 子系统&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;试过种种之后, 了解到在 Windows 10 里, 有 Windows Subsystem for Linux（WSL）这一特性, 支持在 windows 下运行 bash, 来操作一个 linux 系统.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_安装&quot;&gt;4.1. 安装&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;windows 10 商店中搜索 linux, 可以看到很多个 linux 发行版, 像 ubuntu, suse 等. 选择最熟悉的 ubuntu 安装.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 menu:控制面板[程序 &amp;gt; 启用或关闭 windows 功能 ] 中, 勾选 &lt;code&gt;适用于linux 的 windows 子系统&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_使用&quot;&gt;4.2. 使用&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;win + R&lt;/code&gt; 打开运行, 输入 &lt;code&gt;bash&lt;/code&gt; 或者 &lt;code&gt;wsl&lt;/code&gt; 或者 &lt;code&gt;ubuntu&lt;/code&gt;, 就进入了 linux 命令行.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以通过 &lt;code&gt;/mnt/&amp;lt;盘号&amp;gt;/&lt;/code&gt; 来访问 windows 的目录.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line-through&quot;&gt;在 window 下, 可以使用 &lt;a href=&quot;http://cmder.net/&quot;&gt;cmder&lt;/a&gt; 来改善终端.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在windows下, 可以使用 &lt;a href=&quot;https://github.com/eugeny/terminus&quot;&gt;terminus&lt;/a&gt; 来改善终端.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上图:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;image:/img/tools/linux-in-windows/screen.png&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>groovy技巧 for java 开发者</title>
      <link>http://blog.yangxiaochen.com/blog/groovy/groovy-tips-for-javaer.html</link>
      <pubDate>Sat, 5 May 2018 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/groovy/groovy-tips-for-javaer.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_语法格式&quot;&gt;语法,格式&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_基础&quot;&gt;基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_对象&quot;&gt;对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_方法调用&quot;&gt;方法调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_字符串&quot;&gt;字符串&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_引号&quot;&gt;引号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_list&quot;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_map&quot;&gt;map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_流式操作&quot;&gt;流式操作&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_each_遍历&quot;&gt;each 遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_grep_过滤&quot;&gt;grep 过滤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_collect_转换&quot;&gt;collect 转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_groupby_列表转_map&quot;&gt;groupBy 列表转 map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_io&quot;&gt;io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_命令行_command&quot;&gt;命令行 command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_更多&quot;&gt;更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文旨在对有 java 基础的程序员在几分钟内了解 groovy 不同于 groovy 的技巧, 方便快速使用到 groovy 带来的便捷.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_语法格式&quot;&gt;语法,格式&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_基础&quot;&gt;基础&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每句语法后不需要分号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;兼容绝大多数 java 语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非强类型语言, 使用推导类型, 可以使用 &lt;code&gt;def&lt;/code&gt; 来定义变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_对象&quot;&gt;对象&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class Person {
    String name
    final int age
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;属性和对象默认为 public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性会自动生成 getter 和 setter.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;调用 &lt;code&gt;person.name&lt;/code&gt; 等同于调用 &lt;code&gt;person.getName()&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final 只有 get 方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用带参数名的构造方法&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def person = new Person(name: &quot;John&quot;, age: 18)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_方法调用&quot;&gt;方法调用&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;方法调用可以不写括号, 下面两句是一样的&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;println(&quot;haha&quot;)
println &quot;haha&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_字符串&quot;&gt;字符串&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 中字符串字面量有两种:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def s1 = &quot;world&quot;
def s2 = &quot;hello $s1&quot;

assert s2 == &quot;hello world&quot; // true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;s1 是 String 类型, s2 是 GString 类型, 因为 s2 中有 &lt;code&gt;$&lt;/code&gt; 形式的插入值&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;觉大多数情况下, 可以忽略两种类型的差异.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 中字符串可以通过 &lt;code&gt;==&lt;/code&gt; 来判断字符串相等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_引号&quot;&gt;引号&lt;/h4&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单引号 &lt;code&gt;&apos;&lt;/code&gt; 的字符串, 就是纯字符串 &lt;code&gt;java.lang.String&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双引号 &lt;code&gt;&quot;&lt;/code&gt; 的字符串, 可以有插入值, 如 &lt;code&gt;assert &quot;hello $1&quot; == &quot;hello world&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三引号 &lt;code&gt;&apos;&apos;&apos;&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, 是多行形式, 比如&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def s1 = &quot;&quot;&quot;hello
world&quot;&quot;&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_list&quot;&gt;list&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 提供了方便的 list 定义方式, 这个方式的 list 默认是 ArrayList 形式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;// 定义 list
def letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]

assert letters[0] == &apos;a&apos;
assert letters[1] == &apos;b&apos;

assert letters[-1] == &apos;d&apos;
assert letters[-2] == &apos;c&apos;

letters[2] = &apos;C&apos;
assert letters[2] == &apos;C&apos;

// 添加一个元素
letters &amp;lt;&amp;lt; &apos;e&apos;
assert letters[ 4] == &apos;e&apos;
assert letters[-1] == &apos;e&apos;

// 根据下标取子集
assert letters[1, 3] == [&apos;b&apos;, &apos;d&apos;]
// 根据范围去子集
assert letters[2..4] == [&apos;C&apos;, &apos;d&apos;, &apos;e&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_map&quot;&gt;map&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 提供了方便的 map 定义方式, 这个方式的 map 默认是 LinkedHashMap 形式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def colors = [red: &apos;#FF0000&apos;, green: &apos;#00FF00&apos;, blue: &apos;#0000FF&apos;]

assert colors[&apos;red&apos;] == &apos;#FF0000&apos;
assert colors.green  == &apos;#00FF00&apos;

colors[&apos;pink&apos;] = &apos;#FF00FF&apos;
colors.yellow  = &apos;#FFFF00&apos;

assert colors.pink == &apos;#FF00FF&apos;
assert colors[&apos;yellow&apos;] == &apos;#FFFF00&apos;

assert colors instanceof java.util.LinkedHashMap&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_流式操作&quot;&gt;流式操作&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;java8 的 stream 操作带来很多便利, groovy 除了能使用 java8 的 stream 外, 还有自己的一套更为方便的流式操作&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_each_遍历&quot;&gt;each 遍历&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].each { it -&amp;gt;
    println &quot;$it&quot;
}
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].eachWithIndex { it, i -&amp;gt;
    println &quot;$i: $it&quot;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_grep_过滤&quot;&gt;grep 过滤&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def list = [1, 2, 3, 4, 5]
assert list.grep {it &amp;gt; 3} == [4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_collect_转换&quot;&gt;collect 转换&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def list = [1, 2, 3, 4, 5]
assert list.collect { (it * 2) as String } == [&quot;2&quot;, &quot;4&quot;, &quot;6&quot;, &quot;8&quot;, &quot;10&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_groupby_列表转_map&quot;&gt;groupBy 列表转 map&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;assert [
        [name: &apos;Clark&apos;, city: &apos;London&apos;], [name: &apos;Sharma&apos;, city: &apos;London&apos;],
        [name: &apos;Maradona&apos;, city: &apos;LA&apos;], [name: &apos;Zhang&apos;, city: &apos;HK&apos;],
        [name: &apos;Ali&apos;, city: &apos;HK&apos;], [name: &apos;Liu&apos;, city: &apos;HK&apos;],
].groupBy { it.city } == [
        London: [[name: &apos;Clark&apos;, city: &apos;London&apos;],
                 [name: &apos;Sharma&apos;, city: &apos;London&apos;]],
        LA    : [[name: &apos;Maradona&apos;, city: &apos;LA&apos;]],
        HK    : [[name: &apos;Zhang&apos;, city: &apos;HK&apos;],
                 [name: &apos;Ali&apos;, city: &apos;HK&apos;],
                 [name: &apos;Liu&apos;, city: &apos;HK&apos;]],
]

// 对于常见的把一个列表建立 id 索引
assert [
        [id: 1, name: &apos;Clark&apos;, city: &apos;London&apos;], [id: 2, name: &apos;Sharma&apos;, city: &apos;London&apos;],
        [id: 3, name: &apos;Maradona&apos;, city: &apos;LA&apos;]
].groupBy { it.id }.collectEntries { key, value -&amp;gt; [key, value.first] } == [
        1: [id: 1, name: &apos;Clark&apos;, city: &apos;London&apos;],
        2: [id: 2, name: &apos;Sharma&apos;, city: &apos;London&apos;],
        3: [id: 3, name: &apos;Maradona&apos;, city: &apos;LA&apos;]
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_io&quot;&gt;io&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;new File(&quot;a.txt&quot;).eachLine { line -&amp;gt;
    println line
}

def out = new File(&quot;out.txt&quot;)
out &amp;lt;&amp;lt; &quot;hello world\n&quot;
out &amp;lt;&amp;lt; &quot;something&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_命令行_command&quot;&gt;命令行 command&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看例子&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;if(args.size() &amp;lt; 1 ) {
    println &quot;need pid&quot;
    return
}
def pid = args[0]

def sout = new StringBuilder(), serr = new StringBuilder()
def proc = &quot;top -b -n 1 -H -p ${pid}&quot;.execute()

proc.consumeProcessOutput(sout, serr)
proc.waitFor()

def begin = false
def countLimit = 10
def count = 0
sout.eachLine { line -&amp;gt;
    if (line.trim().size() == 0) {
        return
    }
    if (begin &amp;amp;&amp;amp; count &amp;lt;= countLimit) {
        println line
        def row = line.trim().split(&quot; +&quot;)
        def tid = String.format(&quot;nid=0x%x&quot;, row[0].toInteger())
        println tid

        def sout1 = new StringBuilder(), serr1 = new StringBuilder()
        def p1 =  (System.getenv(&quot;JAVA_HOME&quot;)+&quot;/bin/jstack -l ${pid} &quot;).execute() | [&quot;grep&quot;, tid ,&quot;-A 20&quot;].execute()
        p1.consumeProcessOutput(sout1, serr1)
        p1.waitFor()

        serr1.eachLine { println it }
        def lines = sout1.readLines()

        if (lines.size() &amp;gt; 0) {
            println lines[0]
            lines[1..-1].takeWhile { !it.startsWith(&quot;\&quot;&quot;) }.each { println it }
        }

        println()
        count++
    }
    if (!begin &amp;amp;&amp;amp; line.trim().toUpperCase().startsWith(&quot;PID&quot;)) {
        begin = true
    }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_更多&quot;&gt;更多&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;参考实例: &lt;a href=&quot;http://www.groovy-lang.org/groovy-dev-kit.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/groovy-dev-kit.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;db 操作: &lt;a href=&quot;http://www.groovy-lang.org/databases.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/databases.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;json 操作: &lt;a href=&quot;http://www.groovy-lang.org/json.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/json.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>spring 中 aspectj 扫描内容太多导致的启动时加载缓慢</title>
      <link>http://blog.yangxiaochen.com/blog/stackoverflow/spring-aspectj-slow.html</link>
      <pubDate>Thu, 3 May 2018 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/stackoverflow/spring-aspectj-slow.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_现象&quot;&gt;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_发现问题&quot;&gt;发现问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_解决&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_现象&quot;&gt;现象&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我在一个现有的项目中, 引入 jooq. 这个项目本身是使用的 mybatis, 我引入 jooq, 想并行使用, 之后逐渐替换.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;引入 jooq 之后, 启动过程中发现中间停顿了 2-3 分钟. 也没有日志输出.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_发现问题&quot;&gt;发现问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;dump 出主线程的堆栈, 一直是 aspectj 的代码块, 在判断一个 target 是否需要被进行切面代理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;debug 模式启动, 到这个位置时, 在上面 dump 堆栈显示过的位置打断点.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;发现是一个表达式为&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;的 PointCut 在检测 &lt;code&gt;DefaultDSLContext`&lt;/code&gt; 类中的每一个方法是否需要进行切面代理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 &lt;code&gt;DefaultDSLContext&lt;/code&gt; 是 jooq 的入口类, 为了方便我们使用 jooq, 这个类里有大量的方法重载和泛型, 为了支持 jooq 的 22 度强类型, 方法都有 1 - 22 个参数.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以对每一个方法匹配时, 都要获取方法签名, 每一个方法的参数列表类型, 如果是泛型, 还有额外操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_解决&quot;&gt;解决&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过 spring aspectj 部分的文档和源码, 总结有以下结论:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;切面与代码的匹配是一个非常耗时的工作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配的表达式越精确约好.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如何做呢, spring aspectj 的文档给出了一些建议:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一般来说, 切面声明有以下集中类型&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Kinded designators, 比如 execution, get, set, call, handler. 特定类型代码的切面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scoping designators, 比如 within, withincode. 一组切面, 包含了多种类型的代码, 但是有一个范围.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contextual designators, 比如 this, target, @annotation. 可能需要切面的上下文来帮助进行匹配检测.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;单独使用 Kinded designators 或者 Contextual designators 都是可以完成功能的, 但可能会影响织入性能, 因为要做额外的处理和分析.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Scoping designators 可以非常快的判断目标是否在范围内, 避免不必要的分析处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以通常写切面定义时, 最好加上 Scoping designators.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后, 我把切面定义修改为:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;within(com.lianjia.xxx.platform..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;结果界面无效, 因为我要切的目标是 mybatis 的 mapper, 因为这个 mapper 实际上是 com.sun.proxy.Proxy 对象. 最终改成&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;within(com.sun.proxy..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;!within(org.jooq.impl..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;spring 启动是到织如阶段时, 对 DefaultDSLContext 的实例进行判断织如时, 可以通过 fastMatch 直接判断不行, 就不用对方法逐个检查了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最终结果启动耗时减少了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_后记&quot;&gt;后记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其实 &lt;code&gt;execution(* com.lianjia.xxx.platform.&lt;strong&gt;.dao..&lt;/strong&gt;.*(..))&lt;/code&gt; 应该也是可以分析出范围的, 还没有细究是出于什么考虑没有做判断.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家可以对现有项目中的切面进行优化, 尝试减少启动时间.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;aop 是个好东西, 但是也带来复杂性, 可读性, 性能上的隐患. 严格一点来说, 要刨根问底, 保证项目的配置启动过程是完全掌控在手的, 避免黑盒(即不知道为啥, 反正这么配就能 run 起来了, 没有啥问题出现)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;代理对象和正常对象的切入方式会有不同, 需要注意.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>2018 北京 qcon 大会笔记</title>
      <link>http://blog.yangxiaochen.com/blog/设计思想/2018-beijing-qcon.html</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/设计思想/2018-beijing-qcon.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第一场_阿里巴巴微服务技术实践&quot;&gt;第一场: 阿里巴巴微服务技术实践&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_历史背景&quot;&gt;历史背景&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_all_in_one&quot;&gt;all in one&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_code_share&quot;&gt;code share&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_api&quot;&gt;api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_问题&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_出现&quot;&gt;&quot;Pandora&quot; 出现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_问题&quot;&gt;&quot;Pandora&quot; 问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_boot_来解决上面的问题&quot;&gt;&quot;pandora boot&quot; 来解决上面的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_其他内容&quot;&gt;其他内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第二场_51信用卡在微服务架构下的监控平台架构实践&quot;&gt;第二场: 51信用卡在微服务架构下的监控平台架构实践&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第三场_京东阿基米德微服务平台&quot;&gt;第三场: 京东阿基米德微服务平台&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_jsf&quot;&gt;JSF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_containermesh&quot;&gt;ContainerMesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_调用图谱&quot;&gt;调用图谱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_应用集市&quot;&gt;应用集市&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_能力地图&quot;&gt;能力地图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结_2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第四场_saga分布式事务解决方案与实践&quot;&gt;第四场: Saga分布式事务解决方案与实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_end&quot;&gt;end&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;4月22日下午去听了半天的 Qcon 软件开发大会分享. 主要是服务化探索的内容.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第一场_阿里巴巴微服务技术实践&quot;&gt;第一场: 阿里巴巴微服务技术实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一场虽然名字是&quot;阿里巴巴微服务实践&quot;, 但主要讲的是一个名为 &quot;Pandora&quot; 的服务隔离框架, 和为了这个框架能够方便使用的 &quot;Pandora boot&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_历史背景&quot;&gt;历史背景&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;服务化在阿里的过程:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_all_in_one&quot;&gt;all in one&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最早很自然都是 all in one, 一个大的系统所有功能都在一个项目里.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_code_share&quot;&gt;code share&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后在09-12年, 做项目拆分, 但是是通过代码共享, 即业务功能写完后, 发布成 jar 包, 供几个项目引用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里我不得不吐槽, 我在15年也是这么做的, 现在接手的新项目也是这么做的. 显然是很不爽的, 因为修改一个业务逻辑, 就要生成新的 jar 包发布出去, 然后凡是依赖这个 jar 包的应用都要进行更新.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;反过来说, 当你在关注一个应用时, 需要修改它的逻辑, 发现逻辑放在底层的 jar 包里, 需要另开一个项目更改, 很烦.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我最初这么做的想法, 无非是想避免同样的逻辑在不同的系统里写多次, 尤其是数据存取的那些逻辑, 毕竟在 java 里写 pojo mapper 很繁琐, 不能没个项目里都维护一份.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;现在看来, 这种写法非常教条化. 在工作中也遇到有的同学严格照搬分层标准, 对同一个实体封装的 po, vo, dto, 对一个实体的不同纬度的的查询, 就一定要在一个包里, 哪怕这个查询就是为了某一个应用而写的特殊查询, 也要写在公共的包里. 我感觉这很教条, 不灵活, 忽视了功能和业务的聚集, 而仅仅考虑它们是描述同一实体的代码.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_api&quot;&gt;api&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;12年到15, 16年. 就向每个系统代码相互独立, 系统间通过 api 进行交互.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这也就是我们现在通常所认为的微服务.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_问题&quot;&gt;问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在以上服务化演进过程中, 就产生了一些中间件来支持每个应用. 比如 HSF中间件, 消息中间件, tddl, tair, ons 等阿里内部的中间件系统.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样业务系统就会因为这些中间件的 client 端或者 sdk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;产生了一下问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中间件统一运维, 统一更新, 要求业务方应用更新 client 和 sdk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间件 client 或 sdk 的依赖与业务方应用所需要的依赖冲突.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如某个中间件 client 用到 netty 是 4.0.* , 而业务方应用的功能需要依赖 netty 4.1.*&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同中间件之间的所需依赖冲突&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_出现&quot;&gt;&quot;Pandora&quot; 出现&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;Pandora&quot; 就是这种背景产生下的隔离容器.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是基于 java 的 classloader 体系, 通过在 tomcat 等容器上配置自定义的 pandora classloader, 实现加载不同的中间件及其依赖的 class 时, 到不同的目录来查找.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在业务应用部署时, 一个包含了所有中间件依赖的 &quot;Pandora&quot; 目录会部署在项目目录下.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_问题&quot;&gt;&quot;Pandora&quot; 问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;想一下, 就是知道这一套东西用起来很麻烦:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地开发需要引入这样一堆组件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加特殊的虚拟机参数, 容器配置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不引用这个 &quot;pandora&quot; 组件, 则需要自己用 maven 添加中间件所需依赖. 等到上线时才发现自己使用的依赖跟 &quot;pandora&quot; 里的依赖版本不一致造成运行时错误.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用创建麻烦, 找兄弟项目拷贝.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中第四点我们也有同样的问题. 新建项目就是拷贝代码, 一些不好的结构, 过期的依赖, 不合理的配置都会迁移过来&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_boot_来解决上面的问题&quot;&gt;&quot;pandora boot&quot; 来解决上面的问题&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解决项目新建问题:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有一个类似于 &lt;a href=&quot;http://start.spring.io&quot; class=&quot;bare&quot;&gt;http://start.spring.io&lt;/a&gt; 的一站式应用创建页面. 勾选后直接下载一个完整的初始项目压缩包&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决开发依赖的问题:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;pandora&quot; 发布 middleware-sdk包, 包含了所有中间件的依赖, 但全都移除了方法体和实现, 只保留 class 和方法签名, 非常小, 供开发时的编译使用.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决本地开发运行:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;项目引入&quot;pandora boot&quot;, 所有项目第一句, &lt;code&gt;PandoraBootstrap.run(args)&lt;/code&gt;, 这也是收 springboot 启发, 在打包后, pandora-boot 会启动自己的 pandoraboot classloader 来管理类的加载, 实现不同中间件类加载的依赖隔离.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决中间件 sdk 的插件化:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;利用 spring-boot 的 starter 的方式, 引入不同的中间件依赖. 纳入 pandora-boot 的管理.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这几个事情听上去比较简单做起来还是挺复杂的! 就拿 pandora boot 这个自定义类加载来说, 既要考虑打成 jar 包之后的类加载方式和路径, 又要考虑开发时直接从 main 函数启动的类加载方式和路径.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_其他内容&quot;&gt;其他内容&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;演讲者也简单介绍一下他们的微服务中心, 主要是中间件, 容器管控, 监控, 提供一些应用管理能力. 介绍不多.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第二场_51信用卡在微服务架构下的监控平台架构实践&quot;&gt;第二场: 51信用卡在微服务架构下的监控平台架构实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个分享主要就是讲微服务监控, 分享者是51信用卡微服务监控平台的负责人.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个涉及业务比较少, 主要讲的是监控技术.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;微服务监控主要是: 日志监控, 链路监控, 指标监控.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;他们的监控平台通过拉业务日志, 又接受 push 事件的方式获取需要监控的内容, 使用的是一个 prometheus 的指标统计框架&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是由于微服务之后, 相互调用的日志和事件变多了, 又是金融项目, 要求记录详细, 机器扛不住了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以他们做了平台化:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&quot;拉取&quot; 和 &quot;推送&quot; 分别建立了不同的服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把获取到的监控内容发到转换服务器处理成 prometheus 支持的格式, 根据应用存到不同的存储实例上.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之后又做些优化点:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将时序型数据(用来做指标, 统计的那种, 比如一次 pv 打点) 和 非时序型数据(用来查看的, 比如日志) 分别用 Cassandra 和 es 存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标的 key 长度占用空间: 使用 bitmap 做枚举, 减小单个指标长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 druid 来解决预聚合, 维度合并, 减少指标数量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后还讲到了智能诊断:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当报警发生时, 会取报警前后日志, 尤其会去查找 ERROR, Exception 关键字.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有链路日志, 还会进行排序, 方便查看.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个监控的介绍打开了一些眼界, 毕竟作为业务开发者, 对监控这方面了解并不多. 这里列举的坑和解决办法可以在以后工作中提前考虑到.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第三场_京东阿基米德微服务平台&quot;&gt;第三场: 京东阿基米德微服务平台&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;阿基米德是京东一系列服务化支持框架的总称. 这次分享介绍了京东内部为了支持微服务所示用的各种框架和技术.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jsf&quot;&gt;JSF&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东服务框架, 微服务基础, 负责服务发现和注册, rpc 调用, 类似于 dubbo, 同时能够做到异地多活.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_containermesh&quot;&gt;ContainerMesh&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之前听过 ServiceMesh, 说是微服务的未来. 简略了解是提供一个微服务的容器, 具有检测死活, 流量控制, 注册与发现等功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总之, 是不需要每个服务自身再去关心去哪里注册和发现服务, 调用权限, 熔断, 监控等, 只需要做好你的服务放进来.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;极大的简化了服务部署的成本, 每个服务只需关心自己要发布什么功能, 要调用哪些功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东这个也是这个思路, 基于 google 的 Istio 开发. 包含在了自定义 linux 镜像里.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个仅仅是了解, 没有实践过, 这个算是服务化运维的范畴. 所以服务化不只是开发人员的工作, 更是运维人员的工作.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们其实也可以试试成熟的云平台上的容器服务. 公司也确实需要统一微服务的基础设施.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_调用图谱&quot;&gt;调用图谱&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;微服务统一基础设施后, 收集到的日志, 指标都可以统一处理, 形成调用图谱, 包含调用关系, 流量统计, 耗时等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如同玲姐的 dkimi 的效果.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_应用集市&quot;&gt;应用集市&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是我认为的亮点之一: 把大家的服务的信息集中起来, 分门别类. 一个服务是什么, 有哪些功能, 开发团队, 版本迭代都集中在应用集市上. 形成了公司内信息共享.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;同时, 一个功能可能有多个应用提供, 大家在选择的时候就能比较, 还可以反馈, 点赞, 评价.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不好用的服务, 不好的服务态度, 都会导致你的服务被淘汰. 而优秀的会在各方评价建议中不断进化.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个想法非常亮, 他们也在开发中, 说是五月要上线. 不知道推广起来怎么样.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_能力地图&quot;&gt;能力地图&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这又是个亮点! 看图:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/img/2018-beijing-qcon/能力地图.png&quot; alt=&quot;能力地图&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过微服务细分, 微服务添加自己的业务标签, 结合调用图谱, 就能形成可视的业务描述.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如下一个订单, 会经过那些功能模块的处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能让开发人员更直观熟悉项目, 也能让非开发人员(产品, 测试)对项目有所了解, 方便沟通, 价值很大!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结_2&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东这一套东西很实用, 想法也非常好. 他们是基础架构部一个专门的服务化治理组来做这些事情, 具体规模不太清楚.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第四场_saga分布式事务解决方案与实践&quot;&gt;第四场: Saga分布式事务解决方案与实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一场是一个实际技术应用的分享. 讲了一个使用 saga 方式解决分布式事务的库 ServiceComb. 演讲者是这个库的发起人, 目前已经维护到 apache 了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;分布式事务场景下, saga 其实是一个很容易想到的方案: 使用事件来触发业务逻辑执行, 再某一步出错后, 倒序向前执行 undo 事件. 通过最终一致性来保障事务.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但目前的问题是, 没有一个公认的, 成熟的 saga 实现. 反正我接触的都没用过, 大家都是自己写异步事件通知, 保证幂等, 加入补偿.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;他们就是想做这个事. 项目也是在开发中.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;说几点提到的比较有价值的地方:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务外柔内刚.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;意思是一个实例内部, 通过数据库保证刚性事务; 实例之间, 通过最终一致性保障柔性事务. 深以为然, 其实我们做的时候也是这么做的.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要期望框架能够做回滚操作&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是 saga 最长被挑战的部分, 有人就问了, 我用你这个框架, 出了错数据能够自动回滚吗. 这显然是想多了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;补偿操作, undo 操作, 都是要自己写.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以认为是你如果对一个 saga 事件要写一段业务逻辑, 就要同时把补偿和回滚的逻辑写了. 这个其实挺难得, 要考虑的很全面.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决隔离性的问题&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如分布式条件下对订单的操作, 要对订单加分布式锁, 来让对同一个订单的操作隔离.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个业务操作伴随一组 saga 事件&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如下单, 就有生成订单, 扣减库存等一些列事件. 这些事件看成是一个事务, 而不是互相独立, 需要统一saga协调器管理:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;saga start &amp;#8594; order create &amp;#8594; inventory 扣减 &amp;#8594; saga end&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐了论文:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf&quot;&gt;Distributed Sagas - Caitie McCaffrey&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://microservices.io/patterns/data/saga.html&quot;&gt;Microservice saga pattern - Chris Richardson&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_end&quot;&gt;end&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上是半天的收获, 其实也关注了点 团队建设与工程师个人成长 分会场的 ppt, 感觉也很不错, 以后再说吧.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>pac4j 简介</title>
      <link>http://blog.yangxiaochen.com/blog/java/pac4j%E7%AE%80%E4%BB%8B.html</link>
      <pubDate>Sun, 15 Apr 2018 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/pac4j%E7%AE%80%E4%BB%8B.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_什么是_pac4j&quot;&gt;什么是 pac4j&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_重要组件和概念&quot;&gt;重要组件和概念&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_client&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_authenticator&quot;&gt;&lt;strong&gt;authenticator&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_authorizer&quot;&gt;&lt;strong&gt;authorizer&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_matcher&quot;&gt;&lt;strong&gt;matcher&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_config&quot;&gt;&lt;strong&gt;config&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_user_profile&quot;&gt;&lt;strong&gt;user profile&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_web_context&quot;&gt;&lt;strong&gt;web context&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_security_filter&quot;&gt;&lt;strong&gt;security filter&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_callback_controller&quot;&gt;&lt;strong&gt;callback controller&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_logout_controller&quot;&gt;&lt;strong&gt;logout controller&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_流程&quot;&gt;流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_例子&quot;&gt;例子&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_spring_mvc_使用_pac4j_cas_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 进行登录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_spring_mvc_使用_pac4j_cas_和_buji_pac4jpac4j_for_shiro_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 和 buji-pac4j(pac4j for shiro) 进行登录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_什么是_pac4j&quot;&gt;什么是 pac4j&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;pac4j 是一个 java 的安全引擎.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在一套 api 下,&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供了很多种认证机制: form 表单登录, JWS, cas, OAuth 等等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了很多收授权和权限检查机制: role/permissions, CORS, CSRF, HTTP Security headers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了跟很多框架的整合和工具方式: springboot, play, shiro, spring security&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这些认证方式都是可插拔的, 你可以同时使用其中的一种或几种.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_重要组件和概念&quot;&gt;重要组件和概念&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_client&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;引入不同的认证包会包含不同的 Client 类, 每一种 Client 类就代表一种登录和认证方式. 比如:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 pac4j-cas, 里面就是 CasClient&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_authenticator&quot;&gt;&lt;strong&gt;authenticator&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Authenticator 是 client 的一个组件, 用来 validate credentials, 并且用来创建 user profile.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_authorizer&quot;&gt;&lt;strong&gt;authorizer&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是用来检测 user profiles 是否能够通过授权. pac4j 内置了很多 authorizer:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;StrictTransportSecurityHeader
XContentTypeOptionsHeader
XFrameOptionsHeader
XSSProtectionHeader
CacheControlHeader
CsrfAuthorizer
CsrfTokenGeneratorAuthorizer
CorsAuthorizer
IsAnonymousAuthorizer
IsAuthenticatedAuthorizer
IsFullyAuthenticatedAuthorizer
IsRememberedAuthorizer&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们也可以自己实现, 添加到 config 中的 authorizerMap&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_matcher&quot;&gt;&lt;strong&gt;matcher&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;matcher 通常用来判断一个请求, 是否要经过登录或认证.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;开发者可以在 config 中定义很多 matcher, 并定义每个请求路径要经过哪些 matcher.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果一个请求经过所有 matcher 判断结果都为 true, 那么才能进行认证检测&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果为 false, 则直接授权访问&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_config&quot;&gt;&lt;strong&gt;config&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;config 配置了要用到的 clients, authorizers, matchers&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_user_profile&quot;&gt;&lt;strong&gt;user profile&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;代表一个认证后的用户, 包括 id, 属性, 角色, 权限等.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_web_context&quot;&gt;&lt;strong&gt;web context&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是对一个请求的抽象, 包含了 request, response, session, 还有 pac4j 提供的其他的来辅助描述这次请求的数据.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_security_filter&quot;&gt;&lt;strong&gt;security filter&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;security filter 或者其他拦截 http 请求的机制. 根据 client 的不同来进行认证检查, 授权检查, 从而保护一个 url 地址.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果是没有认证的用户, 则尝试登录操作&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_callback_controller&quot;&gt;&lt;strong&gt;callback controller&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对与 &quot;间接 client&quot; indirect client, 比如需要在一个特殊页面进行登录, 而不是每个请求直接携带认证信息的 client.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在完成登录操作后需要调用 callback controller 最终完成登录操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_logout_controller&quot;&gt;&lt;strong&gt;logout controller&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行登出操作&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_流程&quot;&gt;流程&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常是一个请求过来, 访问一个 url A, 如果 A 需要被保护, 那么开发人员会设置需要先经过 &quot;security filter&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果 &quot;security filter&quot; 能从 &quot;web context&quot; 里获取到 &quot;user profile&quot;, 且 &quot;user profile&quot; 是登录状态, 那么通过认证, 允许访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果没有 &quot;user profile&quot;, 那么从 config 中获取改应用所支持的登录方式, 即配置的各种 clients.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先用 direct clients 来判断能否登录, 如果此时 http context 里包含了这类 client 所需要的登录信息, 比如 token, 则能够被授权成功访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果不行, 进行 indirect client 的登录方式, 跳转的特定的登录页.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在特定的登录页登录成功后, 回跳转回 &quot;callback controller&quot; 进行最后的登录操作, 即获取 &quot;user profile&quot; 并保存.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当退出是, 访问 &quot;logout controller&quot;, 执行退出.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_例子&quot;&gt;例子&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_spring_mvc_使用_pac4j_cas_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 进行登录&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_spring_mvc_使用_pac4j_cas_和_buji_pac4jpac4j_for_shiro_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 和 buji-pac4j(pac4j for shiro) 进行登录&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ShiroCasProperties&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;cas.shiro.login-url: http://passport.xxx.com:8088/cas/login
cas.shiro.callback-url: /callback
cas:
  shiro:
    filter-chain-definition-map:
      /page1: securityFilter
      /callback: callbackFilter
      /logout: logout&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;config 配置:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public Config config() {
    final CasConfiguration configuration = new CasConfiguration(shiroCasProperties.getLoginUrl());
    final CasClient casClient = new CasClient(configuration);
    casClient.setUrlResolver(new RelativeUrlResolver());
    final Clients clients = new Clients(shiroCasProperties.getCallbackUrl(), casClient);
    final Config config = new Config(clients);
    config.setSessionStore(new J2ESessionStore());
    return config;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;shiroFilter 配置:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public ShiroFilterFactoryBean shiroFilterFactoryBean() {

    final Config config = config();


    ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    securityManager.setRealm(new Pac4jRealm());
    shiroFilter.setSecurityManager(securityManager);
    shiroFilter.setFilterChainDefinitionMap(shiroCasProperties.getFilterChainDefinitionMap());
    shiroFilter.setFilters(new LinkedHashMap&amp;lt;String, Filter&amp;gt;() {{
        CallbackFilter callbackFilter = new CallbackFilter();
        callbackFilter.setConfig(config);
        put(&quot;callbackFilter&quot;, callbackFilter);
        SecurityFilter securityFilter = new SecurityFilter();
        securityFilter.setConfig(config);
        securityFilter.setClients(&quot;CasClient&quot;);
        put(&quot;securityFilter&quot;, securityFilter);
        LogoutFilter logoutFilter = new LogoutFilter();
        logoutFilter.setConfig(config);
        logoutFilter.setCentralLogout(true);
        put(&quot;logout&quot;, logoutFilter);
    }});
    return shiroFilter;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;完整源码见: TODO&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>jooq 介绍</title>
      <link>http://blog.yangxiaochen.com/blog/db/jooq-intro.html</link>
      <pubDate>Wed, 4 Apr 2018 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/db/jooq-intro.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_对比&quot;&gt;对比&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_jpa_hibernate&quot;&gt;jpa, hibernate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_mybatis&quot;&gt;mybatis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jdbc_template&quot;&gt;jdbc template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_我们的现状&quot;&gt;我们的现状&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jooq_是怎么做的&quot;&gt;JOOQ 是怎么做的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用方式&quot;&gt;使用方式&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_sql_builder_作为_sql_的构造器&quot;&gt;sql builder, 作为 sql 的构造器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_sql_executor_更进一步_作为_sql_执行器&quot;&gt;sql executor, 更进一步, 作为 sql 执行器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_typesafe_sql_builder_and_executor_作为强类型的_sql_构建和执行器&quot;&gt;typesafe sql builder and executor, 作为强类型的 sql 构建和执行器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_curd&quot;&gt;curd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_mapper&quot;&gt;mapper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_特性总结&quot;&gt;特性总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_缺点&quot;&gt;缺点&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_性能&quot;&gt;性能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_商业化&quot;&gt;商业化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jdk_要求&quot;&gt;jdk 要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_学习成本&quot;&gt;学习成本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;几乎每一个 java 程序员都要跟数据库打交道. 最常用的就是通过 java 的 jdbc 来跟数据库进行交互操作.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 jdbc 本身比较底层, 写起来比较繁琐, 于是产生了很多数据库抽象层的框架或者工具. 比如 JPA, Hibernate, Mybatis 等等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;今天介绍的 JOOQ 也是这样一个框架.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_对比&quot;&gt;对比&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们拿出最常用的一些数据抽象层框架来做比较: jpa, hibernate, mybatis, jdbc template.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jpa_hibernate&quot;&gt;jpa, hibernate&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;善于 CURD&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于针对单一对象的基础增删改查, 支持很到位, 这也是他们的立身之本.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ORM 依赖重&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于复杂查询, 关联查询, 配置复杂, 依靠对象 mapping 不灵活&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐藏了 sql&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;sql是大家都很熟悉的, 通过 sql 我们能够很直观的评估语句的性能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而这个框架隐藏了 sql, 不能直观知道我们对数据库切实执行了什么操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jSQL, HQL&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两个自创的类SQL语法应对复杂查询, 但是增加了学习成本.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;综上所述, 你要想在项目中用好 jpa 和 hibernate, 你需要有一个熟悉这两种框架的专家.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;即使这样, 在应对复杂查询的时候依然非常蹩脚.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_mybatis&quot;&gt;mybatis&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;mybatis 在一定程度上解决了一些 jpa 和 heibernate 不善于复杂查询和连表查询的问题, 这也是 mybatis 现在被广泛使用的原因.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家都看重 mybatis 能够自主掌控 sql 的能力.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但同时, mybatis 也有自己的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xml 繁杂&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;xml 本身就是一种复杂的格式, 加之 mybatis 要定义 ResultMap, 动态 sql 等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;改动时需要在代码跟 xml 间来回切换.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当一个字段改动时, 通常要 db &amp;#8594; model &amp;#8594; xml 改 sql &amp;#8594; xml 改 ResultMap 一套改一遍.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然可以codegen, 但复杂的不支持&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过代码生成插件可以解决上面那一些问题, 但是复杂的查询无法生成, 还需要自己写.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而且自己写的 sql 还不能在生成的 xml 和 dao 里, 不然重新生成时会有问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过注解定义查询&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看上去写起来也不简单, 我是没有试过.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jdbc_template&quot;&gt;jdbc template&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jdbc template 是 spring jdbc 提供的一个简单数据访问层框架, 以简单方便著称.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jdbcTempate 通过直接代码中写 sql, 然后定义 RowMapper 来将每一行的数据转化成需要的对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不保证 Typesafe&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写字符串形式的 sql, 需要人工保证字段名字都不写错.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 java 语言强类型的特性, 取出数据时需要指定类型.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RowMapper, dao 要自己实现, 重复工作多.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为没有代码生成的机制, RowMapper, dao 需要自己实现, 那么通常来说, 有多少数据对象, 就要生成多少 RowMapper 和 dao&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 java 是一个面向对象的语言, 所以很多框架都是用面向对象的方式来抽象数据访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然而, 借用 jooq 文档里的一句话:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SQL was never meant to be object-oriented. SQL was never meant to be anything other than&amp;#8230;&amp;#8203; SQL!&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;传统 ORM 解决的问题是 &lt;code&gt;程序中对象&lt;/code&gt; &amp;#8592;&amp;#8594; &lt;code&gt;数据库存储&lt;/code&gt; 的对应, 提供了一套面向对象的封装, 屏蔽了 jdbc 的复杂性.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 jdbc template 等非 orm 的框架提供了完全控制 sql 的能力但无法提供 ORM 提供的强类型映射, 需要开发人员大量的重复编码.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_我们的现状&quot;&gt;我们的现状&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在我们的项目中, 几乎无法避免要使用到关系型数据库, 无法避免要使用 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是, 我们对 sql 的使用可以分成两种类型:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;50% ~ 80% 的 CURD&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;基础的 CURD 是项目中最常见的使用方式, 增删改查一个实体.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们在写业务逻辑的时候, 就是获取各种实体数据, 然后通过计算更改数据, 再将数据保存.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;20% ~ 50% query&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果项目中只有 CURD, 那么生活将会非常美好. 然而项目中总是免不了需要复杂的 sql 来实现的功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如列表查询, 往往需求比较个性化, 一行的数据可能涉及多个数据表.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这种需求虽然现在可以通过冗余存储的方式来解决, 但通常还是用连表查询配合缓存来完成, 有时还会涉及到聚合查询, 可变条件等情况.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;传统 ORM 对于这种情况就会显得力不从心.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_jooq_是怎么做的&quot;&gt;JOOQ 是怎么做的&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 是要来解决上面问题的. JOOQ 通过大量的流式 API 来灵活构建一个 SQL. 下面通过 JOOQ 的几种使用方式来体验下 JOOQ 的特性:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_使用方式&quot;&gt;使用方式&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sql_builder_作为_sql_的构造器&quot;&gt;sql builder, 作为 sql 的构造器&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    String s = DSL.select(DSL.field(&quot;id&quot;), DSL.field(&quot;title&quot;), DSL.field(&quot;published_in&quot;))
            .from(&quot;book&quot;).getSQL();
    System.out.println(s);
}

{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .getSQL();
    System.out.println(s);
}

{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .where(DSL.field(&quot;book.author_id&quot;).eq(2))
            .and(&quot;published_in = 1990&quot;)
            .getSQL();
    System.out.println(s);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不需要数据源, 不需要代码生成, 使用 &lt;code&gt;org.jooq.impl.DSL&lt;/code&gt; 来构建 sql 语句, 来看一下输出结果:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-console&quot; data-lang=&quot;console&quot;&gt;select id, title, published_in from book
select * from book join language as `a` on (book.language_id = a.id)
select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过 jooq 的 api, 可以构建出满足我们需要的简单或复杂的 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sql_executor_更进一步_作为_sql_执行器&quot;&gt;sql executor, 更进一步, 作为 sql 执行器&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jooq 构建 sql 之后, 可以作为 sql 的执行器来运行 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;首先, 利用数据源建立 DSLContext 对象, 下面需要执行的例子都会使用这个对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;DSLContext sql;

@Before
public void before() {
    MysqlDataSource mysqlDataSource = new MysqlDataSource();
    mysqlDataSource.setDatabaseName(&quot;jooq_test&quot;);
    mysqlDataSource.setUser(&quot;root&quot;);
    mysqlDataSource.setPassword(&quot;&quot;);
    sql = DSL.using(mysqlDataSource, SQLDialect.MYSQL);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行构建好的 sql 语句&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .where(DSL.field(&quot;book.author_id&quot;).eq(2))
            .and(&quot;published_in = 1990&quot;)
            .getSQL();
    sql.execute(s, 2);
    sql.resultQuery(s, 2).fetch();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;11:44:36.067 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))
11:44:36.068 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = 2 and (published_in = 1990))
11:44:36.660 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))
11:44:36.660 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = 2 and (published_in = 1990))
11:44:36.760 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+
11:44:36.760 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                          |published_in|language_id|new_field|  id|cd  |description|
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahaha|        1990|          2|        0|   2|de  |Deutsch    |
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上是我们通过 jooq api 和自己拼写 sql 字符串的方式执行 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_typesafe_sql_builder_and_executor_作为强类型的_sql_构建和执行器&quot;&gt;typesafe sql builder and executor, 作为强类型的 sql 构建和执行器&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一步我们要借助 jooq 的 code generator 来生成数据库的描述文件.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;code generator 有 gradle 和 maven 的插件可以使用. 我是用的是 gradle 插件, 我的测试使用配置如下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-gradle&quot; data-lang=&quot;gradle&quot;&gt;plugins {
    id &apos;nu.studer.jooq&apos; version &apos;2.0.9&apos;
    id &apos;java&apos;
}

dependencies {

    jooqRuntime(&apos;mysql:mysql-connector-java:5.1.44&apos;)

    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;
    testCompile &apos;org.slf4j:slf4j-api:1.7.21&apos;
    testCompile &apos;ch.qos.logback:logback-core:1.2.3&apos;
    testCompile &apos;ch.qos.logback:logback-classic:1.2.3&apos;

    testCompile(&apos;org.jooq:jooq:3.10.6&apos;)
    testCompile(&apos;mysql:mysql-connector-java:5.1.44&apos;)
}

jooq {
    sample(sourceSets.main) {
        jdbc {
            driver = &apos;com.mysql.jdbc.Driver&apos;
            url = &apos;jdbc:mysql://localhost:3306/test&apos;
            user = &apos;root&apos;
            password = &apos;&apos;
        }
        generator {

            database {
                name = &apos;org.jooq.util.mysql.MySQLDatabase&apos;
                inputSchema = &apos;jooq_test&apos;
                outputSchemaToDefault = true

            }

            generate {
                relations = true
                deprecated = false
                records = true
                immutablePojos = true
                fluentSetters = true
                daos = true
                // ...
            }
            target {
                packageName = &apos;com.yangxiaochen.jooq&apos;
                // directory = ...
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-console&quot; data-lang=&quot;console&quot;&gt;./gradlew generateSampleJooqSchemaSource&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;生成代码.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;生成之后, 就可以使用了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    Result&amp;lt;Record3&amp;lt;Integer, Integer, String&amp;gt;&amp;gt; result = sql.select(BOOK.ID, BOOK.AUTHOR_ID, LANGUAGE.DESCRIPTION)
        .from(BOOK).join(LANGUAGE)
            .on(BOOK.LANGUAGE_ID.eq(LANGUAGE.ID))
            .where(BOOK.PUBLISHED_IN.eq(1990))
            .fetch();
    Integer id = result.get(0).getValue(BOOK.ID);
    Integer authorId = result.get(0).get(&quot;author_id&quot;, Integer.class);
    String desc = result.get(0).value3();
    System.out.println(id + &quot; &quot; + authorId + &quot; &quot; + desc);

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:06:40.515 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = ?
12:06:40.516 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = 1990
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------+
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|description|
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Deutsch    |
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
4 2 Deutsch&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以看到, jooq 通过生成数据库描述代码来保证强类型, 当数据库发生变动, 可以重新生成.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_curd&quot;&gt;curd&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 针对 CURD 生成基本代码, 来避免重复编码. JOOQ 对 CURD 的支持主要氛围 record 和 dao 两种方式, 可以一起使用:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BookRecord bookRecord = sql.selectFrom(BOOK).where(BOOK.ID.eq(4)).fetchOne();
System.out.println(bookRecord);
bookRecord.setTitle(bookRecord.getTitle() + &quot;ha&quot;);
bookRecord.store();

BookRecord bookRecord1 = sql.newRecord(BOOK);
bookRecord1.setAuthorId(2);
bookRecord1.setLanguageId(1);
bookRecord1.setTitle(&quot;hello&quot;);
bookRecord1.setPublishedIn(2018);
bookRecord1.store();

System.out.println(bookRecord1);

BookDao bookDao = new BookDao(sql.configuration());
List&amp;lt;Book&amp;gt; books = bookDao.fetchByAuthorId(2);
System.out.println(books.get(0));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:18:55.420 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`id` = ?
12:18:55.422 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`id` = 4
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                              |published_in|language_id|new_field|
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahahahaha|        1990|          2|        0|
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------------------------------+------------+-----------+---------+
+----+---------+-----------------------------------+------------+-----------+---------+
|  id|author_id|title                              |published_in|language_id|new_field|
+----+---------+-----------------------------------+------------+-----------+---------+
|   4|        2|Bridahahahahahahahahahahahahahahaha|        1990|          2|        0|
+----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.198 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : update `book` set `book`.`title` = ? where `book`.`id` = ?
12:18:56.199 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : update `book` set `book`.`title` = &apos;Bridahahahahahahahahahahahahahahahaha&apos; where `book`.`id` = 4
12:18:56.240 [main] DEBUG org.jooq.tools.LoggerListener - Affected row(s)          : 1
12:18:56.250 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : insert into `book` (`author_id`, `title`, `published_in`, `language_id`) values (?, ?, ?, ?)
12:18:56.250 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : insert into `book` (`author_id`, `title`, `published_in`, `language_id`) values (2, &apos;hello&apos;, 2018, 1)
12:18:56.268 [main] DEBUG org.jooq.tools.LoggerListener - Affected row(s)          : 1
12:18:56.270 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id` from `book` where `book`.`id` = ?
12:18:56.271 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id` from `book` where `book`.`id` = 19
12:18:56.291 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  19|
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+
+----+---------+-----+------------+-----------+---------+
|  id|author_id|title|published_in|language_id|new_field|
+----+---------+-----+------------+-----------+---------+
|  19|        2|hello|        2018|          1|   {null}|
+----+---------+-----+------------+-----------+---------+
12:18:56.305 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`author_id` in (?)
12:18:56.306 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`author_id` in (2)
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                                |published_in|language_id|new_field|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   3|        2|O Alquimista                         |        1988|          4|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahahahahaha|        1990|          2|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  10|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  11|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  12|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |...7 record(s) truncated...
Book (3, 2, O Alquimista, 1988, 4, 0)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_mapper&quot;&gt;mapper&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 还提供了内置的映射功能, 方便我们进行对象的转换&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; public static class R {
    public Integer id;
    public Integer authorId;
    public String description;

    @Override
    public String toString() {
        return &quot;R{&quot; +
                &quot;id=&quot; + id +
                &quot;, authorId=&quot; + authorId +
                &quot;, description=&apos;&quot; + description + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}

@Test
public void mapping() {

    List&amp;lt;R&amp;gt; r = sql.select(BOOK.ID, BOOK.AUTHOR_ID, LANGUAGE.DESCRIPTION)
            .from(BOOK).join(LANGUAGE)
            .on(BOOK.LANGUAGE_ID.eq(LANGUAGE.ID))
            .where(BOOK.PUBLISHED_IN.eq(1990)).fetch().into(R.class);

    r.forEach(it -&amp;gt; System.out.println(it));
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:23:00.964 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = ?
12:23:00.965 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = 1990
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------+
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|description|
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
12:23:01.863 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Deutsch    |
12:23:01.863 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
R{id=4, authorId=2, description=&apos;Deutsch&apos;}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_特性总结&quot;&gt;特性总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 提供了方便流式 API 用于构建各种各样的 SQL&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过代码生成数据库描述文件, 提供了类型安全保障, 代码与数据库的映射&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过生成 record, dao 等方式支持了 curd, 无需再写基础代码.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;内置映射功能方便了对象之间的转化.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 还有其他很多特性比如: 反过来通过代码描述生成数据库, 支持 xml 读写 等等. 不在本文讨论范围.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_缺点&quot;&gt;缺点&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 也有自身的缺点和局限, 或者说在使用时需要考虑的地方&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_性能&quot;&gt;性能&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 在提供了方便的同事, 在以下几个阶段都会有额外的性能开销.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;construct jOOQ queries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;render SQL strings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bind values to prepared statements&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fetch results&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上面这些开销, 可以自己来设置一些缓存来减小开销, 比如保存和复用 Query 对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而且, 这个开销并不大, 引用官方文档的描述:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jOOQ&amp;#8217;s overhead compared to plain JDBC is typically less than 1ms per query.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个查询的额外开销是 1ms 以内.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_商业化&quot;&gt;商业化&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jooq 是个商业软件, 售价不菲. 但我们可以使用开源版本.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;商业版本针对的是商业数据库比如 oracle, sqlServer 等, 并且会提供技术支持.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jdk_要求&quot;&gt;jdk 要求&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比较新的开源版 jooq 要求 jdk8 以上&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_学习成本&quot;&gt;学习成本&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;
* 生成器配置比较复杂. 需要一个找一个同事来阅读文档称为配置专家, 当然也可以直接找一些比较通用的配置, 比如我这次进行测试的这个配置就可以满足大多数的需求.
* DSL写法需要看文档. 但文档很全, 比如想知道 &lt;code&gt;group by&lt;/code&gt; 怎么写直接文档中搜索就好.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;示例完整源码 &lt;a href=&quot;https://github.com/yxc023/code-examples/blob/master/java/jooq/src/test/java/com/yangxiaochen/example/jooq/JOOQTest.java&quot; class=&quot;bare&quot;&gt;https://github.com/yxc023/code-examples/blob/master/java/jooq/src/test/java/com/yangxiaochen/example/jooq/JOOQTest.java&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>方法论总结</title>
      <link>http://blog.yangxiaochen.com/blog/设计思想/%E6%96%B9%E6%B3%95%E8%AE%BA.html</link>
      <pubDate>Sun, 5 Nov 2017 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/设计思想/%E6%96%B9%E6%B3%95%E8%AE%BA.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_项目构建和组织&quot;&gt;项目构建和组织&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_why_gradle&quot;&gt;why gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_not_use_gradle&quot;&gt;why not use gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_controller_参数接收与验证_exception_handle&quot;&gt;controller 参数接收与验证, exception handle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_unit_test_mock&quot;&gt;unit test, mock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_领域驱动在审批流的一些使用&quot;&gt;领域驱动在审批流的一些使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_一些心得和方法论&quot;&gt;一些心得和方法论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_完结&quot;&gt;完结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_项目构建和组织&quot;&gt;项目构建和组织&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_gradle&quot;&gt;why gradle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可读性好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件生态丰富&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活定义脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更快更智能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很多开源项目是 gradle 构建&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_not_use_gradle&quot;&gt;why not use gradle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;maven 语法定义更严格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总结: gradle 进阶有一定学习成本, 重在积累.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_controller_参数接收与验证_exception_handle&quot;&gt;controller 参数接收与验证, exception handle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用 spring mvc + validator 验证方法参数.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定类型的参数接收, 不用自己显示调用 json 转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一异常处理, 对 spring mvc error 的自定义处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api 文档, swagger
&amp;gt; adoc, 转为 csv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;debug 输出堆栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一接口验证?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_unit_test_mock&quot;&gt;unit test, mock&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不爱写测试 &amp;#8594; 尝到甜头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试代码 == 项目代码, 封装测试基础设施&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建数据case, 不能避免.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BDD&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_领域驱动在审批流的一些使用&quot;&gt;领域驱动在审批流的一些使用&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;service层组织&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常组织&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领域对象能够反映更可视化的实体关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能将设计切实的落实到代码. eg. completeJob(Long jobId)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_一些心得和方法论&quot;&gt;一些心得和方法论&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调研和定位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口设计角度问题, 从使用者角度出发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api 是否要抛出 exception&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重构一往无前没有回头路, 方向正确最重要&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;_完结&quot; class=&quot;sect0&quot;&gt;完结&lt;/h1&gt;

	</description>
    </item>
    <item>
      <title>spring boot mvc 文件上传错误</title>
      <link>http://blog.yangxiaochen.com/blog/java/spring-mvc-multipart-error.html</link>
      <pubDate>Tue, 5 Sep 2017 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/spring-mvc-multipart-error.html</guid>
      	<description>
	&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;今天有一个项目，是从 tomcat 迁移到 spring boot 的。&lt;/p&gt;
&lt;p&gt;实测中发现，文件上传不进来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public JsonResult createBpmn(@RequestParam Long businessId, @RequestParam(value = &amp;quot;file&amp;quot;, required = false) MultipartsFile bpnmFile) {
  // 此时 bpmnFile == null 
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;排查&lt;/h2&gt;
&lt;p&gt;文件上传的处理逻辑是在 &lt;code&gt;DispatherServlet.checkMultipart()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {
		if (this.multipartResolver != null &amp;amp;&amp;amp; this.multipartResolver.isMultipart(request)) {
			if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {
				logger.debug(&amp;quot;Request is already a MultipartHttpServletRequest - if not in a forward, &amp;quot; +
						&amp;quot;this typically results from an additional MultipartFilter in web.xml&amp;quot;);
			}
			else if (hasMultipartException(request) ) {
				logger.debug(&amp;quot;Multipart resolution failed for current request before - &amp;quot; +
						&amp;quot;skipping re-resolution for undisturbed error rendering&amp;quot;);
			}
			else {
				try {
					return this.multipartResolver.resolveMultipart(request);
				}
				catch (MultipartException ex) {
					if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
						logger.debug(&amp;quot;Multipart resolution failed for error dispatch&amp;quot;, ex);
						// Keep processing error dispatch with regular request handle below
					}
					else {
						throw ex;
					}
				}
			}
		}
		// If not returned before: return original request.
		return request;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug 可以看到当前项目中使用的用来支持上传的组件 &lt;code&gt;multipartResolver&lt;/code&gt;  是 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; 类型&lt;/p&gt;
&lt;p&gt;简单看了下这个类型的 resolver 逻辑是从 request 的 inputStream 中读取上传文件。&lt;/p&gt;
&lt;p&gt;但是发现这里 request 的 inputStream 是空的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;DispatherServlet.doDispatch()&lt;/code&gt; 方法开头，也就是所有请求要进行 contoller 分发时，request 的 inputStream 也就已经空了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;
		boolean multipartRequestParsed = false;

// 此时有断点，使用 IDEA 的 debug 工具 执行 IOUtil.toString(request.getInputStream)
// 发现输出为空
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这说明 inputStream 被读过了&lt;/p&gt;
&lt;p&gt;然后就在 Request 对象的 getInputStream 方法上打了断点。&lt;/p&gt;
&lt;p&gt;发现是在一个 filter 的逻辑里，最终调用了 getInputStream 方法，从调用栈的方法名字们看，也有 uploadFile 字眼&lt;/p&gt;
&lt;p&gt;这个 filter 是 &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; , 看了 doc 和代码。这个 filter 的作用大概是：因为现在浏览器只支持 get 和post，为了能支持更多的方法诸如 put ，delete 等，就约定了一个参数名叫 _method 来指定这些不支持的方法，比如 _mothod=put , 就是这次请求在之后的处理中会被当做 put 来处理。&lt;/p&gt;
&lt;p&gt;这个 filter 读取了 inputStream，并把文件加入到了 request 的属性 parts 中。这里的 request 是 tomcat 的实现的，因为内置容器是 tomcat。&lt;/p&gt;
&lt;p&gt;这就有问题了，这个 filter 把 inputStream 给读了，后面的 multipartResolver 就读不到了。&lt;/p&gt;
&lt;p&gt;这个 filter 的 doc 中有一段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NOTE: This filter needs to run after multipart processing in case of a multipart POST request, due to its inherent need for checking a POST body parameter. So typically, put a Spring org.springframework.web.multipart.support.MultipartFilter before this HiddenHttpMethodFilter in your web.xml filter chain.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说我们要把 &lt;code&gt;MultipartFilter&lt;/code&gt; 写在前面，前置执行。&lt;/p&gt;
&lt;p&gt;但是，看了一眼 &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; 可是 &lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt; 中定义的，按道理说，这个是个标准化的，不应该由我们在做什么处理才能用拿到 upload 的 file。&lt;/p&gt;
&lt;p&gt;其实，如果 multipartResolver 如果直接从 request 的 parts 属性中拿 file 不就行了，不从 inputSream 中读。spring boot 一套应该是把这些都搞定得了。&lt;/p&gt;
&lt;p&gt;后来看 &lt;code&gt;MultipartAutoConfiguration&lt;/code&gt; ，里面注册了个 multipartResolver，但类型是 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;看了 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt; 的实现，果然是从 request 的 parts 属性中取。&lt;/p&gt;
&lt;p&gt;所以，原因出来了：&lt;/p&gt;
&lt;p&gt;是在项目迁移的过程中遗留了 mvc 的 xml 配置，里面配置了 multipartResolver，类型指定为 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; , 去掉后就ok了。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;spring mvc 提供了两种 multipartResolver：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CommonsMultipartResolver&lt;/code&gt;：从 request 的 inputStream 中读取文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandardServletMultipartResolver&lt;/code&gt;：使用 &lt;code&gt;HttpServletRequest.getParts()&lt;/code&gt; 方法来获取文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;spring boot 使用的自动配置的一个 filter &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; 会比较早的时候读取 request 的 inputStream，导致 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; 无法在获取到数据。所以 spring boot mvc 默认是用 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt;，用错 resolver 会导至上传文件读不到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HttpServletRequest.getParts()&lt;/code&gt; 方法是 servlet 3.0 之后获取  &lt;code&gt;multipart/form-data&lt;/code&gt; 类型的请求数据的一个标准方法，凡是实现了 servlet 3.0 的服务器都支持，可以尽量使用 StandardServletMultipartResolver&lt;/p&gt;
&lt;/blockquote&gt;

	</description>
    </item>
    <item>
      <title>gradle简明教程</title>
      <link>http://blog.yangxiaochen.com/blog/java/gradle%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html</link>
      <pubDate>Mon, 24 Jul 2017 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/gradle%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_安装&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_打开一个_gradle_项目&quot;&gt;打开一个 gradle 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_新建一个_gradle_项目&quot;&gt;新建一个 gradle 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_常见问题&quot;&gt;常见问题&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_插件选择&quot;&gt;插件选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_build速度慢&quot;&gt;build速度慢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何debug&quot;&gt;如何debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_私服使用和包管理混乱引起的问题&quot;&gt;私服使用和包管理混乱引起的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_常用命令或参数&quot;&gt;常用命令或参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_依赖冲突处理&quot;&gt;依赖冲突处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_交流&quot;&gt;交流&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文没有 gradle 与 maven 对比，也没有深入 gradle 实现。只有 gradle 从 0 开始使用的说明。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个 gradle 项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入一个 gradle 项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交流
&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_简介&quot;&gt;简介&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gradle 是一个构建工具。负责管理项目依赖，组织项目结构，完成项目构建的工作。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_安装&quot;&gt;安装&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;从 官网 下载，解压即可，并将 bin/gradle 命令加入到 path 中。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_打开一个_gradle_项目&quot;&gt;打开一个 gradle 项目&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常, 大家首次接触 gradle 是遇到一个 gradle 作为构建工具项目.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;观察基于 gradle 构建的项目结构, 通常有以下几个文件:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;build.gradle                      // 重要, 构建脚本文件，主要的构建配置都在这里写
gradlew                           // gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
gradlew.bat                       // gradle wrapper 执行脚本文件的 windows 版
gradle
|- wrapper
   |- gradle-wrapper.properties   // 重要, 描述了 gradlew 使用的 gradle 版本
   |- gradle-wrapper.jar          // gradlew 执行时用到的 jar, 无需关注
settings.gradle                   // 项目配置，指明根项目名字和引入的 module&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;./gradlew tasks&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能够列出所有可用的构建命令. 这时如果是第一次运行 gradle, 且本地没有缓存过 gradle-wrapper.properties 中描述的 gradle 版本, 则会去 gradle-wrapper.properties 指的的 url 去下载 gradle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是这个官方地址的 gradle 下载通常会比较慢, 所以如果是要给同事分享 gradle 项目时, 可以把 gradle 提前下载到内网, 然后将 gradle-wrapper.properties 中的下载地址改成内网的地址.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 idea 打开这个项目, 也就是 open build.gradle 文件, 就可以引入项目了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_新建一个_gradle_项目&quot;&gt;新建一个 gradle 项目&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;新建一个文件夹作为项目文件夹&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
mkdir project-example
cd project-example
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 gradle 初始化&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
gradle init
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;然后目录下会生成这些文件&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
build.gradle     // 构建脚本文件，主要的构建配置都在这里写
gradle           // 存放gradle wrapper 执行配置和工具的文件夹，
gradlew          // gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
gradlew.bat      // gradle wrapper 执行脚本文件的 windows 版
settings.gradle  // 项目配置，指明根项目名字和引入的 module
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 build.gradle 文件，结果像下面这样&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
/*
声明插件，声明插件的方式有两种，下面这种是 2.* 版本之后的新的定义方式。可以声明两种插件：
1. 官方内置插件，如 java，idea。
2. 在 gradle 插件中心注册过的插件，如第三个就是，这种要还要声明版本。
声明插件的目的是因为插件会提供很多 task，而每一个 task 就是一段构建脚本，可以执行不同的任务。比如 compileJava，test 等。
*/
plugins {
    id &apos;java&apos;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明 group 和 版本，而 project 的名字在 settings.gradle 文件中，而子 module ，或者又称为 sub projects 的名字通常和文件夹名字一样。
*/
group &apos;com.yangxiaochen.gradle&apos;
version &apos;1.0.0-SNAPSHOT&apos;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明依赖仓库，这里使用的是 jcenter，也可以使用其他的如 mavenCentral 等。也可以声明多个，会按顺序查找。
*/
repositories {
    jcenter()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明依赖
*/
dependencies {
    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;
    testCompile &apos;junit:junit:4.12&apos;
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;   编辑 settings.gradle 文件如下，声明了project name
   ```
   rootProject.name = &apos;project-example&apos;
   // include &apos;sub-project&apos;
   ```
4. 用 idea open build.gradle 文件.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_插件选择&quot;&gt;插件选择&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;内置插件都在官方文档中有说明，除了内置插件外, 可以 [Search Gradle plugins](&lt;a href=&quot;https://plugins.gradle.org/)，gradle&quot; class=&quot;bare&quot;&gt;https://plugins.gradle.org/)，gradle&lt;/a&gt; 插件的官方仓库。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_build速度慢&quot;&gt;build速度慢&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;速度慢一般来说是依赖更新慢，因为众所周知的原因，国内使用国外的仓库速度并不乐观，所以可以替换`repositories`, 使用阿里云的仓库&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;repositories {
  maven {
  	url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再者, 有的同学使用私服, 可能是公司搭建的. 这个有时候会有不稳定, 且有时需要认证的情况. 看稍后的章节.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_如何debug&quot;&gt;如何debug&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gradle 运行中的提示并不算很友好, 尤其在链接仓库和下载jar包时, 在连接有问题的时候, 经常没有提示(新版本的可能好一些.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;经常使用&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;gradle idea -i
gradle idea -id

还可以加入 --no-daemon 参数来避免daemon启动产生的日志干扰
gradle idea -id --no-daemon
一般来说就能定位到构建问题.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;来获取更多的信息. 比较常见的卡住是因为`仓库链接不上`, &lt;code&gt;jar包下载链接不上, 又不返回 response (私有仓库偶尔有问题)&lt;/code&gt;, &lt;code&gt;资源下载缓慢&lt;/code&gt;, &lt;code&gt;仓库需要认证登陆&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;仓库连接不上: 检查仓库地址, 检查网络.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源无法连接又没有response: 这种通常会在上面打出的日志中体现, 请求一个 url 便没有响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载缓慢: 更换仓库, 或者忍耐下第一次, 以后会好很多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 IDEA 刷新有问题时, 可以执行这个命令debug, 一般这个命令能成功, 那么 IDEA 刷新通常也能成功. (请注意版本问题, 命令行里执行的 gradle 版本需要跟 IDEA 里配置的 gradle 版本一致)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_私服使用和包管理混乱引起的问题&quot;&gt;私服使用和包管理混乱引起的问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;私服使用中会有以下问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;不稳定, 偶尔服务无响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置出错, 无法 proxy maven 主仓库. 或者出现私服中存在第三方包但是却不完整到时无法下载.&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;一般来说会尝试把第三方仓库配置到私服之前:&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
maven {
  url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;maven {
  url &quot;http://你家私服地址/&quot;
  credentials {
    username &quot;xxx&quot;
    password &quot;xxx&quot;
  }
  authentication {
  	basic(BasicAuthentication)
  }
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;这样先去第三方查找, 再到私服查找.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;私服有认证. 可以参照第二条私服的认证方式. 其中&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
  authentication {
  	basic(BasicAuthentication)
  }
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;是可选填的, 不填的话会自动识别认证方式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包方式不完整. 有的同学上传包的时候虽然包含了编译后的jar包, pom文件, 但是有时却没有把source包上传, gradle 默认是会下载source的, 如果没有, 私服返回404还好, 最怕会卡主(遇到过私服虽然没有这个文件却迟迟不返回response的情况.), 所以, 如果遇到这种问题, 可以:&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
idea {
	module {
		downloadJavadoc = false
		downloadSources = false
	}
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;不让 IDEA 刷新的时候下载源码和文档, 万不得已还是不要用.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_常用命令或参数&quot;&gt;常用命令或参数&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--refresh-dependencies&lt;/code&gt;   刷新依赖，刷新那些SNAPSHOT的依赖，类似于 maven 的 -U 参数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle tasks&lt;/code&gt; 列出所有可执行的task&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle tasks --all&lt;/code&gt; 列出所有可执行的task, 并附加上 mudole&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle help --task taskName&lt;/code&gt;  查看一个task的帮助, 不过并不是所有task都有, 因为task都是可以自己来实现的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle idea -id&lt;/code&gt; 用来debug IDEA进行刷新时遇到的问题, 一般这个任务能成功, 刷新就能成功. 注意使用的 gradle 版本要一致.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--no-daemon&lt;/code&gt; 不是使用daemon进行构建. daemon的作用是不用每次 build 都再启动一个进程, 节省时间. 但却会在我们 debug 问题的时候不停的生产日志, 产生干扰.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_依赖冲突处理&quot;&gt;依赖冲突处理&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以通过命令来查看一个项目的依赖&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gradle webapp:dependencies --configuration=compile&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不同于maven的&lt;strong&gt;最近&lt;/strong&gt;原则，gradle 依赖使用的是&lt;strong&gt;最新&lt;/strong&gt;原则. 比如你构建处于依赖顶层的 module , 那么版本会优先使用这个顶层module 的`build.grale` 中定义的版本. 所以可以在顶层module 中强制定义版本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;依赖排除, 通常可以使用&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) {
    exclude module: &quot;spring-boot-starter-logging&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样的语法, 还有更为粗暴直接的:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;configurations {
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-classic&apos;
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-core&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;官方文档相当的详细，且附有很多example，配合 gradle 安装包里的 example 源文件阅读&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_交流&quot;&gt;交流&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;欢迎加入群 661035226，gradle，spring，activiti 交流&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Java web 项目异常设计实践</title>
      <link>http://blog.yangxiaochen.com/blog/java/%E5%BC%82%E5%B8%B8%E5%AE%9E%E8%B7%B5.html</link>
      <pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/%E5%BC%82%E5%B8%B8%E5%AE%9E%E8%B7%B5.html</guid>
      	<description>
	&lt;h1&gt;异常实践&lt;/h1&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文是我在项目中设计和处理异常的一些实践，主要是围绕着常见的web项目，欢迎大家指正。&lt;/p&gt;
&lt;p&gt;本文分为两个个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异常设计&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2&gt;异常设计&lt;/h2&gt;
&lt;p&gt;通常考虑异常设计时大致分为三个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口层&lt;/li&gt;
&lt;li&gt;业务层&lt;/li&gt;
&lt;li&gt;类库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接口层就是我们通常说的 controller 层，以及提供 rpc 服务的接口层。&lt;/p&gt;
&lt;p&gt;业务层就是主要的业务代码模块，主要是 service 层。&lt;/p&gt;
&lt;p&gt;类库主要是指一些公共模块，可以在各个项目中使用的，比如 json，分布式锁等。&lt;/p&gt;
&lt;h3&gt;业务层&lt;/h3&gt;
&lt;p&gt;在业务层，我们主要是要设计&lt;strong&gt;业务异常&lt;/strong&gt;。什么是业务异常？业务异常就是我们能够人为的判断出业务逻辑走到某一个位置是不对的。比如，我们要根据一个 uid 来修改一个 user 的 name，但我们发现并没有这个 uid 对应的 user 数据，这时候就应该抛出一个业务异常。在发生业务异常时，要避免抛出 npe，RuntimeException 等其他内置异常，以方便上层来分辨到底是业务错误还是程序 bug。&lt;/p&gt;
&lt;p&gt;我一般会设计一个业务异常的基类 &lt;code&gt;ServiceException&lt;/code&gt;，将所有业务异常以这种类型来抛出，并带有必要的 message。&lt;/p&gt;
&lt;p&gt;为了把用户可读的消息和开发人员可读的消息区别开，&lt;code&gt;ServiceException&lt;/code&gt; 还需要实现一个接口 &lt;code&gt;UserMessage&lt;/code&gt;，并实现其中方法 &lt;code&gt;getUserMessage()&lt;/code&gt;来返回用户可读的信息，而 getMessage() 可以携带更详细的开发人员可读的错误信息&lt;/p&gt;
&lt;p&gt;设计一个 &lt;code&gt;ServiceErrorException&lt;/code&gt;，继承 &lt;code&gt;ServiceException&lt;/code&gt;。&lt;code&gt;ServiceErrorException&lt;/code&gt; 的主要目的是为了表明这个异常的错误程度高，需要记录 error。&lt;/p&gt;
&lt;p&gt;以上就定型了业务异常的基本结构，上面一些特殊设计会在&lt;strong&gt;异常处理&lt;/strong&gt;中用到，我们后面来说，再做前后对照。我们可以根据需要来实现若干子类来表示业务层中不同模块的错误。&lt;/p&gt;
&lt;h3&gt;接口层&lt;/h3&gt;
&lt;p&gt;对于接口层，特别是rpc调用，比如我们的dubbo调用，需要把api的jar包放在调用方。我们需要把异常类给包括进去，但调用方不能也不应该拿到我们业务层的 &lt;code&gt;ServiceException&lt;/code&gt;，所以需要在接口层定义新的业务异常类型，比如，就叫&lt;code&gt;ApiServiceException&lt;/code&gt;，放在api的jar包里给调用方。&lt;/p&gt;
&lt;p&gt;接口实现需要把业务层的&lt;code&gt;ServiceException&lt;/code&gt;给catch到，重新封装为&lt;code&gt;ApiServiceException&lt;/code&gt;抛出。&lt;/p&gt;
&lt;p&gt;这样，调用方在判断调用时发生的异常时，有三种可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rpc框架异常。比如又dubbo框架抛出的异常，这一版两种可能：1. 网络异常，我们需要重试；2. 调用未能达成，这种一般是接口没有匹配上，在开发测试时都可以发现的错误，改掉即可。所以，当发生rpc框架异常时，调用方的策略就应该是重试。&lt;/li&gt;
&lt;li&gt;ApiServiceException。这表示被调用方出现了业务异常，调用方也需要作为业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。这表示被调用方的程序有bug报出了异常透传给了调用方，这是调用方应及时联系接口实现方来修补bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就能够分类准确应对rpc过程中的异常情况。&lt;/p&gt;
&lt;p&gt;http方式的接口层也可以这么做，不过由于api并不对外，所以也可以完全由自身来处理异常类型，详见&lt;strong&gt;异常处理&lt;/strong&gt;部分。&lt;/p&gt;
&lt;h3&gt;类库&lt;/h3&gt;
&lt;p&gt;作为类库，因为通常没有业务意义，所以在发生逻辑上的异常时，根本不可能知道需要怎么处理，这就需要直接向上抛出，到交给业务层处理。&lt;/p&gt;
&lt;p&gt;类库需要将自身的逻辑上的异常，同一封装。比如，处理 Json 的类库，异常最终抛出时，都被封装成为&lt;code&gt;JsonParseException&lt;/code&gt; 或 &lt;code&gt;JsonSerializeExcption&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样调用方使用类库时，异常会有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类库封装的自定义异常。这种是调用时出现的逻辑错误，调用方以业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。可以认为是类库bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;p&gt;有了以上的异常设计，那么处理时就可以按照以下流程。&lt;/p&gt;
&lt;p&gt;以 http 请求的 ExceptionHandler 为例，所有 http 请求异常都会放在这里处理，过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ex 异常传入。&lt;/li&gt;
&lt;li&gt;装饰 ex 异常，&lt;code&gt;ex = new WebApiException(...,ex)&lt;/code&gt;，其包含有 &lt;code&gt;message&lt;/code&gt;，&lt;code&gt;isLogError&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;如果 ex 是非 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = “系统内部错误”&lt;/code&gt;，&lt;code&gt;isLogError = true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 ex 是 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = ex.getUserMessage()&lt;/code&gt;；更进一步，如果是 &lt;code&gt;ServiceErrorException&lt;/code&gt;，那么&lt;code&gt;isLogError = true&lt;/code&gt;，否则 &lt;code&gt;isLogError = false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ex.isLogError == true&lt;/code&gt;，记录 error log，否则，记录 warn log。&lt;/li&gt;
&lt;li&gt;判断 http 请求是页面请求，还是ajax请求。&lt;/li&gt;
&lt;li&gt;如果是页面请求。500转错误页，显示 &lt;code&gt;ex.getMessage()&lt;/code&gt;，如果是debug环境或者是请求带有debug参数，也把错误堆栈输出在页面上。&lt;/li&gt;
&lt;li&gt;如果是 ajax 请求。返回表示错误的 json 消息，同样，如果是debug环境或者是请求带有debug参数，消息中带上堆栈信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就是一个简单而有效的异常处理机制。&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>spring &amp; spring mvc 初始化介绍</title>
      <link>http://blog.yangxiaochen.com/blog/java/spring+%26+spring+mvc+%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%8B%E7%BB%8D.html</link>
      <pubDate>Thu, 30 Mar 2017 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/spring+%26+spring+mvc+%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%8B%E7%BB%8D.html</guid>
      	<description>
	&lt;!-- # spring &amp; spring mvc 初始化介绍 --&gt;
&lt;h2&gt;web项目的结构&lt;/h2&gt;
&lt;h3&gt;java servlet 技术&lt;/h3&gt;
&lt;p&gt;java servlet 技术是 java 的一个 web 服务规范, 提供了统一的 servlet api 供各个容器厂商实现, 以保证一个 java web 项目可以运行在不同厂商的服务器下.&lt;/p&gt;
&lt;p&gt;请看实例简单复习下 servlet, listner, filter&lt;/p&gt;
&lt;p&gt;listner, filter 会在 web 容器启动时执行 init 方法&lt;/p&gt;
&lt;p&gt;servlet 会在第一次访问时进行初始化. 当然也可以设置 init on start&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3&gt;非 servlet 规范的 java web 项目&lt;/h3&gt;
&lt;p&gt;使用netty作为服务器lib, 加入 http 协议的处理层,  自行完成处理 http 请求读写&lt;/p&gt;
&lt;h3&gt;spring mvc 的的封装&lt;/h3&gt;
&lt;p&gt;我们最常用到的 spring mvc 框架就是对 servlet 技术的封装, 在 web.xml 中加入实现 &lt;code&gt;Listenner&lt;/code&gt; 的 &lt;code&gt;SpringContextListener&lt;/code&gt; 和实现了 &lt;code&gt;Servlet&lt;/code&gt; 的 &lt;code&gt;DispatcherServlet&lt;/code&gt;, 来对spring 和 spring mvc 进行初始化.&lt;/p&gt;
&lt;h2&gt;spring context 结构&lt;/h2&gt;
&lt;p&gt;spring context 是整个 spring 的核心, 通常也被叫做 spring 容器. 通常讲的 spring 初始化过程, 就是初始化 spring context 的过程.&lt;/p&gt;
&lt;p&gt;根据应用不同, 使用的 spring  context 类型也不同&lt;/p&gt;
&lt;h3&gt;继承树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/context继承.png&quot; alt=&quot;context继承.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;常见的 war 包形式的 web 应用, 使用的是 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;spring boot 默认使用的是 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;重要组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 通用组件, 负责 bean 注册和初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Environment&lt;/code&gt; 通用组件 , 包含系统参数, 启动参数等. 还有对启动参数解析后的属性, 比如 profile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationListener&lt;/code&gt;s 通用组件, 保存注册进来的context事件listener&lt;/li&gt;
&lt;li&gt;一些 context 状态标志, parent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContext&lt;/code&gt;, &lt;code&gt;ServletConfig&lt;/code&gt; WebApplicationContext类里特有的&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些特定的参数. 在特定context类型中, 比如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/** Default config location for the root context */
public static final String DEFAULT_CONFIG_LOCATION = &amp;quot;/WEB-INF/applicationContext.xml&amp;quot;;

/** Default prefix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_PREFIX = &amp;quot;/WEB-INF/&amp;quot;;

/** Default suffix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_SUFFIX = &amp;quot;.xml&amp;quot;;	
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;spring context 初始化过程概念概览&lt;/h2&gt;
&lt;p&gt;一个 spring context 的初始化过程大致分为以下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取并设置系统参数, 环境变量, 获取一些初始化 context 需要的组件, 比如 ApplicationContextInitializer 等.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个属于context 初始化的前置逻辑, 由应用自己控制, 我们也可自己来写, 用来给后面 context 初始化做准备&lt;/p&gt;
&lt;p&gt;这一步根据应用不同差别很大, 比如传统 war 包的 ContextLoadListner 和 spring boot 的 SpringApplication 中的逻辑就很不同.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create context&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据应用不通, 创建不同的 context&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;configure context&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用第1步获得的参数和组件, 来配置创建好的 context&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;context.refresh&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心步骤, context 初始化的具体过程就在这里.&lt;/p&gt;
&lt;p&gt;包括分门别类的加载各种特殊的 bean, 然后加载普通的ben&lt;/p&gt;
&lt;h2&gt;spring 初始化过程实例概览(非 spring boot 的传统war包)&lt;/h2&gt;
&lt;h3&gt;ContextLoaderListener&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt; 配置在 web.xml 中, 在容器启动时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/ContextLoaderListener.png&quot; alt=&quot;ContextLoaderListener.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3) 决定spring web app context类型. 不指定的情况下默认策略创建 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16) 以 bean 的 configuration 文件, 就是一般我们说的xml文件 为入口, 加载 &lt;code&gt;BeanDefinition&lt;/code&gt; 到 bean factory. 注意仅仅是加载 bean 的描述, 而没有实例化这些 bean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;17) 实例化执行所有的 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;, 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中和 context 的 &lt;code&gt;beanFactoryPostProcessors&lt;/code&gt; 字段中查找.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;是意图在 bean factory 加载了所有定义的 bean 定义之后, 且在这些 bean 实例化之前, 做一些操作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一步通常在调用各个 processor 时, 产生新的 bean 定义到 bean factory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;18) 注册 &lt;code&gt;BeanPostProcessor&lt;/code&gt; , 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中查找.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 会在之后每个 bean 实例化之后调用, 用来对 bean 做一些其他操作, 比如放入一些参数:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt; 的作用就是注入 &lt;code&gt;@Autowired&lt;/code&gt; 字段.&lt;/p&gt;
&lt;p&gt;生成动态代理对象也是通过  &lt;code&gt;BeanPostProcessor&lt;/code&gt; 实现的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;21) &lt;code&gt;onRefresh&lt;/code&gt; 是用来初始化其他的特殊的 bean, 这部分逻辑通常在特殊的 context 子类实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如在 spring boot 中使用的 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt; 中, 会在这里初始化并启动内嵌服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;22) 将在  &lt;code&gt;BeanDefinition&lt;/code&gt; 中的, 还有之前设置到context属性中的  &lt;code&gt;ApplicationListener&lt;/code&gt; 加到广播列表中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;23) 将  &lt;code&gt;BeanDefinition&lt;/code&gt;  中其他的非懒加载的 bean 实例化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;24) 实例化并调用 &lt;code&gt;LifecycleProcessor&lt;/code&gt; , 然后广播 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;26) 将 context 放到 &lt;code&gt;ServletContext&lt;/code&gt; 的 attribute 属性里, 之后 &lt;code&gt;DispatcherServlet&lt;/code&gt; 初始化会用到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;*以上说的 bean 均为 singleton 的 scope&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;DispatcherServlet&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 配置在 web.xml 中, 在第一次访问时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/DispatcherServlet.png&quot; alt=&quot;DispatcherServlet.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5) 以 &lt;code&gt;ContextLoaderListener&lt;/code&gt;创建的 context 为 parent, 创建新的 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;8) 创建一个 &lt;code&gt;ContextRefreshListener&lt;/code&gt; , 加入到 context 中, 监听 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;9) refresh 过程跟&lt;code&gt;ContextLoaderListener&lt;/code&gt; 一样, 不同的是在查找 bean 时, 能够查到 parent context 的 bean, 供新的 context 初始化使用.&lt;/li&gt;
&lt;li&gt;10) 触发  &lt;code&gt;ContextRefreshedEvent&lt;/code&gt; , 初始化 spring mvc 的组件, 添加到 &lt;code&gt;DispatcherServlet&lt;/code&gt; 中.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一些特殊类型Bean的初始化时机 (待完善, 请持续补充)&lt;/h2&gt;
&lt;h3&gt;BeanFactoryPostProccesor&lt;/h3&gt;
&lt;p&gt;context refresh 之后, 初始化好 factory 之后, 会先执行 context 自身的 factory post 操作, 然后就会执行  &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt;  这种类型 bean 所定义的 factory post 操作.&lt;/p&gt;
&lt;h3&gt;BeanDefinitionRegistryPostProcessor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 的子类, 执行优先级比 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 要高. 通常可以通过 order 来控制&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt; 类型的执行顺序, 还跟这个 bean 定义的时机有关, 在 prepare context 阶段定义的总会最先执行.&lt;/p&gt;
&lt;p&gt;通常自定义的 xml 和 bean 配置 会在这个阶段被定义到 factory.&lt;/p&gt;
&lt;h3&gt;BeanPostProccesor&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 都执行完之后实例化, 并 apply 到 factory ,  在一个 bean 初始化之后会被调用.&lt;/p&gt;
&lt;h3&gt;Aware&lt;/h3&gt;
&lt;p&gt;如 &lt;code&gt;ApplicationContextAware&lt;/code&gt; , 实现这个接口的 bean 会由一个 &lt;code&gt;BeanPostProccesor&lt;/code&gt; 类型的  &lt;code&gt;ApplicationContextAwareProcessor&lt;/code&gt; 在初始化之后 set 一个 application context&lt;/p&gt;
&lt;p&gt;Aware 相关类的很多, 都类似&lt;/p&gt;
&lt;h3&gt;ApplicationListener&lt;/h3&gt;
&lt;p&gt;用来监听 context 生命周期中各个事件的类, 可以在 prepare 和 refresh 阶段注入&lt;/p&gt;
&lt;h3&gt;ApplicationContextInitializer&lt;/h3&gt;
&lt;p&gt;prepare context 阶段执行, 在 context refresh之前执行. 可以对 context 注入 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 和 &lt;code&gt;ApplicationListener&lt;/code&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Java异常规范</title>
      <link>http://blog.yangxiaochen.com/blog/java/%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83.html</link>
      <pubDate>Thu, 29 Sep 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83.html</guid>
      	<description>
	&lt;h1&gt;异常规范&lt;/h1&gt;
&lt;h2&gt;异常介绍&lt;/h2&gt;
&lt;h4&gt;Throwable&lt;/h4&gt;
&lt;p&gt;所有Exception和Error的父类.&lt;/p&gt;
&lt;h4&gt;Error&lt;/h4&gt;
&lt;p&gt;致命错误. 项目自身存在问题, 诸如格式有问题, 编译版本不对, 堆栈溢出等, 项目在出现ERROR的情况下是不应该运行的. 同时, 程序遇到Error时, 程序不需要, 通常也是没有能力做处理的, 只能够停止程序针对项目或者运行环境做人工处理才行.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4&gt;Exception&lt;/h4&gt;
&lt;p&gt;区别于Error, 是程序可以自己处理的异常. Exception的子类中, 特殊的RuntimeException被称为&lt;strong&gt;运行时异常&lt;/strong&gt;, 也叫&lt;strong&gt;非受检异常&lt;/strong&gt;; 其他的子类包括Exception类本身都叫&lt;strong&gt;受检异常&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;受检异常&lt;/h5&gt;
&lt;p&gt;Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。&lt;/p&gt;
&lt;h5&gt;非受检异常(运行时异常)&lt;/h5&gt;
&lt;p&gt;不需要强制catch或者throw的异常.&lt;/p&gt;
&lt;h2&gt;程序中如何使用异常&lt;/h2&gt;
&lt;p&gt;程序中我们主要关注&lt;strong&gt;受检异常&lt;/strong&gt;和&lt;strong&gt;运行时异常&lt;/strong&gt;的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些原则, 这些原则并不独立, 互相之间有照应或者补充:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发生可恢复错误的抛出受检异常，程序错误就抛出运行时异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用运行时异常. 从保障代码简洁, 清晰, 有意义的角度上来说.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意绝对不是无脑把受检异常换为运行时异常.&lt;/p&gt;
&lt;p&gt;很多时候我们要延迟处理异常: 比如我们的一个受检异常在层次很深的地方抛出, 但是我们在代码层次很高的地方才能做处理, 那么受检异常会出现在代码调用的每一层. 这非常繁琐, 也不清晰.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谨慎抛出受检异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;受检异常是不受欢迎的.&lt;/p&gt;
&lt;p&gt;除非你认为你是在强调这个异常, 调用者在大多数情况下需要重点关注这个异常并catch这个异常并做处理.&lt;/p&gt;
&lt;p&gt;使用运行时异常带来的简洁并不能够弥补开发人员忽略了这个异常带来的问题时.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为定位是类库的模块, 尽量使用运行时异常, 并对java低层异常封装, 抛出类库特有的概括性的异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当站在调用者的角度, 可以获悉这个类库有哪几种异常, 出现时代表什么了.&lt;/p&gt;
&lt;p&gt;移位类库的调用很多时候跟业务没有关系, 当出现错误时, 通常是因为我们的代码漏洞造成的, 这并不能简单通过try_catch进行恢复, 所以尽量不使用受检异常.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为定位是服务的模块, 可以使用一些受检异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为当调用服务出现错误, 一般是一个可以解释的业务错误, 如果是想要调用者非常注意的错误, 可以使用受检异常.&lt;/p&gt;
&lt;p&gt;服务的调用一般代码层次比较浅, 并且是和业务比较相关的.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务异常需要单独封装成新的异常来表达一类或者一个模块的业务错误, 可以使用受检异常. 但也参照1, 2, 3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以把一些非业务异常封装成为业务异常, 如果你知道在这个地方这种非业务异常在业务上可以表达一些含义.&lt;/p&gt;
&lt;p&gt;比如某个位置抛出了json解析异常, 我们可以说传入的某个数据格式是错误的.&lt;/p&gt;
&lt;p&gt;为了给大家建立异常体系结构, 业务异常定义为受检异常, 强制让大家关注下.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非业务异常, 代码底层异常, 如果出现的话可以定义为代码bug的, 使用运行时异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使没有catch住的后果是在系统运行时抛给了用户, 也不应该catch. 当然在项目中需要一个最高层次的异常处理, 对非业务异常统一catch记录报警而不要暴露给用户&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务异常如果可以, 不要跨层(跨模块)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;controller -&amp;gt; service -&amp;gt; adaptor -&amp;gt; UC dubbo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UC dubbo 抛出的异常, 应该在adaptor或者service做处理封装新的异常, 不要让controller直面UC dubbo的异常.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异常应该携带更多信息.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尤其对业务异常来说, 知道异常发生时的业务数据是很重要的, 方便查找定位问题.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在api层(controller层), 将一些业务异常封装为API异常, 这类异常将直接给用户api异常的提示, 且有时可以认为这些异常是正常的, 不需要报警的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效的业务异常类划分和异常code定义, 有助于统一处理异常时区别异常的等级合适否需要报警.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在设计异常时请考虑这一点.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果不知道自己的异常应该是使用受检异常还是运行时异常, 使用运行时异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先报出错误, 不做对未知的设计&lt;/p&gt;
&lt;h2&gt;如何处理异常&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;绝对禁止catch后什么都不做!&lt;/li&gt;
&lt;li&gt;在catch之后封装成新异常抛出的时候, 不要记录日志. 因为你抛出了, 会有上层来处理记录日志, 只要没有1这种情况, 总会有信息的. 这里再记录日志就重复了.&lt;/li&gt;
&lt;li&gt;在需要时一定要使用上finally&lt;/li&gt;
&lt;li&gt;处理异常时记录的日志一般要把异常的堆栈给记录下来.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;具体实施方案&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;所有类库&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/fn-commons&quot;&gt;fn-commons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/common-search&quot;&gt;common-search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个项目, master打tag, 切新版本分支, 升级大版本, 例如1.0 -&amp;gt; 2.0&lt;/p&gt;
&lt;p&gt;目标: 基本都是用运行时异常,减轻调用负担, 看情况决定是否自定义异常. 类库尽量少记log, 尤其不能记info的log. 这个出log规范的时候再说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重点项目&lt;a href=&quot;http://git.lianjia.com/fnrd/fnrd-gte&quot;&gt;fnrd-gte&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;切个exception-refactor分支&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新类库依赖. 更改由依赖更新引起的代码错误.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中在service包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;adaptor&lt;/p&gt;
&lt;p&gt;新建一个RPCException, 继承RuntimeException, 替换现有的直接用RuntimeException抛出.&lt;/p&gt;
&lt;p&gt;RPCException可以带一些请求参数信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api包&lt;/p&gt;
&lt;p&gt;强烈建议使用&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;, 不过涉及较多, 可以逐步改改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;impl包, 核心流程逻辑&lt;/p&gt;
&lt;p&gt;重点处理的位置, 挨个文件看, 然后从低向上重构&lt;/p&gt;
&lt;p&gt;定义FlowException作为主要流程业务异常, 统一处理时将会使用其中msg通知用户, &lt;strong&gt;非FlowException将会统一封装友好提示&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;可以定义更加细致的异常继承FlowException异常, 以应对更细致的需要.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;event, listner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易, 金融业务相关的增删改查service等.&lt;/p&gt;
&lt;p&gt;可以新定义FnServiceExcetion, TeServiceException, 也作为一类业务异常.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller&lt;/p&gt;
&lt;p&gt;选择性的对一些异常封装, WebApiException, msg直接给用户显示.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

	</description>
    </item>
    <item>
      <title>git实际开发语句</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-use.html</link>
      <pubDate>Mon, 4 Jul 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/git/git-in-use.html</guid>
      	<description>
	&lt;!-- # git实际使用指南 --&gt;
&lt;h2&gt;dev上工作git指南&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切到&lt;code&gt;dev&lt;/code&gt;分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b bug/JRTE-333-问题描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/JRTE-333-需求描述
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.....
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提交分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起&lt;code&gt;merge request&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;登陆git.lianjia.com发起
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一切正常, 就结束了. 如果发现&lt;code&gt;merge request&lt;/code&gt;有冲突, 不能合并, 转 &lt;code&gt;7&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;merge request&lt;/code&gt;有冲突&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到&lt;code&gt;dev&lt;/code&gt;, 更新之.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git co dev
git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切回你的分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git co [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rebase! 难以理解而又复杂的一步. 但做过一次你就会了!&lt;/p&gt;
&lt;p&gt;进行rebase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git rebase dev&lt;/code&gt; 的意思是将&lt;code&gt;你的分支&lt;/code&gt;上的每一次提交, 应用到&lt;code&gt;dev&lt;/code&gt;分支的尾部.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果提示有冲突, 转&lt;code&gt;7.5&lt;/code&gt;. 如果没有冲突:&lt;/p&gt;
&lt;p&gt;因为你push过你的分支, 所以&lt;code&gt;远程你的分支&lt;/code&gt;和&lt;code&gt;本地你的分支&lt;/code&gt;已经不一致了. 所以强行覆盖&lt;code&gt;你的远程分支&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push -f origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你就发现你的&lt;code&gt;merge request&lt;/code&gt;显示可以自动合并了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冲突, 然后根据提示执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add [冲突文件]
git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果还有冲突, 转&lt;code&gt;7.5&lt;/code&gt;, 如果没有, 转&lt;code&gt;7.4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如果出现以下情况, 很有可能你就错了&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把&lt;code&gt;dev&lt;/code&gt;上的代码merge到分支:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;dev&lt;/code&gt;上merge分支代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在dev上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在任何分支上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;合并为一次提交&lt;/h2&gt;
&lt;h3&gt;方法一&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始version]
git add .
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法二, 保证没有冲突, 且合并为一次提交!&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;4. 提交分支&lt;/code&gt; 时, 先更新&lt;code&gt;dev分支&lt;/code&gt;, 然后在&lt;code&gt;你的分支&lt;/code&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase dev -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把除了第一个&lt;code&gt;pick&lt;/code&gt;全改成&lt;code&gt;s&lt;/code&gt;或者&lt;code&gt;squash&lt;/code&gt;. 提示很全, 试试吧.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git分支管理与使用规范</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-action.html</link>
      <pubDate>Tue, 21 Jun 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/git/git-in-action.html</guid>
      	<description>
	&lt;!-- # git分支管理与使用规范 --&gt;
&lt;h2&gt;分支管理&lt;/h2&gt;
&lt;h3&gt;flow&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git flow&lt;/li&gt;
&lt;li&gt;github flow&lt;/li&gt;
&lt;li&gt;gitlab flow&lt;/li&gt;
&lt;li&gt;fn flow&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3&gt;分支与开发定义&lt;/h3&gt;
&lt;h4&gt;主要分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;master&lt;/p&gt;
&lt;p&gt;线上分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;develop&lt;/p&gt;
&lt;p&gt;常规开发分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;masterfix&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;辅助分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;feature/*&lt;/p&gt;
&lt;p&gt;功能开发分支, 从develop分支而来, 然后合并入develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;release/*&lt;/p&gt;
&lt;p&gt;上线分支, 从develop分支而来, 然后合并入master, 并应用到develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hotfix/*&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 从masterfix分支而来, 然后合并入masterfix, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;如何使用各种分支&lt;/h3&gt;
&lt;h4&gt;init&lt;/h4&gt;
&lt;p&gt;一个项目初始有master分支, 需要新建立一个develop分支和masterfix分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git br -b develop 
git push origin develop

git br -b masterfix
git push origin masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;feature&lt;/h4&gt;
&lt;p&gt;常规功能开发需要从develop分支checkout出feature分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/GET-1008-添加用户查询列表 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发完毕后合并回develop分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git pull // 先更新develop
git merge feature/GET-1008-添加用户查询列表 --no-ff
git push origin develop

git branch -d feature/GET-1008-添加用户查询列表
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Release&lt;/h4&gt;
&lt;p&gt;开发完毕, 准备发布:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b release/1.0.0 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在发布分支上处理一些发布操作, 比如更改版本号, 上线前测试, 问题修改等等. 当分支可以进行上线发布后:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge release/1.0.0 --no-ff 
git tag -a 1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此release完成, 但是需要将在release分支上的修改应用到develop上.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge release/1.0.0 --no-ff

git branch -d release/1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, 我们可以激活masterfix分支, 同步一下已经上线的master分支, 为修改将要出现的线上bug做准备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge master // 在正常情况下, 这里一定是fast-faward
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;hotfix&lt;/h2&gt;
&lt;p&gt;当出现bug时, 我们需要从master或者是masterfix分支上分出hotfix分支来修改bug.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b hotfix/修改空指针 masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完毕后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge hotfix/修改空指针 --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;期间可以进行多次hotfix, 最后当masterfix测试后没有问题, 准备上线:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在master上打下当前上线的tag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag -a 1.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样, 这些修改要应用到develop分支上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;分支与环境对应?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;master    --  online&lt;/li&gt;
&lt;li&gt;release   --  off&lt;/li&gt;
&lt;li&gt;develop   --  ci&lt;/li&gt;
&lt;li&gt;masterfix --  online-bug-fix&lt;/li&gt;
&lt;li&gt;feature   --  local, dev&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;h2&gt;使用规范&lt;/h2&gt;
&lt;h3&gt;鼓励开分支&lt;/h3&gt;
&lt;p&gt;鼓励本地开分支开发, 独立功能独立分支.&lt;/p&gt;
&lt;h3&gt;将分支上提交合并&lt;/h3&gt;
&lt;p&gt;分支上开发的commit建议合并为一个commit, 这样易读, 方便主分支管理.&lt;/p&gt;
&lt;p&gt;一种最简单直接的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始处]
git commit -m &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法, 在feature分支上执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i develop // 将feature分支的修改应用到develop上

// 后续操作
http://www.ruanyifeng.com/blog/2015/08/git-use-process.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;保留分支信息&lt;/h3&gt;
&lt;p&gt;在不同分支合并时使用 &lt;code&gt;--no-ff&lt;/code&gt; 参数生成merge commit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commit e562022b423f7bf29f77927dea4d13cb05230681
Merge: d88f815 799b7f8
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:41 2016 +0800

    Merge branch &apos;feature/welcome&apos; into develop

commit 799b7f87b99d5f5c49acf2edd8a6a363ff44f29f
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:11 2016 +0800

    也修改auth

commit 18e7893f1583559003f7a4bb41fd03b937b3ed42
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:08:04 2016 +0800

    修改 auth
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;减少以及消除无意义的分支内merge&lt;/h3&gt;
&lt;p&gt;同一分支更新时要避免产生无意义的merge&lt;/p&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;h3&gt;冲突提交&lt;/h3&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;常用操作&lt;/h3&gt;
&lt;p&gt;回滚&lt;br /&gt;
git reset --hard [version]  // 丢弃版本后的所有修改&lt;br /&gt;
git reset [version]         // 保留版本后的所有已提交修改&lt;br /&gt;
git reset --soft [version]  // 保留版本后的所有已提交修改到commit stage&lt;/p&gt;
&lt;p&gt;补充提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交tag到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志与diff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sourcetree // 软件
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-workflow.html&quot;&gt;Git 工作流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/08/git-use-process.html&quot;&gt;合并commit&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git-flow实践</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-flow-in-action.html</link>
      <pubDate>Sun, 12 Jun 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/git/git-flow-in-action.html</guid>
      	<description>
	&lt;!-- # git-flow 操作实践 --&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;brew install git-flow
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2&gt;init&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ git flow init

Initialized empty Git repository in ~/project/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master]
Branch name for &amp;quot;next release&amp;quot; development: [develop]

How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时会在当前目录执行git init操作. 并且生成4个分支名字, 并且默认在develop分支上, develop分支就是我们主要工作的地方.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
* develop
master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们除了要把master分支推到远端仓库, develop同样也要推到远端仓库 &lt;code&gt;git push origin develop&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Feature branches&lt;/h2&gt;
&lt;p&gt;开始一个新功能添加, 或者是一般bug修复, 或者是其他功能. 我们需要开一个feature分支. 我们在本地的主要工作都是要开feature分支完成的. ** 不要在develop 分支上开发. **&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature start authentication
Switched to a new branch &apos;feature/authentication&apos;

Summary of actions:
- A new branch &apos;feature/authentication&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;feature/authentication&apos;

Now, start committing on your feature. When done, use:

    git flow feature finish authentication
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以做自己的修改了, 完成后, 需要将feature合并回develop分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature finish authentication
Switched to branch &apos;develop&apos;
Updating 9060376..00bafe4
Fast-forward
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch feature/authentication (was 00bafe4).

Summary of actions:
- The feature branch &apos;feature/authentication&apos; was merged into &apos;develop&apos;
- Feature branch &apos;feature/authentication&apos; has been removed
- You are now on branch &apos;develop&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;多个开发者进行开发时, 会出现每个人本地的develop分支不一致的情况, 这样在每次拉取远端develop分支时, 会出现很多merge提交. 关于这个问题, 在最后的&lt;code&gt;减少以及消灭无用的merge commit&lt;/code&gt;章节中说明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;releases&lt;/h2&gt;
&lt;p&gt;在没有使用git-flow工具时, 发布是一件很繁琐的事情, 要保留一个用于releases的分支, 打tag等. 使用git-flow可以用简单命令解决.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release start 0.1.0
Switched to a new branch &apos;release/0.1.0&apos;

Summary of actions:
- A new branch &apos;release/0.1.0&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;release/0.1.0&apos;

Follow-up actions:
- Bump the version number now!
- Start committing last-minute fixes in preparing your release
- When done, run:

    git flow release finish &apos;0.1.0&apos; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你将开始一个发布, 一般可以直接finishi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release finish 0.1.0
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch release/0.1.0 (was 1b26f7c).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Release branch has been merged into &apos;master&apos;
- The release was tagged &apos;0.1.0&apos;
- Release branch has been back-merged into &apos;develop&apos;
- Release branch &apos;release/0.1.0&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时develop分支回合并到master分支, 并打tag. 之后我们只要把master和tag都推到远端仓库即可.&lt;/p&gt;
&lt;h2&gt;Hotfixing production code&lt;/h2&gt;
&lt;p&gt;紧急bug修复, 在已经发布的代码上更正. 会从master开出hotfix分支, 然后合并回master, 也会合并回develop.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix start assets
Switched to a new branch &apos;hotfix/assets&apos;

Summary of actions:
- A new branch &apos;hotfix/assets&apos; was created, based on &apos;master&apos;
- You are now on branch &apos;hotfix/assets&apos;

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

    git flow hotfix finish &apos;assets&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改问题, 之后提交:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix finish assets
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Deleted branch hotfix/assets (was 08edb94).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Hotfix branch has been merged into &apos;master&apos;
- The hotfix was tagged &apos;0.1.1&apos;
- Hotfix branch has been back-merged into &apos;develop&apos;
- Hotfix branch &apos;hotfix/assets&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在往下阅读之前, 你最好将以上的命令实践一遍, 感受git-flow的操作与分支流向. 推荐SourceTree来跟踪变化.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;减少以及消灭无用的merge commit&lt;/h2&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然, 操作的疏忽依然会产生无意义的commit, 但这并不致命, 注意就好.&lt;/p&gt;
&lt;p&gt;如果真的要消灭无意义commit: 在你&lt;code&gt;git pull&lt;/code&gt;之后发现自动合并了, 那么用&lt;code&gt;git reset --hard [刚刚你本地的提交commit version]&lt;/code&gt;进行本地版本回滚, 然后再&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我对rebase的理解也不是很多, 以上只是应用中的使用体会, 肯定还存在很多没有想到的情况和处理不当的地方, 请大家多提出来指正, 共同讨论.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&quot;&gt;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&quot;&gt;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

	</description>
    </item>
    <item>
      <title>java 多线程同步的几种写法</title>
      <link>http://blog.yangxiaochen.com/blog/java/thread-coordinate-n-methods.html</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/java/thread-coordinate-n-methods.html</guid>
      	<description>
	&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回字的四种写法&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;假设有三个比较耗时的非cpu密集型任务, 最后的结果分些需要这三个任务的结果相加, 使用多线程并发可以让三个任务同时进行.
&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面是几种写法:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;package com.yangxiaochen;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Semaphore;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/**
 * @author yangxiaochen
 * @date 16/4/14 上午12:17
 */
public class ForkJoinTest {&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m1() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m1&quot;);
    return 1;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m2() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m2&quot;);
    return 2;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m3() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m3&quot;);
    return 3;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    public static void main(String[] args) throws ExecutionException, InterruptedException {
        type0();
//        type1();
//        type2();
//        type3();
//        type4();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type0() throws InterruptedException {
    ForkJoinTest test = new ForkJoinTest();
    class Holder {
        int a;
        int b;
        int c;
    }
    Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t1 = new Thread(() -&amp;gt; h.a = test.m1());
t1.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t2 = new Thread(() -&amp;gt; h.b = test.m2());
t2.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t3 = new Thread(() -&amp;gt; h.c = test.m3());
t3.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    t1.join();
    t2.join();
    t3.join();
    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type4() throws InterruptedException {
    Semaphore semaphore = new Semaphore(0);&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTest test = new ForkJoinTest();
class Holder {
    int a;
    int b;
    int c;
}
Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.a = test.m1();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.b = test.m2();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.c = test.m3();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    semaphore.acquire(3);
    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type3() throws InterruptedException {
    ForkJoinTest test = new ForkJoinTest();
    class Holder {
        int a;
        int b;
        int c;
    }
    Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.a = test.m1();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.b = test.m2();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.c = test.m3();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;synchronized (test) {
    test.wait();
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type2() throws InterruptedException, ExecutionException {
    ForkJoinTest test = new ForkJoinTest();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;FutureTask&amp;lt;Integer&amp;gt; f1 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m1());
FutureTask&amp;lt;Integer&amp;gt; f2 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m2());
FutureTask&amp;lt;Integer&amp;gt; f3 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m3());&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(f1).start();
new Thread(f2).start();
new Thread(f3).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    System.out.println(f1.get() + f2.get() + f3.get());
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type1() throws InterruptedException, ExecutionException {&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTest test = new ForkJoinTest();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTask&amp;lt;Integer&amp;gt; f1 = ForkJoinTask.adapt(() -&amp;gt; test.m1()).fork();
ForkJoinTask&amp;lt;Integer&amp;gt; f2 = ForkJoinTask.adapt(() -&amp;gt; test.m2()).fork();
ForkJoinTask&amp;lt;Integer&amp;gt; f3 = ForkJoinTask.adapt(() -&amp;gt; test.m3()).fork();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;        System.out.println(f1.join() + f2.join() + f3.join());
    }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>从一个丢失的iphone看互联网信息安全</title>
      <link>http://blog.yangxiaochen.com/blog/secure/a-lost-iphone-secure.html</link>
      <pubDate>Mon, 4 Apr 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/secure/a-lost-iphone-secure.html</guid>
      	<description>
	&lt;!-- # 一个真实故事 --&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;妹子把手机丢了...是在上公交车时, 妹子第二个上车, 头一个上去的黑色羽绒服男上车后问师傅是否去XX地, 师傅说不去, 黑羽绒服男就又挤下了车. 上车坐定一会, 妹子就发现手机不见了. 再打关机. 妹子说上车前确定手机还在 ,可以肯定就是那个黑衣服男偷得.&lt;/p&gt;
&lt;p&gt;之后补卡, 改密码等等善后事宜暂且不表. 且说说后续一些列发展引起我对互联网安全的思考.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2&gt;开端&lt;/h2&gt;
&lt;p&gt;用iphone手机的用户都知道, 一个iphone由一个appleid激活, 如果不进行反激活, 是无法登陆其他appleid的. 所以妹子就打开了丢失模式. 当丢失的手机打开联网时定位并且锁定. 小偷不知道appleid的密码, 就无法解锁手机, 也就无法转手卖出.&lt;/p&gt;
&lt;p&gt;头几天鸟无音信.&lt;/p&gt;
&lt;p&gt;在一两周后, 妹子邮箱接连收到邮件, 内容大概是:&lt;/p&gt;
&lt;p&gt;&amp;gt; 您的iphone正在尝试解锁刷机, 如果是您操作, 请忽略; 如果不是您操作, 请登录&lt;a href=&quot;#&quot;&gt;Apple ID 服务中心&lt;/a&gt;进行取消操作. 该操作将在12小时后被允许.&lt;/p&gt;
&lt;p&gt;署名是 &lt;code&gt;Apple ID Service&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;还好妹子是对这种事情无从下手, 问我怎么办, 我比较警惕, 说转发给我, 我接到后打开, 发现这个邮件的格式和内容很正式. 但是很明显有以下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邮件来源地址不是&lt;code&gt;apple.com&lt;/code&gt;, 而是一个其他的地址.&lt;/li&gt;
&lt;li&gt;邮件中登陆Apple ID 中心的链接也不是官方的.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开这个链接, 是个和&lt;code&gt;查找 iphone&lt;/code&gt;登录界面完全一样的页面. 当然, 这是个伪造的钓鱼网站, 如果妹子自己打开这个并输入了appleid和密码, 那么账号密码就已经陷落了.&lt;/p&gt;
&lt;p&gt;&amp;gt;注意: 如果是手机邮箱, 那么发件人的地址默认是隐藏的. 而且, 打开链接后网页的url也是隐藏的. 所以, 如果是手机打开邮件, 很难分辨真假.&lt;/p&gt;
&lt;p&gt;可见, 被偷iphone手机, 由于其激活机制的特殊性, 产生了一条很色的产业链:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小偷偷到手机后, 无法解锁, 只能卖给下线. 下线是大型的收购商, 来收购被偷的iphone, 然后进行批量的邮件进行钓鱼, 骗取密码解锁手机.&lt;/p&gt;
&lt;p&gt;于是我告诉妹子, 这种邮件都不要乱点, 不要输入你任何信息.&lt;/p&gt;
&lt;h2&gt;继续&lt;/h2&gt;
&lt;p&gt;陆续几天, 还是有同样的伪造刷机警告发来, 妹子都置之不理. 直到开始受到新的类型的邮件, 大概内容:&lt;/p&gt;
&lt;p&gt;&amp;gt; 你的手机在我们公司, 我们无法解锁, 所以按照我们的收购价800块卖给你. 请看&lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt;, &lt;a href=&quot;#&quot;&gt;店铺地址&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;妹子经过上一波教训, 已经对互联网有一定的畏惧心理, 所以丝毫没动, 转发给我.&lt;/p&gt;
&lt;p&gt;我收到后打开, 明显的, 日然是来历不明的邮箱地址. 而且, 店铺地址的链接也是来历不明的.&lt;/p&gt;
&lt;p&gt;虽然是来历不明的链接, 我还是想点进去看看, 于是, 我进行了点击. 结果是:&lt;/p&gt;
&lt;p&gt;空白页面...&lt;/p&gt;
&lt;p&gt;为什么是空白页面呢, 怎么不是钓鱼网站了? 于是我打开chrome开发者模式, 重新打开链接, 有很多请求, 我意识到, 这可能是xss攻击.&lt;/p&gt;
&lt;p&gt;有一个XXX.qq.com域名的请求, 中间进行了重定向, 然后又发送一个特殊url的请求, 这个url暂不公开, 可以假设为 xsssite.net&lt;/p&gt;
&lt;p&gt;因为妹子的appleid用的是qq邮箱. 所以如果对qq.com域名下的一个网页注入脚本的话, 当用户打开这个网页, 很可能能拿到这个用户的登录信息.&lt;/p&gt;
&lt;p&gt;由于这次我是从转发的邮件打开的链接, 所以泄露的是我的登录信息, 所以并无大碍.(跨站脚本只是获取了你的登录状态, 能够一段时间内伪造登录状态, 而并不是获取了你的密码)&lt;/p&gt;
&lt;p&gt;xsssite.net这个域名的请求包含的很多内容, 且这个网站就是一个xss攻击的平台. 关于这个xss攻击位置, 如何获取登录状态, 传递了哪些信息, 我还尚未去详细查看, 以后分享给大家.&lt;/p&gt;
&lt;p&gt;我很感叹, 这个产业链远比我想象的发达:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者 -&amp;gt; 黑客
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;结果&lt;/h2&gt;
&lt;p&gt;后来, 由于一些事情, 还是在妹子的登录状态打开一个这种连接, 对方登陆了妹子的邮箱, 从而重置了appleid密码, 当然期间有apple的邮件, 但是妹子以为是假的, 直接忽略掉了. 我没有及时得到消息, 还是让对方得逞了.&lt;/p&gt;
&lt;h1&gt;故事之后的反思&lt;/h1&gt;
&lt;p&gt;前面讲了妹子的遭遇, 我又想起近几年几次密码泄露, 信息泄露的事件, 深感互联网安全非常重要, 豺狼虎视眈眈, 但是绝大多数人丝毫没有防范意识. 所以我想了一些关于互联网安全的知识, 提示, 以及应对措施. 给大家普及一下.&lt;/p&gt;
&lt;h4&gt;互联网危险到何种程度&lt;/h4&gt;
&lt;p&gt;请看&lt;a href=&quot;WooYun.org&quot;&gt;乌云网&lt;/a&gt;, 白客们所发现的各种系统漏洞. 触目惊心.&lt;/p&gt;
&lt;p&gt;几年前csdn的数据库泄露事故, 余威犹在. 后续几次京东, 7k7k等网站的大量用户密码泄露都是这次事故的后遗症.&lt;/p&gt;
&lt;p&gt;黑色产业链早已超乎你我的想象. 道高一尺魔高一丈. 你的一切都时时刻刻被攻击者盯着, 不要有侥幸心理.&lt;/p&gt;
&lt;h4&gt;关于密码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;密码与社会工程学&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;社会工程学: 一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段取得自身利益的手法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子, 最简单的社会工程学案例, 就是根据你的生日来推测你的银行卡密码. 根据人们慵懒的习惯, 尝试&lt;code&gt;123456&lt;/code&gt;, &lt;code&gt;asd123&lt;/code&gt;, &lt;code&gt;abcd&lt;/code&gt; 等方便输入的习惯来推测你的密码. 所以说, 根据你的个人信息, 比如生日, 身份证号, 门牌号, 亲友生日, 名字拼写, 短语拼写等任何对你有意义的字符序列, 都会被认为是你的潜在密码. 依靠计算机的自动化, 计算效率, 可以不停的对大量的用户数据进行尝试破解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以我们应该避免使用和自身信息有关的密码&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全并不在你的掌握之中&lt;/p&gt;
&lt;p&gt;使用随机的, 比较复杂的密码, 就可以确保账号安全了么? 很遗憾, 不是的.&lt;/p&gt;
&lt;p&gt;因为你的密码不仅仅是你自己要保管, 你所注册的网站, 应用也需要保管. 所以, 你所使用的网站, 应用是否在安全上做足了必要的功夫, 是很重要的.&lt;/p&gt;
&lt;p&gt;前几年CSDN数据库泄露, 大量用户资料被盗, 令人震惊的是他们的密码是明文的....&lt;/p&gt;
&lt;p&gt;根据用户们懒惰的习惯, 不愿意记很多密码, 于是可以假设用户们都喜欢用同一套用户名密码来登陆所有网站,应用. 一时间, 大量网站,应用被撞库成功.&lt;/p&gt;
&lt;p&gt;原则上, 网站是不会保存明文密码的, 他们所保存的是对你的密码进行不可逆加密后的密文, 每次你登陆输入密码, 网站会对输入的密码进行同样的不可逆加密, 然后与保存的密文进行对比来验证正确性. 这样在网站数据库泄露时, 用户密码至少不会以明文显示在盗窃者面前.&lt;/p&gt;
&lt;p&gt;同时, 网站也不应该仅仅用md5简单加密. 如今对于简单通用的加密手段, 黑客已经有数量庞大的样本来进行比较, 所以, 简单通用加密的效果已经接近明文了.所以, 加密时加入随机的salt, 是常用的方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免所有账号都是同一密码. 可以简单分成几级账号密码, 你的关键应用比如qq号, 支付宝, 邮箱等的密码, 一定不要与注册小网站的密码一样.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要轻易进行注册, 尤其对于小网站, 他们的技术相对于薄弱, 安全工作做得不够. 建议小网站都使用第三方认证的方式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二步验证&lt;/p&gt;
&lt;p&gt;在输入密码后, 需要再进行一次密码验证.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One Time Password: 一次性密码, 每个密码只在一次, 或者很短的时间内有效. 下次登录或认真, 就会用不同的密码.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个已经非常常见了, 比如常见的手机验证码, 暴雪战网的安全令牌.&lt;/p&gt;
&lt;p&gt;如果你的账号可以开通二步验证, 强烈推荐开通, 虽然每次耽误点时间, 但是可以对你的账号进行非常好的保护.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apple ID, Google账号, QQ邮箱(使用qq安全中心) 等都支持二步验证, 建议都去开通一下吧&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;关于常用邮箱&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;你的安全老巢&lt;/p&gt;
&lt;p&gt;你的邮箱有多重要? 如果你的邮箱被别人登陆:&lt;br /&gt;
1. 首先, 你的个人信息被别人一览无余. 而且, 有的同学还喜欢用邮箱来作为记事本.&lt;br /&gt;
2. 可以随时重置你的各种网站, 应用的密码!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立密码&lt;/p&gt;
&lt;p&gt;如果你使用网易, QQ, 新浪等不管是什么邮箱, 要设置独立密码! 如同妹子邮箱被登录的教训. 如果你在网易, QQ, 新浪的账号登录状态被xss攻击获得, 那么攻击者可以直接进入你的邮箱!&lt;/p&gt;
&lt;p&gt;这些大网站, 大企业的安全做得很好不用担心? 我承认, 这些大企业的核心业务是没有问题的, 关键在于这些企业家大业大, 设计的方面非常多, 部门也非常多, 甚至分布在不同的地点, 所以不可能所有的地方都能做好安全措施. 妹子这个例子中, 应该是QQ的大粤网中论坛的漏洞, 被进行了xss攻击.&lt;/p&gt;
&lt;p&gt;话说回来, 林子大, 什么鸟都有, 你不能保证这些企业当中有黑客的存在. 就像你找人做了个保险箱, 你不能保证这个人是不是留了一把钥匙, 或者在保险箱你不知道地方做了个机关. 尤其对这些企业的非核心业务的技术人员, 并不事都是经过严格考核进来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要轻易在浏览器中从邮箱中打开连接&lt;/p&gt;
&lt;p&gt;切记, 邮箱中的不确定连接不要轻易就打开, 尤其实在浏览器环境下使用邮箱的时候. 预防xss攻击.&lt;/p&gt;
&lt;p&gt;如果打开链接, 发现有异常, 查看请求记录, 如果有疑似xss攻击, 果断退出登录状态, 修改密码. 然后把该链接提交给出现漏斗的网站.(技术工作者)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要在浏览器中打开链接, 请使用&amp;quot;隐身窗口中打开&amp;quot;, 据我所知Chrome, 以及使用Chrome内核的浏览器基本都支持&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;关于手机号&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;你的安全命门
&lt;p&gt;当你的手机丢了, 第一件事, 补卡. 让丢失的卡不能再使用.&lt;/p&gt;
&lt;p&gt;当你的手机落入别人手中, 又能正常使用, 那么它可以使用很多应用的二步验证.&lt;/p&gt;
&lt;p&gt;作为一些应用的密保手机, 它能够充值你这些应用的密码.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手机丢了先补卡&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;如果你对妹子的经历感兴趣, 想获取妹子收到的邮件样本, 请在评论里留下你的邮箱, 说明要获取邮件样本, 我会不定期地查看进行转发.&lt;/p&gt;
&lt;p&gt;当然, 对于产生的一些列问题我特此声明不负任何责任.&lt;/p&gt;
&lt;p&gt;如果你觉得本文对你有帮助和启发, 可以转发给其他人, 以示提醒.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>定位占用cpu的java线程</title>
      <link>http://blog.yangxiaochen.com/blog/linux/top-thread.html</link>
      <pubDate>Fri, 1 Apr 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/linux/top-thread.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;列出一个进程中线程 cpu 占用&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    top -Hp 18207&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;获取一个 java 进程 cup 占用率 top10 的线程堆栈, groovy 脚本 &lt;code&gt;groovy 本脚本 [pid]&lt;/code&gt;. need JAVA_HOME&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;if(args.size() &amp;lt; 1 ) {
    println &quot;need pid&quot;
    return
}
def pid = args[0]

def sout = new StringBuilder(), serr = new StringBuilder()
def proc = &quot;top -b -n 1 -H -p ${pid}&quot;.execute()
proc.consumeProcessOutput(sout, serr)
proc.waitFor()
println sout

def begin = false
def countLimit = 10
def count = 0
sout.eachLine { line -&amp;gt;
    if (line.trim().size() == 0) {
        return
    }
    if (begin &amp;amp;&amp;amp; count &amp;lt;= countLimit) {
        println line
        def row = line.trim().split(&quot; +&quot;)
        def tid = String.format(&quot;nid=0x%x&quot;, row[0].toInteger())
        println tid

        def sout1 = new StringBuilder(), serr1 = new StringBuilder()
        def p1 =  (System.getenv(&quot;JAVA_HOME&quot;)+&quot;/bin/jstack -l ${pid} &quot;).execute() | [&quot;grep&quot;, tid ,&quot;-A 20&quot;].execute()
        p1.consumeProcessOutput(sout1, serr1)
        p1.waitFor()

        serr1.eachLine { println it }
        def lines = sout1.readLines()

        if (lines.size() &amp;gt; 0) {
            println lines[0]
            lines[1..-1].takeWhile { !it.startsWith(&quot;\&quot;&quot;) }.each { println it }
        }

        println()
        count++
    }
    if (!begin &amp;amp;&amp;amp; line.trim().toUpperCase().startsWith(&quot;PID&quot;)) {
        begin = true
    }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>mkdir在/home目录下新建文件夹 for mac</title>
      <link>http://blog.yangxiaochen.com/blog/mac/create-dir-home.html</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/mac/create-dir-home.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hmmm, trying to create a directory under &apos;/home&apos; on a Mac?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, Apple doesn&amp;#8217;t want you to (with good reason, automounter owns this dir, which makes it easier to do NFS mounts and such) so you shouldn&amp;#8217;t muck with it but if you really just &apos;have to do it&apos;, here is how you can.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Basically: Edit &lt;code&gt;/etc/auto_master&lt;/code&gt; and remove or comment out the line that starts with &quot;/home&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;sudo vim /etc/auto_master&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;before:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;# Automounter master map
+auto_master            # Use directory service
/net                    -hosts          -nobrowse,hidefromfinder,nosuid
/home                  auto_home      -nobrowse,hidefromfinder
/Network/Servers        -fstab
/-                      -static&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;after:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;# Automounter master map
+auto_master            # Use directory service
/net                    -hosts          -nobrowse,hidefromfinder,nosuid
#/home                  auto_home      -nobrowse,hidefromfinder
/Network/Servers        -fstab
/-                      -static&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to have the change take effect without a reboot:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;sudo automount&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;mkdir /home/test
ls -l /home/
total 0
drwxr-xr-x 3 root admin 102 Aug 10 11:33 test&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
I wouldn&amp;#8217;t do anything &apos;important&apos; with this directory as it&amp;#8217;s easy to forget you altered this and an upgrade will plow over this directory, removing all data. (this dir is also not included in any Time Machine backups.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>python入门</title>
      <link>http://blog.yangxiaochen.com/blog/develop/python-starter.html</link>
      <pubDate>Tue, 9 Feb 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/develop/python-starter.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;本文不讲python语法, 因为语法手册到处都有, 而且也不难, 本文旨在介绍python的生态环境和开发环境搭建.&lt;/p&gt;
&lt;h2&gt;生态&lt;/h2&gt;
&lt;h3&gt;包管理工具 pip&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;python 3.*版本自带&lt;/li&gt;
&lt;li&gt;python 2.*须另外安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pip 文档地址&lt;a href=&quot;https://pip.pypa.io/en/latest/&quot;&gt;pip文档&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;虚拟环境 Virtualenv&lt;/h3&gt;
&lt;p&gt;python安装类库为全局安装, 在一台机器上一个用户安装一个类库, 对该机器上所有用户和项目有效. 所以为了解决这个问题, 引入了虚拟环境, 使依赖类库管理编程项目范围.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;python 3.*版本自带&lt;/li&gt;
&lt;li&gt;python 2.*须另外安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Virtualenv 文档地址&lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;Virtualenv文档&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>homebrew安装旧版本软件</title>
      <link>http://blog.yangxiaochen.com/blog/mac/homebrew-install-old-version-soft.html</link>
      <pubDate>Tue, 9 Feb 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/mac/homebrew-install-old-version-soft.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不需要用brew versions ,这个已经过时了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;很多有重要版本的软件都已经区分版本的设定formulae了
参见项目地址 &lt;a href=&quot;https://github.com/Homebrew/homebrew-versions&quot; class=&quot;bare&quot;&gt;https://github.com/Homebrew/homebrew-versions&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如nodejs   有重要的0.10.*版本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;yangxiaochen:/usr/local$ brew search node
leafnode node node010 node04 node06 node08 nodebrew nodenv&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;node010就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;同理php也是这样分php56 php55 php54 ….&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>rabbitmq管理使用实践</title>
      <link>http://blog.yangxiaochen.com/blog/develop/rabbitmq-in-action.html</link>
      <pubDate>Mon, 8 Feb 2016 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/develop/rabbitmq-in-action.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_原创_转载请注明出处httpsblog_yangxiaochen_comhttpsblog_yangxiaochen_com&quot;&gt;原创, 转载请注明出处[https://blog.yangxiaochen.com](https://blog.yangxiaochen.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_poi&quot;&gt;poi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_业务事件流&quot;&gt;业务事件流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_日志流&quot;&gt;日志流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_其他&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_rabbitmq_规范&quot;&gt;rabbitmq 规范&lt;/a&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_使用规范&quot;&gt;使用规范&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_0_使用原则&quot;&gt;0. 使用原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_1_datasourceexchanges&quot;&gt;1. datasourceExchanges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_2_durable_queues_exchanges&quot;&gt;2. durable queues, exchanges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_3_temp_queues_exchagnes&quot;&gt;3. temp queues, exchagnes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_原创_转载请注明出处httpsblog_yangxiaochen_comhttpsblog_yangxiaochen_com&quot;&gt;原创, 转载请注明出处[&lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;](&lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;)&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;# MQ数据源&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&lt;code&gt;datasource &amp;#8594; topic exchange&lt;/code&gt;&lt;/code&gt;, 数据源已固定格式发入exchange, exchange类型为topic,既可以使用路由route_key, 又可以进行通配. 不要将生产者, 消费者用在同一队列上, 这样耦合度高, 消息无法复用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据源只关心输入exchange, 对后续消费者无需关心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新加,修改数据源需要备案记录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者一般情况下使用临时队列, 必要情况下使用持久队列. 队列从数据源的exchange中订阅数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成. 防止程序改动造成的废弃的exchange, queue仍然存在在rabbitmq中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名统一.&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:[sth.sth]
queueName: [消费者程序名称]:[exchangeName].[subject]
route_key: [exchangeName].[subject]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
exchangeName: datasource:dispatch.event
queueName: autoDispatch:dispatch.event.orderCreate
route_key: dispatch.event.orderCreate&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_poi&quot;&gt;poi&lt;/h3&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:poi&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_业务事件流&quot;&gt;业务事件流&lt;/h3&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:dispatch.event&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_日志流&quot;&gt;日志流&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_其他&quot;&gt;其他&lt;/h3&gt;

&lt;/div&gt;
&lt;h1 id=&quot;_rabbitmq_规范&quot; class=&quot;sect0&quot;&gt;rabbitmq 规范&lt;/h1&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_使用规范&quot;&gt;使用规范&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_0_使用原则&quot;&gt;0. 使用原则&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;数据源已固定格式发入exchange, exchange类型为topic.数据源只关心输入exchange.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改数据源, 持久队列, 持久内部exchange需要备案记录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者一般非必要情况下使用临时队列. 队列从数据源的exchange中订阅数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_1_datasourceexchanges&quot;&gt;1. datasourceExchanges&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;datasource:[datasourceName]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
datasource:poi
datasource:dispatch.event&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git@gitlab.supaide.cn:sys/rabbitmq.git
datasources.txt&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;备案说明详见文件内部格式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_2_durable_queues_exchanges&quot;&gt;2. durable queues, exchanges&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;queueName
[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName
x:[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
autoDispatch:dispatch.event.orderCreate
x:autoDispatch:dispatch.event.*&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git@gitlab.supaide.cn:sys/rabbitmq.git
durableQueues.txt&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;备案说明详见文件内部格式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_3_temp_queues_exchagnes&quot;&gt;3. temp queues, exchagnes&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;gen.[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;or&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;默认随机名称&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;无需备案&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>css 定位指南</title>
      <link>http://blog.yangxiaochen.com/blog/frontend/css-position.html</link>
      <pubDate>Tue, 8 Nov 2011 00:00:00 +0000</pubDate>
      <guid isPermaLink="false">blog/frontend/css-position.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;前置知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解html各个标签&lt;/li&gt;
&lt;li&gt;对css各种属性有一些了解&lt;/li&gt;
&lt;li&gt;理解盒子模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;对于网页制作的新手来说, 了解了html各种标签的含义, 并不能够制作出像网上那些绚丽的网页.&lt;br /&gt;
一个网页的制作过程, 要经过一下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计&lt;/li&gt;
&lt;li&gt;布局分析&lt;/li&gt;
&lt;li&gt;编写html, 并用css布局&lt;/li&gt;
&lt;li&gt;css来进行各个布局区块内部的样式编写&lt;/li&gt;
&lt;li&gt;js来编写动态效果和其他功能脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们这里研究的是第三部分: 当我们确定了布局, 如何用html和css把布局描述出来&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;html编写&lt;/p&gt;
&lt;p&gt;html是用来表达文档结构的,当看到一个h1标签, 不应该去想这一标签让文字放大加粗, 而应该想这个标签引用的文字, 是一个一级标题, 这才是html的初衷. html中不应该出现描述样式的属性如&lt;code&gt;width&lt;/code&gt;, &lt;code&gt;sytle&lt;/code&gt;等.&lt;/p&gt;
&lt;p&gt;html不应该去思考样式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档流&lt;/p&gt;
&lt;p&gt;怎么定位? 很多人直接就开始讲定位的属性和方法. 其实, 要真正理解定位, 就要先了解文档流.&lt;/p&gt;
&lt;p&gt;什么是文档流? 写出来的html文档的顺序, 就是文档流的顺序. 当不加任何修饰的时候, 页面上显示出来的时候, 和你html代码是很相像. 也就是说, 所写的html文档的各个元素, 是按这个默认顺序排列下来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位&lt;br /&gt;
有了这个基础,再来看定位:定位有两种方式.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;float定位&lt;/p&gt;
&lt;p&gt;float有两个值:&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. 分别表示向左向右浮动. 一旦一个元素采用了float进行定位, 那么这个元素将脱离文档流. 意思是这个元素虽然在页面上还看得到, 但是已经不据占位置了, 后面的元素会补上来.&lt;/p&gt;
&lt;p&gt;那么它会到哪呢? 飘走了… 一个较为明确的说法是: 因为任何一个元素可以成为一个盒子模型, 那么这个元素有个边框, 浮动的框可以根据float的值是&lt;code&gt;left&lt;/code&gt;还是&lt;code&gt;right&lt;/code&gt;进行向左或向右移动, 直到它的外边缘碰到父元素的边框或另一个同级元素的边框为止.&lt;/p&gt;
&lt;p&gt;float的块级元素将不占一正行, 宽度为内容实际宽度.&lt;/p&gt;
&lt;p&gt;在这个元素后面的文档流部分会顶上来, 取代这个元素的位置. 但是后面那个元素里的内容, 比如说文字, 会围绕在上面那个浮动元素周围. 这个效果不是很好表达,大家可以自己做个试验. 定义两个div, 里面都写上文字, 注意第二个div里的文字要比第一个多(这样才能环绕), 让后给第一个加CSS属性:&lt;code&gt;float:left&lt;/code&gt;. 然后就看到效果了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;position定位&lt;/p&gt;
&lt;p&gt;position有四个值:&lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先说static,这个是默认值,每个元素如果没有定义position属性,就等于是这个值.所以,不解释了,可以说就是没有定位方式.&lt;/p&gt;
&lt;p&gt;关键是其他的三种.选择其中任何一个后,就可以按自己需求布局了.这时候你可以用CSS中的四个属性:&lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;. 比如&lt;code&gt;top:100px&lt;/code&gt;, 表示相对于”相对元素”(稍后解释这个相对元素)的顶部有&lt;code&gt;100px&lt;/code&gt;的距离.其他以此类推.&lt;/p&gt;
&lt;p&gt;相对元素是什么? &lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;这三个值决定了这个相对元素:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;relative&lt;/p&gt;
&lt;p&gt;元素会相对于自身原来在文档流的位置进行偏移. 这时定义&lt;code&gt;top:100px&lt;/code&gt;就表示相对它本来应该在的位置向下偏移了&lt;code&gt;100px&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;absolute&lt;/p&gt;
&lt;p&gt;元素框从文档流完全删除, 并相对于其包含块定位.&lt;/p&gt;
&lt;p&gt;包含块定义:&lt;/p&gt;
&lt;p&gt;这个包含块并不一定是直接父元素, 一个元素可能被包在好几层块之内. 距离最近的,postion属性为absolute relative fixed 三者之一的祖先元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fixed&lt;/p&gt;
&lt;p&gt;元素框的表现类似于将 position 设置为 &lt;code&gt;absolute&lt;/code&gt;，不过其包含块是视窗本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;练习与参考&lt;/h2&gt;
&lt;p&gt;以上是定位的理论, css的学习是一个不断熟练的过程, 写的时候可以参照成熟网站的类似布局, 通过chrome开发者模式来研究别人的页面写法很有裨益.&lt;/p&gt;
&lt;p&gt;另外[CSS禅意花园]这本书值得一看, 虽然比较老, 但是里面的一些基础知识, 基本css写法是值得学习的.&lt;/p&gt;

	</description>
    </item>

  </channel> 
</rss>
