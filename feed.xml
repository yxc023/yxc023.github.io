<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>http://blog.yangxiaochen.com</link>
    <atom:link href="http://blog.yangxiaochen.com/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>星期四, 5 五月 2022 03:36:14 +0800</pubDate>
    <lastBuildDate>星期四, 5 五月 2022 03:36:14 +0800</lastBuildDate>

    <item>
      <title>Gradle 使用实践</title>
      <link>http://blog.yangxiaochen.com/blog/2022/0504-gradle-practice.html</link>
      <pubDate>星期三, 4 五月 2022 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/2022/0504-gradle-practice.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_构建脚本实例解读&quot;&gt;构建脚本实例解读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_常见问题&quot;&gt;常见问题&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_构建脚本里面都有啥&quot;&gt;构建脚本里面都有啥&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_构建脚本的执行顺序&quot;&gt;构建脚本的执行顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何引用文件&quot;&gt;如何引用文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_依赖查看与版本设置&quot;&gt;依赖查看与版本设置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_implementation_compileonly_等依赖标识是啥意思&quot;&gt;implementation, compileOnly 等依赖「标识」是啥意思&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_tbd&quot;&gt;TBD.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle 是一个第一眼看上去比较简单，实则有一定入门门槛的构建工具。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在配置仓库，引入依赖这种基本操作之外，想做一些其他的个性化配置，经常无处下手。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;官方文档，虽然很详实，但是对于没有进行系统学习的人，看起来还挺费劲。而且，文档中给出的例子，跟实际情况脱离较远，不是很好参照。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gradle 的配置文件，大多使用 groovy 来进行，弱类型的语言，dsl 和 closures 的表达方式，都会让很多 java 程序员摸不着头脑。
虽然我没有对 gradle 进行特别系统的学习，但是也是一直在应用。简单的配置语法、极度灵活的自定义构建配置是我一直喜欢的地方。当然，过程中也遇到了不少问题，翻过文档和源码。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这里记录一些实践，算是对 Gradle 使用的一些觉得不错的经验积累。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_构建脚本实例解读&quot;&gt;构建脚本实例解读&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这些文件来自项目： &lt;a href=&quot;https://github.com/yxc023/gradle-practice&quot; class=&quot;bare&quot;&gt;https://github.com/yxc023/gradle-practice&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;gradle-practice
├── build.gradle
├── gp-api
│   ├── build.gradle
├── gp-app
│   ├── build.gradle
├── gp-db
│   ├── build.gradle
├── gp-service
│   ├── build.gradle
├── gradle
│   ├── jooq.gradle
│   ├── publish.gradle
│   └── wrapper
├── gradlew
├── gradlew.bat
└── settings.gradle&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;这是一个多模块的项目，通过根项目下的 &lt;code&gt;build.gradle&lt;/code&gt; 文件，做好全局配置，让每个子模块中的 &lt;code&gt;build.gradle&lt;/code&gt; 足够简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子项目中的 &lt;code&gt;build.gradle&lt;/code&gt; 文件，一般只需要定义 Dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽离一些可服用的构建脚本，放到 &lt;code&gt;gradle&lt;/code&gt; 文件夹下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先看 &lt;code&gt;settings.gradle`&lt;/code&gt;, 再看 rootProject 的 &lt;code&gt;build.gradle&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_构建脚本里面都有啥&quot;&gt;构建脚本里面都有啥&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每一个 project 下都有一个名为 &lt;code&gt;build.gradle&lt;/code&gt; 的构建脚本。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每一个 &lt;code&gt;build.gradle&lt;/code&gt; 构建脚本背后，都隐含了一个 &lt;code&gt;Project&lt;/code&gt; 对象。这个构建脚本中定义的各种属性或者方法，基本都是这个 project 中包含的。比如你可以在脚本中直接使用 &lt;code&gt;Project&lt;/code&gt; 接口中定义好的变量和方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;project 中包含了这些重要的东西：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;自身的属性和方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tasks - 当前 project 中包含的任务实例。引入一些 plugin 时，也会向 project 中添加 task&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;// 创建一个名字为 `jooqTask`，类型为 `JooqTask` 的 task
project.tasks.create(&quot;jooqTask&quot;, JooqTask.class)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;extra property - 通过 ext block 声明的额外变量&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;ext {
    mysqlVersion = &apos;8.0.18&apos;
    jooqVersion = &apos;3.13.1&apos;
    jooqGenDataSourceDriver = &apos;com.mysql.jdbc.Driver&apos;
    jooqGenDataSourceUrl = &apos;jdbc:mysql://127.0.0.1:3306/gp_database&apos;
    jooqGenDataSourceUrlUser = &apos;gp_database_user&apos;
    jooqGenDataSourceUrlPassword = &apos;test&apos;
    jooqGenDataSourceInputSchema = &apos;gp_database&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;extensions - 引入一些 plugin 时， 会向 project 中添加一些 extension 对象，并命名。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;// 创建一个名字为 `$JOOQ_EXTENSION_NAME`，类型为 `JooqExtension` 的 extension。后面两个参数是 `JooqExtension` 的构造参数
project.extensions.create(&apos;jooq&apos;, JooqExtension.class, whenConfigurationAdded, &apos;jooq&apos;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;加入 extension 后，就可以在构建脚本中定义&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;jooq {
    version = jooqVersion
    edition = &apos;OSS&apos;
    generateSchemaSourceOnCompilation = false
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;convention - 引入一些 plugin 时，会加入一些 convention object，翻译过来叫‘约定’，‘预定大于配置’的‘约定’。convention object 通常是 POJO，为 project 提供一些拓展属性。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;// 这两个变量，在引入 java plugin 之后，就能在构建脚本里够直接定义下面的变量。
sourceCompatibility = 1.8
targetCompatibility = 1.8&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总之，这些 project 中包含的重要信息的作用，它们定义了 &lt;code&gt;build.gradle&lt;/code&gt; 中可以写什么 property 或者 block&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当 &lt;code&gt;build.gradle&lt;/code&gt; 中使用了一个 property 或者 block，他的查找顺序是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;是否是 project 中的属性和方法&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;// version 这个变量，即是 project.version
version = &apos;1.0.0&apos;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否是 &lt;code&gt;ext&lt;/code&gt; 定义的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否是 extensions 中的 extension 的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否是 convention 中定义的 pojo 中的变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否是 task 的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否在上层 project 的 ext 和 convention 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_构建脚本的执行顺序&quot;&gt;构建脚本的执行顺序&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;setting.gradle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rootProject build.gradle&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subProject build.gradle&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_如何引用文件&quot;&gt;如何引用文件&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_依赖查看与版本设置&quot;&gt;依赖查看与版本设置&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_implementation_compileonly_等依赖标识是啥意思&quot;&gt;implementation, compileOnly 等依赖「标识」是啥意思&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_tbd&quot;&gt;TBD.&lt;/h3&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>日常体会(更新至 2021-08-08)</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/daily-experience.html</link>
      <pubDate>星期日, 8 八月 2021 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/daily-experience.html</guid>
      	<description>
	&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当你对未来的需求有预见性, 能够估计出现在的设计如何改动, 老数据如何迁移, 就能够接受当前的并不完善的设计. 重要的是设定概念, 或者叫领域模型, 只要老的模型和新的模型都是清晰地, 就不怕从老的模型迁移到新的模型.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为什么有时候重构困难, 不是无法找到一个新模型, 而是老模型混乱, 细节上二义性多, 每一次模型的更新都没有对数据全面处理, 造成数据的历史版本多.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个模型内部的各种字段的业务场景都要明确, 各司其职. 讲模型就是树立概念. 应该是自冾的, 能够演绎的, 能说服自己的.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-02-21 在讨论需求实现时一定程度的妥协&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;工程师怎么才会想着要做到更专业? 一个工程师在觉得专业的东西离自己比较远时, 通常不会要求自己作的很专业.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但当一个工程师看到了写的很专业的代码, 文档, 就在自己身边, 并被专业性所打动时, 肯定会自己也想要做到这样.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当花费了些功夫, 自己也模仿专业的方式来要求自己, 产出成果后, 会产生很大满足感, 这样一个工程师今后都会更高要求自己.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个同事, 之前不写测试, 或者说对写测试不感冒, 在一个优秀的测试代码上尝到甜头, 给自己的项目补充了非常整齐的测试用例.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-03-08 如何让自己趋向专业&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;新项目真的能给人带来很大的提升, 尤其在一个严格要求下的新项目.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;代码书写的传授在新项目里是非常高效的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大概是自己在一个干净的环境, 也会尽力来保持整洁.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当然, 前提是这个项目由一个作为经验丰富的实践家的高级别工程师把控.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;话外之意, 有一些高级工程师, 在真正的业务开发中实践较少, 在实践中总结的方法论不足, 不够优秀.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;人家都转管理了, 哪有功夫跟着你泥塘里打滚.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-03-08 新项目对同学们提升很大&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;整体大局观, 怎么才能考虑全面, 怎么才能有高度.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个很重要的一点是获取更多信息, 从业务上来讲, 产品的远期规划, 近期变动, 公司对现有业务的新的思考. 其他部门的业务现状. 最后行业现状等等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;从技术上来讲, op 的职责划分, 网络线路, 机房现状.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总之, 获取的信息越多, 越有利于做判断, 下结论, 以上只是这个规则在软件开发上的应用, 在其他领域, 也是吃的开的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是反过来讲, 要求开发人员做到这些, 要求太高了. 明明应该是各司其职, 结果让开发人员全包. 就因为开发同学是最接近真实实现的. 无法调和.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-03-08 提升整体大局观&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写代码优雅果然不是一蹴而就的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;没有亲身体会是不行的.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-03-26 review 代码有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写代码时要告诉自己, 代码是给别人读的, 换位思考, 把自己的意图展示出来, 把自己的意图展示出来, 把自己的意图展示出来.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-10 review 代码有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;找到一个合适的设计很重要, 但是知道当前的设计不合适更重要. 只有指导不合适, 才会抓耳挠腮, 辗转反侧, 去找到一个合适的设计.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-16 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个复杂多变的业务一定要进行抽象梳理, 找出不变的东西, 核心的流程. 流程上的细节处理通过各种策略模式来实现.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-25 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个事情没想清楚, 不要往大了做, 拆系统&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-26 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不要以程序不报错为目标写代码, 要以逻辑正确为目标写代码.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-26 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写代码决不能只看自己这一块, 要往上游多看, 往下游多看, 才能写的正确.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-04-30 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;创建请求凭证跟发起请求不要在同一个事务中.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可能需要一个全局的异步补偿逻辑注册中心.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-05 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写单测是对系统逻辑的 review&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能顺利写出单测, 说明开发对系统逻辑了解, 业务逻辑设计的时候就想好了怎么用.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-06 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写代码要让别人知道自己在做什么, 而不是怎么做. 不要让别人通过复杂的逻辑代码, 猜测你在做什么.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;if (time == null || time.notAfter(&apos;1970-01-02 00:00:00&apos;)) {
    time = newTime
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;项目中有个 &lt;code&gt;time&lt;/code&gt; 字段, 要求如果没有设置过值, 则这设置为当前时间. 如果改为&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;if (isInitialTime(time)) {
    time = newTime
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当别人读到下面这段代码时, 就知道你在做什么, 而不是通过复杂的判断来推断.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-06 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个项目, 从产品到开发都没有一个有能力把产品, 业务, 概念, 抽象好的人, 这个产品就没啥可维护性可言了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后造成产品各种变动, 开发疲于奔命.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-06 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们总是想封装, 自动化配置, 让他人更少的了解细节. 但同时我们又要求了解实现, 以完成更优的使用.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-08-09 封装&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为什么总是强调字段和方法命名? 为了统一语言和概念, 为了表达意图. Name things 是软件开发中最难得两个事情之一.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-10-23 字段命名&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最开始没有订好概念, 没有想清楚, 不坚持原则, 为实现而实现, 后面迭代重构就会连本带利还回来.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-06 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;流程需要更高一层的人来梳理, 更高一层的人深入下层&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-05-06 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;PM 出需求, 要有文档, 原型, user case. user case 可以有 rd 来出.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2019-12-20 杂乱业务设计有感&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下定义本身就是件非常要动脑的事; 把定义写出来做好解释更是费劲. 只有写下来, 才能不被大脑欺骗, 才是把事情真正的想清楚了.
写出来才是想清楚, 才能把概念传播. 避免陷入系统一的陷阱.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2020-01-06 下定义&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;传递思想, 对齐认知. 是一件难而正确的事.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个项目上, 要有能去想这个事情的人, 能持续培养, 纠正一个项目的人, 投入感情的人, 而不仅仅是让一个项目或者. 带着感情编程.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写清楚目标, 就是为了避免做着做着不知道自己要干啥. 或者不知道让下属干啥.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2020-05-15 管理工作中的几个想法&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;临时方案总是不可避免的, 但是临时方案也要遵循一些原则:
1. 尽量在外部看起来, 不像一个临时方案. [optional]
2. 一定要思考过完整方案, 或者完整方案的方向. [required]
3. 尽量让临时方案和预期的完整方案在一个方向上. [optional]
3. 一定要思考将临时方案改成完整方案的成本. [required]
最终我们会得到一个容易拆除, 容易替换, 对本体基本无害的方案.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2020-05-15 临时方案&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;好的设计，代码千篇一律。坏的设计就是人类思维精华大赏
所以我不喜欢去总结和报告一个项目里各种各样的问题及影响，我只想推出我认为合理的设计&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2021-08-13&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于 saas 平台而言，不一定非要对业务了解的面面俱到，
一个业务进来之后可能自己也都没想好，然后在运行时慢慢完善。我们能够支持他们做这个优化完善的过程即可。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2021-08-13&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;抽象存储层，强行进行抽象，提升业务拓展性。 低代码、无代码。&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; 杨晓辰&lt;br&gt;
&lt;cite&gt;2021-08-18&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>spring 中一个 alias 别名导致的 bean 无法找到问题</title>
      <link>http://blog.yangxiaochen.com/blog/stackoverflow/bean-not-found-becauseof-alias.html</link>
      <pubDate>星期日, 22 三月 2020 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/stackoverflow/bean-not-found-becauseof-alias.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_起因&quot;&gt;起因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_初步排查&quot;&gt;初步排查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_进一步排查&quot;&gt;进一步排查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_起因&quot;&gt;起因&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前几天遇到一个奇怪的问题, spring boot 升级坂本后, 项目中定义的一个 bean 无法被 autowired 获得, 这个 beanName 是 &lt;code&gt;taskExecutor&lt;/code&gt;, 是一个项目内自定义的类, 姑且叫 &lt;code&gt;com.a.b.TaskExecutor&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;仔细检查了 scanPackage 的路径, 发现没有问题, 按道理肯定能加载到才对, 统计目录下的其他 bean 都能扫描到.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_初步排查&quot;&gt;初步排查&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;找到抛出异常的地方, 打个断点, 往前跟踪了几行代码, 确实是 spring 的 beanFactory 在找类型为 &lt;code&gt;com.a.b.TaskExecutor&lt;/code&gt; 的 bean 时找不到.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我调用了一下 &lt;code&gt;getBeanDefinitionByName(&quot;taskExecutor&quot;)&lt;/code&gt;, 发现存在一个 beanDefinition, 并且能看到它的 &lt;code&gt;beanClassName = &quot;com.a.b.TaskExecutor&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我又调用了下 &lt;code&gt;getBeanNamesByType(com.a.b.TaskExecutor.class)&lt;/code&gt;, 居然返回 &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;又是&quot;灵异事件&quot;&amp;#8230;&amp;#8203; 我通常把很奇怪的问题叫做灵异事件&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_进一步排查&quot;&gt;进一步排查&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里绕了一些弯路, 一直在找这个 bean definition 跟其他的 &lt;strong&gt;bean definition (后面简称 bd)&lt;/strong&gt; 有什么区别, 造成这两个方法获取时的不同. 发现这个 taskExecutor 的 bd 中, 只有字符串类型的 &lt;code&gt;beanClassName&lt;/code&gt;, 没有真正可以标明类型的 &lt;code&gt;resolvedType&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么 &lt;code&gt;resolvedType&lt;/code&gt; 是什么时候产生的呢, 发现在 &lt;code&gt;getBeanNameForType()&lt;/code&gt; 的过程中, 会便利所有的 bd, 其中有一步, 如果没有 &lt;code&gt;resolvedType&lt;/code&gt;, 会进行类型的 resolve.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这就奇怪了, 我明明调用了 &lt;code&gt;getBeanNamesByType(com.a.b.TaskExecutor.class)&lt;/code&gt;, 为啥还会获取不到.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;聚焦跟踪 &lt;code&gt;getBeanNamesByType(com.a.b.TaskExecutor.class)&lt;/code&gt; 的运行代码.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;发现在 &lt;code&gt;doGetBeanNameForType()&lt;/code&gt; 的方法中, 会对每一个 bd 进行判断, 但是在每个 bd 判断之前, 有一句 &lt;code&gt;if(!isAlias(beanName))&lt;/code&gt;, 只有当不是 alias 时, 才做判断. 否则就指向 alias 关联的 bean 的 bd.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;也就是说, 当一个 bean 由 a, b, c 三个名字时, b 和 c 都是 a 的 alias 别名. 当 &lt;code&gt;doGetBeanNameForType()&lt;/code&gt; 中发现 b 是别名, 则使用 a 的 bd 来做类型检测.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回到我们的例子中, &lt;code&gt;taskExecutor&lt;/code&gt; 被判断是一个别名, 在 aliasMap 里有一个键值对, 指向 &lt;code&gt;applicationTaskExecutor&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;破案了, 一个名字为 &lt;code&gt;applicationTaskExecutor&lt;/code&gt; 的 bean, 用了两个名字, 第二个名字是`taskExecutor`. 这个关系被维护到了一个 aliasMap 中. 这个 bean 的定义位置也在一个 autoconfiguration 的 bean 里找到了, 确实如上所说.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而我们自己定义的 &lt;code&gt;taskExecutor&lt;/code&gt;, 虽然也添加到了 bdMap 中, 但是在 &lt;code&gt;getBean&lt;/code&gt; 的过程中会先检测 aliasMap. 所以即使在 bdMap 中有定义, 也拿不到..&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_后记&quot;&gt;后记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我还没有对比两版 spring 这里的处理, 旧版的 spring boot 框架是没啥问题的. 顺便一提原版本是 2.1.0, 新版本是 2.1.9&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;感觉可以有一个断言, 凡是在 aliasMap 里的别名, 均不应该在 bdMap 里有 bean definition 定义.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
写的时候没有再翻代码, 都是记忆, 以上内容方法名字可能略有出入.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>如何处理 java 代码中的异常</title>
      <link>http://blog.yangxiaochen.com/blog/java/how-to-deal-with-java-exception.html</link>
      <pubDate>星期五, 17 一月 2020 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/how-to-deal-with-java-exception.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何判断是否要处理异常&quot;&gt;如何判断是否要处理异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何处理异常&quot;&gt;如何处理异常&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_处理非业务异常&quot;&gt;处理非业务异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_处理业务异常&quot;&gt;处理业务异常&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对异常我们一般有这么几个处理方式:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我处理掉, 让上层无感知.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对异常进行封装, 封装成一个新的异常, 加入我的解释, 帮上层理解异常.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不做处理.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_如何判断是否要处理异常&quot;&gt;如何判断是否要处理异常&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;if (当前代码在抛出可预期异常) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    处理异常()
} else if (根据我的分析, 这段代码会发生潜在异常) { &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    if (需要关心这种异常) { &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        处理异常()
    }
} else {
    // 再发生异常时就是我预测不到的, 我统称为 bug.  &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;众所周知, java 中异常分为可预期(excepted)异常和 runtime 异常. 为什么会有&lt;strong&gt;可预期异常&lt;/strong&gt;这种东西? 帮助经验不足 java 程序员知道这段代码有发生哪些异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;比如有网络请求, 有参数校验等, 我知道这段代码可能会在某种可以想到的情况下发生异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;如何判断是否需要关心?&lt;/strong&gt; 我当前的程序不需要较好的健壮性, 这个异常也不会影响到别人, &lt;strong&gt;没有人因为这个异常没处理会感到疑惑或者背地里骂我&lt;/strong&gt;, 那么我就可以不关心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;我想象到不到会出现什么异常. 当然, 如果发生线上问题, 就要背锅交学费了&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_如何处理异常&quot;&gt;如何处理异常&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;判断完是否要处理异常, 如果需要处理, 就要看看如何处理异常:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;function 处理异常(ex) {
    if (我在非业务逻辑中) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
        pass:q[**处理非业务异常(ex)**]
    } else if (我在业务逻辑中) {
        处理业务异常(ex)
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;什么叫非业务异常? 跟业务逻辑无关的中立代码. 比如 &lt;code&gt;发送 HTTP 请求的工具类&lt;/code&gt;, &lt;code&gt;初始化项目基础设施的代码&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_处理非业务异常&quot;&gt;处理非业务异常&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;非业务代码中的异常, 一般是无法原地处理的, 都是要抛给上层, 让真正知道业务的地方去判断出了这种问题该如何处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;function 处理非业务异常(ex) {

        if (我很确定重试后成功的概率很高) { &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
            do: 考虑尝试 1-2 次
            如果成功就 ok, return
        }

        do: 抛出特定异常, 说明错误原因, 带上原始异常. 最好带上特定 异常 code, 带有结构化的数据能够对异常做详细说明 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;一般都是不能抢救的. 例外的, 比如创建链接超时这种不确定异常, 可以重试下, 很多 HTTP 请求框架也是有这么做的.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;一个包含了足够信息的异常. &lt;a href=&quot;http://blog.yangxiaochen.com/blog/design-and-thinking/expressive-exception-lib.html&quot;&gt;一个更有表现里的异常&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_处理业务异常&quot;&gt;处理业务异常&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;业务逻辑中处理异常会稍微复杂一些, 到这里已经不是一个技术问题, 而是个业务思维问题了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先看流程吧:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;function 处理异常(ex) {
    if (业务逻辑不需要回滚) {
        if (这种异常不需要处理, 或者可以被自动处理) {
            do: warn 日志|错误计数
            return
        } else {
            do: error 日志
            return
        }
    }

    if (不符合业务逻辑规则, 我可以抛给用户, 可以让用户知道发生了什么, 并且能够理解的) { // 非 bug
        do: 抛出 ServiceException, 带上错误 tip. 在用户接口层对这个错误进行处理, 返回提示, 打印 warn 日志, 或进行审计计数.
        return
    } else if (不符合业务逻辑规则, 但是也没有办法通知用户到用户的) {
        return
    } else if (系统内部运行不符合预期的) { // bug 或 问题
        do: 抛出 ServiceErrorException, tip: 系统错误. 统一 catch 输出异常提示, 打 error 日志
        return
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;lt;1&amp;gt;
&amp;lt;2&amp;gt; 通常是我不能处理的, 因为我不知道这个异常对于整个业务逻辑有着什么影响, 所以一般都是不能抢救的. 例外的, 对于创建链接超时这种不确定异常, 可以重试下, 很多 HTTP 请求框架也是有这么做的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;warn 日志 - 不太需要关注, 通常可以自动恢复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;error 日志 - 错误, 需要报警关注&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常收集计数 report&lt;/p&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;通常不太需要关注, 但是达到某种阈值会变成问题.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要定期例行关注下.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>一个更有表现力的异常设计</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/expressive-exception-lib.html</link>
      <pubDate>星期日, 8 十二月 2019 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/expressive-exception-lib.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_动机&quot;&gt;1. 动机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_设计意图&quot;&gt;2. 设计意图&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_message&quot;&gt;2.1. message&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_code&quot;&gt;2.2. code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_tip&quot;&gt;2.3. tip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_data&quot;&gt;2.4. data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_level&quot;&gt;2.5. level&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_usage&quot;&gt;3. USAGE&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_引入&quot;&gt;3.1. 引入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用&quot;&gt;3.2. 使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_拓展异常_level&quot;&gt;3.3. 拓展异常 level&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何处理异常&quot;&gt;4. 如何处理异常&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_spring_mvc&quot;&gt;4.1. spring mvc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_dubbo&quot;&gt;4.2. dubbo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_意见收集&quot;&gt;5. 意见收集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Build an exception with optional fields: &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;tip&lt;/code&gt;, &lt;code&gt;level&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个能够包含更多信息的异常基础库. 是一套异常设计和处理的方法论的落地.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;git 地址: &lt;a href=&quot;https://github.com/yxc023/expressive-exception&quot; class=&quot;bare&quot;&gt;https://github.com/yxc023/expressive-exception&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_动机&quot;&gt;1. 动机&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在业务项目实践中, 异常经常用来传递一些业务错误或者警告.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常, 这些业务错误和警告, 经常要包含更多的信息, 比如错误编码, 错误消息. 有时为了给用户更好体验, 还会放入一些便于用户阅读的消息. 甚至, 还会需要一些数据.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_设计意图&quot;&gt;2. 设计意图&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在多个业务系统实践中, 我做了一个总结, 一个好用的异常, 要包含以下几个数据:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;message&lt;/code&gt; - 异常都会包含的消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;code&lt;/code&gt; - 异常编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tip&lt;/code&gt; - 异常提示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt; - 可选, 异常携带的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;level&lt;/code&gt; - 可选, 异常级别&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面对每一项进行详细说明.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_message&quot;&gt;2.1. message&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常意义下的 exception message, 通常是对异常的描述. 比如当要删除一个订单, 但给的订单号并不存在时:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Order not found, id: 1001&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常是英文, 且格式标准专业, 包含了异常相关足够的信息.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_code&quot;&gt;2.2. code&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为业务比较复杂, 异常情况也很多, 我们基本不会对每一种异常设计一个异常类型. 比如在处理订单操作时, 我们只定义一种异常类型: &lt;code&gt;OrderOperationException&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么更细节的异常我们可以通过编码来表示:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;SUCCESS - 成功都是相同的

// 而失败各有不同
FAILURE - 通用的失败编码
ORDER_NOT_FOUND - 订单不存在
ORDER_HAD_PAYED - 订单状态异常: 已经支付过了
...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;code&lt;/code&gt; 使用字符串, 好处是更易读.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_tip&quot;&gt;2.3. tip&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;tip&lt;/code&gt; 和 &lt;code&gt;message&lt;/code&gt; 很像, 都是用来表达异常的信息. &lt;code&gt;tip&lt;/code&gt; 的设计意图在于&lt;mark&gt;提供用户可读的异常信息&lt;/mark&gt;. 比如&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;要操作的订单号[1001]不存在.
订单[1001]已经支付过了.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_data&quot;&gt;2.4. data&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt; 的作用是与请求成功响应时返回的数据项对齐.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在发生异常时, &lt;code&gt;data&lt;/code&gt; 其实并不常用, 场景比较少. 只是在发生异常时需要返回一些关联数据. 举一个场景:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当用户购买一个比较抢手的产品时, 有一个购买限制: 一个用户下单后必须支付才能下第二单.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么, 当用户触发这个限制时, 返回的异常中要包含未支付的订单号, 再由统一的异常处理转换成带有 data 的异常返回信息.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_level&quot;&gt;2.5. level&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;异常为什么要分级? 因为我在业务逻辑中, 所有不符合最常规业务逻辑流程的, 都使用异常来返回.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么有的异常可能并不算是错误. 比如登录时账号密码不匹配, 这并不是系统 bug 引起的错误, 也不需要记录 error 日志, 甚至报警.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而有的, 比如逻辑执行中, 某个数据一定应该存在的, 结果没有查询到, 代表着数据完整性异常, 那么这是真真正正的 error.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而其他的, 甚至还有说偶尔异常没问题, 大量异常有问题的. 比如客户端断开连接, 偶尔出现很正常, 但大量出现就是有问题的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以在设计中, 默认将异常 level 分为了两类:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SERVICE_LEVEL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ERROR_LEVEL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_usage&quot;&gt;3. USAGE&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_引入&quot;&gt;3.1. 引入&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;dependencies {
    compile &apos;com.yangxiaochen:expressive-exception-core:1.2.1-RELEASE&apos;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_使用&quot;&gt;3.2. 使用&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;code&gt;exception-core&lt;/code&gt; 中, 提供了 &lt;code&gt;HasTip&lt;/code&gt;, &lt;code&gt;HasCode&lt;/code&gt;, &lt;code&gt;HasData&lt;/code&gt;, &lt;code&gt;HasLevel&lt;/code&gt; 几个接口, 你需要定义自己的异常类时:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public class MyException extends Exception implements HasTip, HasCode, HasData, HasLevel {
    ...
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了方便定义异常类, 提供了两个抽象类 &lt;code&gt;BaseExprException&lt;/code&gt;, &lt;code&gt;BaseExprRuntimeException&lt;/code&gt;, 可以直接继承这两个类:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public class MyException extends BaseExprException {
    ...
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;打印出的异常 log 例子:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;com.yangxiaochen.exception.test.application.exception.ServiceRuntimeException: [SERVICE_EXCEPTION] default service exception, tip: 默认业务异常, ctxVars: {fooId=1002, time=Wed Aug 21 18:17:26 CST 2019}
...&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_拓展异常_level&quot;&gt;3.3. 拓展异常 level&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以通过实现 &lt;code&gt;ExceptionLevel&lt;/code&gt; 来定义新的异常 level.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_如何处理异常&quot;&gt;4. 如何处理异常&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;mark&gt;异常定义只是一个方面,  如何看待, 解释, 处理我们定义的异常是另一个方面.&lt;/mark&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_spring_mvc&quot;&gt;4.1. spring mvc&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;expressive-exception-spring-mvc/src/main/java/com/yangxiaochen/exception/spring/ExceptionHandler.java&quot;&gt;spring mvc exception handler&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;dependencies {
    compile &apos;com.yangxiaochen:expressive-exception-spring-mvc:1.2.1-RELEASE&apos;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;提供了一个默认的 &lt;code&gt;ExceptionHandler&lt;/code&gt;, 来统一处理异常, 其核心异常处理方法实现如下:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
    if (pathPrefixs.stream().noneMatch(prefix -&amp;gt; request.getRequestURI().startsWith(prefix))) {
        return null;
    }

    ex = translateException(ex, request);
    if (ex == null) {
        return null;
    }
    logAction.log(request, ex);

    return errorViewResolver.resolve(request, response, ex);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;加入到 spring mvc 框架中实现异常的统一处理:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Configuration
public class MvcConfig implements WebMvcConfigurer {

    private boolean printStack = false;
    private MappingJackson2JsonView view = new MappingJackson2JsonView();

    @Override
    public void extendHandlerExceptionResolvers(List&amp;lt;HandlerExceptionResolver&amp;gt; resolvers) {
        ExceptionHandler exceptionHandler = new ExceptionHandler();
        resolvers.add(0, exceptionHandler);
    }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以对 &lt;code&gt;ExceptionHandler&lt;/code&gt; 的处理行为进行定制:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exceptionHandler.setPathPrefixs(Arrays.asList(&quot;/web/&quot;, &quot;/api/&quot;));
exceptionHandler.setErrorViewResolver((request, response, ex) -&amp;gt; {
    ModelAndView mv = new ModelAndView();
    mv.addObject(&quot;msg&quot;, ex.getMessage());
    mv.addObject(&quot;success&quot;, false);
    if (ex instanceof HasCode) {
        mv.addObject(&quot;code&quot;, ((HasCode) ex).getCode());
        if (((HasCode) ex).getCode() == null) {
            mv.addObject(&quot;code&quot;, 0);
        }
    }
    if (ex instanceof HasTip) {
        mv.addObject(&quot;tip&quot;, ((HasTip) ex).getTip());
        if (ex.getMessage() == null) {
            mv.addObject(&quot;msg&quot;, ((HasTip) ex).getTip());
            mv.addObject(&quot;message&quot;, ((HasTip) ex).getTip());
        }
    }
    if (ex instanceof HasData) {
        mv.addObject(&quot;data&quot;, ((HasData) ex).getData());
    }
    if (printStack) {
        mv.addObject(&quot;stackTrace&quot;, getStackFrames(ex));
    }
    mv.setView(view);
    return mv;
});&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_dubbo&quot;&gt;4.2. dubbo&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;expressive-exception-dubbo/src/main/java/com/yangxiaochen/exception/dubbo/GlobalExceptionFilter.java&quot;&gt;dubbo filter&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_意见收集&quot;&gt;5. 意见收集&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个项目即是一个类库, 更是一个异常设计和处理的方法论, 类库是方便方法论落地的措施.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果你有不同的想法和意见, 欢迎 issue 交流.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>项目接口设计实践</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/api-design.html</link>
      <pubDate>星期四, 25 七月 2019 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/api-design.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_接口&quot;&gt;2. 接口&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_宏观战略&quot;&gt;2.1. 宏观战略&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_接口组织结构&quot;&gt;2.1.1. 接口组织结构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_细节战术&quot;&gt;2.2. 细节战术&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_通用&quot;&gt;2.2.1. 通用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_面向服务&quot;&gt;2.2.2. 面向服务&lt;/a&gt;
&lt;ul class=&quot;sectlevel4&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_http&quot;&gt;http&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_dubbo&quot;&gt;dubbo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_面向前端&quot;&gt;2.2.3. 面向前端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_callback&quot;&gt;2.2.4. callback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_文档&quot;&gt;3. 文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;项目不同, 项目提供的接口功能也不同, 能否有一套比较通用切良好的规则, 来指导我们对项目接口的宏观设计和细节设计?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文是我在项目中设计 api 接口的一些实践经验.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_接口&quot;&gt;2. 接口&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_宏观战略&quot;&gt;2.1. 宏观战略&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_接口组织结构&quot;&gt;2.1.1. 接口组织结构&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个项目中, 接口组织结构应该是良好干净的. 接口不是想写哪里写哪里, 接口需要有功能分类, 业务分类, 协议分类, 然后分门别类的组织在不同的文件夹里.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;按照功能作用分&lt;/dt&gt;
&lt;dd&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统间服务接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;按照业务分&lt;/dt&gt;
&lt;dd&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;业务模块 A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务模块 B&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;按照协议分&lt;/dt&gt;
&lt;dd&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dubbo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;很多人多多少少想过这些分类, 但很少想过要把接口按照这些组织好. 我给出一个接口的组织目录&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;application
+-- api                         // 面向服务的接口
|   +-- dubbo                   // dubbo 协议的接口
|   |   +-- order               // 按照业务化分, order 模块的接口
|   |   +-- product
|   |   \-- module C
|   \-- http                    // http 协议的接口
+-- controller                  // 面向前端的接口
|   +-- web                     // ajax 请求接口
|   |   +-- order               // 按照业务化分
|   |   \-- product
|   +-- page                    // 页面请求接口
|   +-- manage                  // 管理用的 ajax 和 页面接口.
|       +-- web
|       \-- page
\-- callback                    // 接收回调的接口&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先按照面向服务, 面向前端进行化分.&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;验证方式不同. 面向前端的接口通常要认证登录状态; 面向服务的接口通常是接入验证.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者不同. 前端接口调用者是用户, 请求的数据通常更贴近展示, 面向展示设计接口, 当发生异常时, 需要返回一些用户可读的信息; 服务接口使用者是系统代码, 请求的数据更贴近领域模型, 根据自身领域来暴露服务, 发生异常时, 需要返回明确的状态码, 来供调用方程序判断.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在面向服务的接口中, 提供了不同协议的接口. 不同协议的接口中, 又按照不同的模块化分.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在面向前端的接口中, 分为 &lt;code&gt;web&lt;/code&gt; 和 &lt;code&gt;page&lt;/code&gt; 两种, 分别应对 ajax 请求和页面请求.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在面向前端的接口中, &lt;code&gt;manage&lt;/code&gt; 包里为管理后台的接口. 因为管理后台通常跟前台的请求要求的身份权限不同.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立出 &lt;code&gt;callback&lt;/code&gt; 类型的接口, 这种接口往往按照回调发起方的接口规范来.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上, 我们通过接口的受众和类型, 制定了一套接口的组织形式.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;目的是保持清晰, 避免混用. 因为我们经常会在接口层做一些通用的操作, 比如日志, 性能打点, 认证等, 对于不同的功能和作用的接口是不同的, 做划分之后, 我们可以分别处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上面的目录划分的真实代码示例, 可以在 &lt;a href=&quot;https://github.com/yxc023/blueprint/tree/master/blueprint-application/src/main/java/com/yangxiaochen/blueprint&quot;&gt;blueprint project&lt;/a&gt; 找到.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_细节战术&quot;&gt;2.2. 细节战术&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_通用&quot;&gt;2.2.1. 通用&lt;/h4&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;读接口无副作用, 不要返回业务异常或错误码&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;获取信息的时候, 有就是有, 没有就是没有. 比如, 当调用 &lt;code&gt;getOrder(orderId)&lt;/code&gt; 接口时, 没有数据就返回 &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而不要返回一个错误叫做 &lt;code&gt;订单不存在&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向服务的写接口声明会发生的各种异常和错误码&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;让异常类型中包含 &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;tip&lt;/code&gt;, &lt;code&gt;level&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;. 让异常能够传递更多信息.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;https://github.com/yxc023/expressive-exception&quot;&gt;A More Expressive Exception Library, 更有表达力的异常类库&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向服务的接口设计应该以自身业务另约需要暴露的功能为出发点, 而不是尊奉需求方的要求.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;站在自身角度来思考我能够提供什么服务, 标准能力.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如作为订单管理系统, 提供 &lt;code&gt;创建订单&lt;/code&gt;, &lt;code&gt;通用查询订单&lt;/code&gt; 的 api 接口.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是对于使用方想要 &lt;code&gt;查询女性用户创建的订单&lt;/code&gt;, 这种显然就不是一种标准能力.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计完之后, 要站在使用者的角度试用自己的接口, 看是否有问题.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了保证自己设计和提供的标准服务 api 不是闭门造车, 能够符合使用者的要求, 要站在使用者角度, 来尝试使用自己的接口, 看是否符合预期.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口给出粗粒度的数据&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;跟项目里的方法接口不同, 在对外服务接口上要提供粗粒度的数据. 有时我们的数据模型存放在多个表里, 或者多个实体形成了一个聚合. 那么在返回数据时, 要想想一下使用者拿到数据后的使用, 提供足够的数据, 避免接口太零碎需要多次访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过 &lt;code&gt;GraphQl&lt;/code&gt; 可以一定程度解决一些接口数据层复杂度的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_面向服务&quot;&gt;2.2.2. 面向服务&lt;/h4&gt;
&lt;div class=&quot;sect4&quot;&gt;
&lt;h5 id=&quot;_http&quot;&gt;http&lt;/h5&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;服务接口 path 为 &lt;code&gt;/api/**&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 header 传递额外信息. 比如 appId, timestamp, 签名信息等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写接口使用 &lt;code&gt;POST&lt;/code&gt;, 接收参数类型为 &lt;code&gt;application/json&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 &lt;code&gt;POST&lt;/code&gt; 的写接口进行验签时, 由于 content 是 json 类型, 格式层次复杂, 不能把每个字段拿出来加入到签名中做校验, 所以把 content 的内容做哈希算法签名, 来做为一个校验字段, 而不用使用 content 里单独的字段来做.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用统一的 &lt;code&gt;ApiResult&lt;/code&gt; 对象封装结果返回. &lt;code&gt;ApiResult&lt;/code&gt; 包含 &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;tip&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; 等字段.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写接口的返回值中的 &lt;code&gt;code&lt;/code&gt; 应为字符串类型, 用于更有表达力的表明各种异常状态.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;response status code 使用. 参考 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;RFC 7231&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;正常和业务异常 - 200&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数校验错误 - 400&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验签未通过 - 401&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验签通过但是无权限使用接口 - 403&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意料外异常 - 500&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限流, 熔断, 拒绝服务 - 503&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect4&quot;&gt;
&lt;h5 id=&quot;_dubbo&quot;&gt;dubbo&lt;/h5&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;dubbo 接口的设计理念: 尽量使 rpc 调用看上去跟调用本地方法一样.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;结果无需再做封装, 成功就是成功了, 失败通过异常类传递.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读接口直接返回数据, 无需额外封装. 读接口不抛业务异常, 有异常就认为 bug.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;OrderDTO getByOrderId(Long orderId);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;https://github.com/yxc023/blueprint/blob/master/blueprint-api-dubbo/src/main/java/com/yangxiaochen/blueprint/api/dubbo/order/OrderFacade.java&quot;&gt;OrderFacade#getByOrderId&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写接口返回数据无需额外封装. 业务异常信息通过 &lt;code&gt;Exception&lt;/code&gt; 抛出, 并包含异常 &lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Long createOrder(OrderCreateParam orderCreateParam) throws ApiException;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;声明要抛出的异常.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;https://github.com/yxc023/blueprint/blob/master/blueprint-api-dubbo/src/main/java/com/yangxiaochen/blueprint/api/dubbo/order/OrderFacade.java&quot;&gt;OrderFacade#createOrder&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dubbo 接口实现中, 要做异常全局处理, 转化为 &lt;code&gt;ApiException&lt;/code&gt;. 并将 &lt;code&gt;ApiException&lt;/code&gt; 放到发布的 api 包中. 否则无法在 dubbo 客户端对异常反序列化.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;实现 dubbo 的 filter 来做全局的异常处理, 将系统内的异常, 转化为 api 包中的 &lt;code&gt;ApiException&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;https://github.com/yxc023/blueprint/blob/master/blueprint-application/src/main/java/com/yangxiaochen/blueprint/api/dubbo/DubboExceptionHandler.java&quot;&gt;DubboExceptionHandler&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dubbo 发布的 api 包中, 应包含接口用到的&lt;strong&gt;常量&lt;/strong&gt;, &lt;strong&gt;数据对象&lt;/strong&gt;, &lt;strong&gt;异常 code 常量&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面的例子中这个 module 就要作为一个 api jar 包发布出去.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;see &lt;a href=&quot;https://github.com/yxc023/blueprint/tree/master/blueprint-api-dubbo/src/main/java/com/yangxiaochen/blueprint/api/dubbo&quot;&gt;api jar&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;包含了 &lt;code&gt;ExceptionCodes&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, &lt;code&gt;dto&lt;/code&gt; 等对象.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dubbo 接口不应返回枚举类型以及包含枚举类型的对象. 应该转成字符串或数字常量返回. 避免客户端因为服务端枚举类变化导致反序列化的失败.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如在项目业务逻辑中, &lt;code&gt;Order&lt;/code&gt; 中的 &lt;code&gt;orderStatus&lt;/code&gt; 字段是 &lt;code&gt;OrderStatusEnum&lt;/code&gt; 类型.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么在接口输出时, &lt;code&gt;OrderDTO&lt;/code&gt; 中要变为 &lt;code&gt;orderStatus: Integer|String&lt;/code&gt; 和 &lt;code&gt;orderStatusName: String&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dubbo 发布的 api 包中, 应该配套 source 包. 源码中应该有足够的注释.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在使用者最容易看到的地方提供足够的说明.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dubbo 的认证信息可以包含在 &lt;code&gt;attachment&lt;/code&gt; 里.&lt;/p&gt;
&lt;div class=&quot;exampleblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;和诸多协议一样, dubbo 协议也有自己的 &quot;header&quot;, 那就是 &lt;code&gt;attachment&lt;/code&gt;, 请求附加信息可以使用 &lt;code&gt;attachment&lt;/code&gt; 传输.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_面向前端&quot;&gt;2.2.3. 面向前端&lt;/h4&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;前端接口 path 为 &lt;code&gt;/web/**&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端页面 path 为 &lt;code&gt;/page/**&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端接口的设计理念: 为展示而生, 能够为让前端直接做显示而不用做一些逻辑判断. 但是不能完全脱离业务模型.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用统一的 &lt;code&gt;Result&lt;/code&gt; 对象封装结果返回. &lt;code&gt;Result&lt;/code&gt; 包含 &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;tip&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; 等字段.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常要统一包装成数据返回, 需要返回人类可读的 tip. 绝大多数异常情况接口不需要返回特定错误码.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;response status code 使用. 参考 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;RFC 7231&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;正常和业务异常 - 200&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数校验错误 - 200 - tip: 参数错误:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验签未通过 - 401 - 且返回 header 中包含重定向 location, 供前端同学跳转登录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验签通过但是无权限使用接口 - 403 - tip: 你没有相关权限.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意料外异常 - 200 - tip: 发生内部错误, 工程师已经收到正在修复. 有问题请联系 XXX.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限流, 熔断, 拒绝服务 - 200 - tip: 当前系统繁忙, 请稍候再试&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_callback&quot;&gt;2.2.4. callback&lt;/h4&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;callback 接口 path 为 &lt;code&gt;/callback/**&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;callback 接口尊奉回调发起方的接口格式要求.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_文档&quot;&gt;3. 文档&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;

&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>「企业应用架构模式」读书笔记与思考 - 1 - 领域逻辑模式</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/reading-notes-for-PoEAA1.html</link>
      <pubDate>星期五, 12 七月 2019 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/reading-notes-for-PoEAA1.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_笔记&quot;&gt;2. 笔记&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_领域逻辑模式&quot;&gt;2.1. 领域逻辑模式&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_事务脚本&quot;&gt;2.1.1. 事务脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_领域模型&quot;&gt;2.1.2. 领域模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_表模块&quot;&gt;2.1.3. 表模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_服务层&quot;&gt;2.1.4. 服务层&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;3. 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TBD.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最近读了 Martin Fowler 的[企业应用架构模式](Pattern of Enterprise Application Architecture), 记一些笔记和思考.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;全书讲了几十个&quot;企业应用架构&quot;的模式. 区别于我们常说的设计模式, 这里的设计模式是描述`项目整体结构和业务组织结构`, 而不单单是`代码结构`.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而且多种模式通常是糅合在在一起,&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之所以要抽象出这些模式和概念, 就是为了简化之后的思考, 给之后遇到的问题奠定几个思考方向. 相当于把设计和思考的成果固化, 提高思维熟练度, 而不是每次都重头来想一边.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_笔记&quot;&gt;2. 笔记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_领域逻辑模式&quot;&gt;2.1. 领域逻辑模式&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;领域逻辑模式主要解决了 &quot;核心业务逻辑如何组织&quot; 这一问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_事务脚本&quot;&gt;2.1.1. 事务脚本&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;将一个完整的业务请求使用一个方法完成, 整个方法处于一个事务之中.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过过程来组织逻辑, 每个过程来自表现层的一个请求&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如 &lt;code&gt;创建订单&lt;/code&gt; 这个请求, 就是由 &lt;code&gt;OrderFlowService.createOrder()&lt;/code&gt; 方法完成. 过程中执行 &lt;code&gt;接收参数&lt;/code&gt;, &lt;code&gt;新建订单&lt;/code&gt;, &lt;code&gt;校验&lt;/code&gt;, &lt;code&gt;保存订单&lt;/code&gt;, &lt;code&gt;库存扣减&lt;/code&gt; 等逻辑代码.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_领域模型&quot;&gt;2.1.2. 领域模型&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果用领域模型来描述 &lt;code&gt;创建订单&lt;/code&gt; 的逻辑, 大概是这样:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;OrderDomain order = new OrderDomain(createOrderParams)

order.doCreate()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而在 &lt;code&gt;order.doCreate()&lt;/code&gt; 里:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;order.validate() &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
order.lockSaleInventory() &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
order.create() &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;校验&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;锁定订单中商品的销售库存, 等到支付完成后进行扣除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;创建订单&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;什么意思呢, 具体逻辑由领域对象来完成.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_表模块&quot;&gt;2.1.3. 表模块&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;作者例举了一个 .NET 框架中的例子. 为了方便说明, 我还用上面的 java 的例子来说.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;em&gt;表模块模式&lt;/em&gt; 是指业务中操作的对象背后关联着一个数据表. 以表为维度描述逻辑.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Order order = new Order(dataSource) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
SaleInventory saleInventory = new SaleInventory(dataSource) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;

validate(createOrderParams)

createOrderParams.products.each { productToBuy -&amp;gt;
    saleInventory.updateLock(productToBuy.id, productToBuy.count)
}

order.insert(extractDataFromParams(createOrderParams))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;订单的表模块对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;销售库存的表模块对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看上去很像 DAO. 使用跟数据库表完全对应的数据访问对象来完成业务逻辑.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其实很多 java 程序员所写的大概是这种面向对象的业务逻辑, 面向的对象其实是数据库表.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;与其说做了业务抽象, 不如说只是把事务脚本中访问数据库的代码按照不同的表进行了封装罢了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_服务层&quot;&gt;2.1.4. 服务层&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;图 TBD.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;服务层定义了应用边界和标准能力, &lt;strong&gt;从接口客户层角度所能看到的可用操作集合&lt;/strong&gt;. 它封装了应用的业务逻辑, 事务控制, 及其操作实现中的响应协调.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如定一个了一个 &lt;code&gt;OrderFlowBiz&lt;/code&gt; 的服务层对象, 包含了对订单流程的操作集合.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;createOrder()
pay()
payComplete()
delivery()
receive()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个模式中, 服务层通常很像事务脚本, 需要明确的针对特定业务请求.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常, 服务层会在领域逻辑层之上, 作为领域逻辑的操作门面. 因为领域层的细节操作太多, 不要暴露给接口层.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_总结&quot;&gt;3. 总结&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;复杂度和业务抽象程度: 事务脚本 &amp;lt; 表模块 &amp;lt; 领域模型&lt;/p&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;事务脚本最简单, 我也很喜欢, 应对任务型工作, 事务脚本很好用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表模块是对事务脚本进行的面向对象的抽象, 把访问数据库的代码抽象到了对象里. 甚至不能叫面向对象, 而只是在事务脚本的基础上引入了一些对象, 方便数据库访问. 可能我们多数程序员都是在写这种代码.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领域模型是回到面向对象第一节课上所讲的, 让对象有生命力, 不仅有自己的属性, 还有自己的行为.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务层通常在表模块或者领域模型之上一层, 作为业务能力暴露&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>如何有效的书写项目单元测试</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/how-to-write-unittest.html</link>
      <pubDate>星期一, 17 六月 2019 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/how-to-write-unittest.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何开始写单测&quot;&gt;2. 如何开始写单测&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_测试带来的好处&quot;&gt;3. 测试带来的好处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何写业务单元测试&quot;&gt;4. 如何写业务单元测试&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_为单测准备独立的环境_可重复执行&quot;&gt;4.1. 为单测准备独立的环境 [可重复执行]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用表达力更强的语言来书写测试_易书写&quot;&gt;4.2. 使用表达力更强的语言来书写测试 [易书写]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_创建单元测试基础类_易书写&quot;&gt;4.3. 创建单元测试基础类 [易书写]&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_数据模板&quot;&gt;4.3.1. 数据模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_业务操作便捷方法&quot;&gt;4.3.2. 业务操作便捷方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_mock_方法&quot;&gt;4.3.3. mock 方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_测试哪些代码&quot;&gt;5. 测试哪些代码&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_业务逻辑层&quot;&gt;5.1. 业务逻辑层&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_对外接口层&quot;&gt;5.2. 对外接口层&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_其他场景的测试&quot;&gt;6. 其他场景的测试&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_异步逻辑测试&quot;&gt;6.1. 异步逻辑测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_并发逻辑测试&quot;&gt;6.2. 并发逻辑测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;7. 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我近两年在几个业务项目中都尝试编写了单元测试, 用于保障业务逻辑的正确性.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里所说的单测, 并不是常规的对单一小方法的测试, 而是对业务流程的测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这个过程中, 遇到了很多问题, 也总结了一些经验, 所以写下了这篇文章, 感觉是一套比较有效和有参照意义的方法论.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_如何开始写单测&quot;&gt;2. 如何开始写单测&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;第一次写单测, 是一个审批流业务相关的项目, 内部业务逻辑很复杂, 分支判断多. 不同的审批流配置, 最终审批流运行时的表现是不一样的. 在当时的开发和测试过程中, 就遇到了问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;每修改一个功能或者加一个特性, 测试需要全流程来测试, 而且我还在不断重构代码, 测试的自动化 case 修改速度还跟不上我的功能开发速度.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外, 我在开发时也需要自测, 我需要从头构建一个审批流配置, 然后发起流程, 走到我新加了特性的节点, 才能验证我的功能. 当发现验证失败后, 就找问题, 修改代码, 然后重复这个过程, 效率及其低下.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;于是, 我就写了一套从定义审批流配置, 到后续审批节点操作, 整个流程的测试代码. 用于一键自测.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;后来, 因为不同的配置会对逻辑有影响, 所以我准备了多套审批流程配置, 也就是多个测试用例.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;后面, 又进行了优化和完善, 最终达到了以下目标:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可重复执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易书写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两点, 是单测的灵魂.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可重复执行, 保证了单测并非一次性的, 每次测试数据是相同的. 如果每次测试都是不一样的数据, 需要人工修改, 那就没有意义.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;易书写, 只有易书写, 单测的编写才能持续下去. 如果编写一个 case 总是需要很长时间, 谁都没有太大动力去维护和添加单测.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_测试带来的好处&quot;&gt;3. 测试带来的好处&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我之所以坚持给业务项目写单元测试, 是因为我确确实实尝到了甜头:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开发效率提高&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;开发中验证功能, 通过一键测试就可以. 不用启动项目, 手动构造数据, 再进行触发.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试效率提高&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;开发人员是最了解代码的, 开发人员写的单元测试相当于做了白盒测试, 提前检查了问题, 也减少了漏测.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提升了重构的动力和信心&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;重构风险大? 是的, 改动那么大, 心里怎么才能有底? 重构完成后, 单测一跑全都过了, 别样的舒爽, 重构不害怕.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对业务逻辑进行 review&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;书写单测的过程, 也是对自己业务逻辑 review 的过程.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果构建一个单测来完成业务流程都非常费力, 这个代码结构, 逻辑结构一定是有问题的.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总而言之, 最直观的感受就是: 漏测率大大下降; 重构引发的问题几乎没有; 单测跑通后, 在 qa 那边基本不会有大的逻辑上的 bug.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面我就罗列一些点, 来说一说如何写单元测试. 这些点都可以归纳到达成 [可重复执行] 或 [易书写] 的目标中.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_如何写业务单元测试&quot;&gt;4. 如何写业务单元测试&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我所做的项目都是 java 项目, 使用的都是 spring boot 框架, 所以测试也是使用 spring boot test 来进行项目启动和测试的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;具体的实现方式是跟语言框架相关的, 但是思想是通用的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_为单测准备独立的环境_可重复执行&quot;&gt;4.1. 为单测准备独立的环境 [可重复执行]&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为项目总是会依赖一些基础服务环境, 比如 数据库, redis, zk 等. 我的一个原则是, 单测时使用独立的一套环境, 而不是跟开发和测试时用一套环境, 并且, 这个环境在每次单测启动时, 是要进行初始化的, 保证每次单测的初始数据是完全一致的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;介绍几个我用过的方式:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mysql&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;单独建立一个 unittest 的空数据库. 使用 &lt;code&gt;Flyway&lt;/code&gt; 来管理这个项目的所有 sql 初始化语句. 当测试用例启动时, 清空这个库, 执行所有的初始化语句, 并且将项目中的数据源改为这个库.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redis&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用单独的 redis 实例或者 db. 在每次启动时 &lt;code&gt;flushdb&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zk&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;zk 可以用单独的服务或者更换节点域. 更简单是使用 zk 的 test 框架, 可以直接在测试启动时, 运行一个本地的测试 zk 服务.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总之, 最终目的是保证单测的环境及初始数据每次都是一致的, 且可预期的.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_使用表达力更强的语言来书写测试_易书写&quot;&gt;4.2. 使用表达力更强的语言来书写测试 [易书写]&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我使用 groovy 来给 java 的项目写测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;能够无缝使用 java 的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达力更强, 更易书写.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能够字面式的初始化对象, 列表, map.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;弱类型, 且语法足够灵活, 简练.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_创建单元测试基础类_易书写&quot;&gt;4.3. 创建单元测试基础类 [易书写]&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个项目的业务是不一样的, 但在一个项目内部, 业务和功能大多领域是一致的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;创建一个 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; , 里面包含这个项目中比较通用的功能或者业务组件, 让所有的测试类都继承这个基础类, 都能够放点的调用自己需要的功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面是一个 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; 的简单的例子, 设置了测试的启动环境, 并定义了一些公用变量, 方便子类调用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@RunWith(SpringRunner)
@SpringBootTest(
        classes = TestBoot,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = [&quot;spring.profiles.active=local,unittest&quot;]) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
@ContextConfiguration(initializers = [TestZookeeperServerInitializer, TestDBinitializer, TestRedisinitializer]) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
abstract class AbstractTest {

    @LocalServerPort
    Integer port &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;

    @Autowired
    Environment environment

    ObjectMapper objectMapper = new ObjectMapper()

    static User USER1 = new User(10000001, &quot;user1&apos;s name&quot;, &quot;18812388888&quot;, &quot;org101&quot;) &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;

    ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;加载测试时加载 &lt;code&gt;unittest&lt;/code&gt; 配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;用于环境初始化的组件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;项目使用的随机端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;通用的用户&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_数据模板&quot;&gt;4.3.1. 数据模板&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;数据是每个测试用例的核心, 如何方便的构造测试数据, 是一个项目测试是否可持续的关键.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我的方法是, 将项目中关键的领域对象, 实例化一个或多个 &lt;strong&gt;&lt;em&gt;数据模板&lt;/em&gt;&lt;/strong&gt;, 数据模板的数据都是默认数据. 通过修改模板中的数据, 来达到构造不同数据 case 的效果. 最后将模板生成为初始数据.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;整个过程的分 3 步:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Template template = defaultTemplate() &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
template.field1 = case1 &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
template = saveTemplate(template) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;获取默认数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;在默认数据基础上构造 case&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;生成初始化数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;拿一个商店的项目作为例子, 当我想测试下单流程, 我需要有现成的商品才行, 而不同的商品的下单流程逻辑中有不同的分支. 简化的代码如下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;class OrderTest extends AbstractTest {

    ProductTemplate productTemplate

    void pre() {
        // 获取初始化的产品数据
        // 包括产品的基本信息, 店铺信息, sku 信息, 购买时的限制策略等
        productTemplate = defaultProduct() &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

        productTemplate.productDomain.merchantCode = &apos;test-shop&apos;
        productTemplate.productDomain.scopeIds = [1, 2, 3] &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        productTemplate.productDomain.attributes += [size: 30]
        productTemplate.skuDomains[0].productSku.salePrice = 100

        productTemplate = saveProduct(productTemplate) &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;

        adjustInventory(productTemplate.skuDomains[0].skuId, 10) &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        adjustInventory(productTemplate.skuDomains[1].skuId, 10)

    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;获取初始化的产品数据. 这个 &lt;code&gt;defaultProduct()&lt;/code&gt; 是写在 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; 里的 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;对初始化数据进行修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;生成初始化数据. 这个 &lt;code&gt;saveProduct()&lt;/code&gt; 是写在 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; 里的 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;对初始化好的数据进行操作, 这里是调整了库存. 这个 &lt;code&gt;adjustInventory()&lt;/code&gt; 是写在 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; 里的 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是一个测试下单逻辑的前置数据生成逻辑, 可以方便的构造各种产品 case.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-tip&quot; title=&quot;Tip&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
能够方便的生成初始数据, 是代码业务逻辑合理的表现. 当原有业务代码比较糟糕, 写测试的时候也会非常的困难
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_业务操作便捷方法&quot;&gt;4.3.2. 业务操作便捷方法&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上面的例子中, 已经出现了 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt; 的意图, 是对业务中的操作进行简化. 有可能我们测试逻辑, 需要很多前置逻辑, 比如: 退款逻辑. 当要测试退款逻辑时, 我们需要前置的一些列逻辑. 通过创造 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;, 对原有业务代码封装, 简化参数传递, 方便在测试中完成前置动作, 集中精力测试我们要测试的逻辑部分.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt; 定义在 &lt;strong&gt;&lt;em&gt;单测基础类&lt;/em&gt;&lt;/strong&gt; 中, 供所有测试类使用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-tip&quot; title=&quot;Tip&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
当然, 如果业务操作并不复杂, 也可以直接调用原有业务代码
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;列举一些我在项目中定义的一些 &lt;strong&gt;&lt;em&gt;便捷方法&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;abstract class AbstractTest {

    ProductTemplate defaultProduct()

    ProductTemplate saveProduct(ProductTemplate productTemplate)

    ProductDomain getProductDomain(Long productId) &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

    SkuDomain getSkuDomain(Long skuId)

    void adjustInventory(Long skuId, Long count)

    Long createOrder(CreateOrderBizParam param)

    OrderDomain getOrderDomain(Long orderId)

    void payOrder(Long orderId)

    void payCallback(Long orderId) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;

    ...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;获取产品和 sku 信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;模拟支付回调, 让订单到达支付完成状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_mock_方法&quot;&gt;4.3.3. mock 方法&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个项目总是会依赖其他的系统, 在单测时经常无法正常使用其他服务的接口, 比如你提供的测试用户在其他服务中根本找不到, 你的单测环境不能通过其他服务的访问验证, 还有就是单元测试不能给其他服务写入无用的测试数据.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是我们就需要用到 mock 方法.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 spring boot test 中, 提供了一种 mock 手段, 让我们能够使用一个 mock bean 来替换 spring 容器中特定的一个 bean.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当我们的业务逻辑执行这个特定的 bean 的方法时, 实际执行的是我们 mock bean 的对应方法.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看一个简单实例:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;abstract class AbstractTest {...

    @MockBean
    UserCenterRpc userCenterRpc &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

    static User USER1 = new User(10000001, &quot;user1&apos;s name&quot;, &quot;18812388888&quot;, &quot;org101&quot;)

    void mockUserCenterRpc() {
        Mockito.when(userCenterRpc.getUser(10000001)).thenReturn(USER1) &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;对系统中的 UserCenterRpc 类型的 bean 声明 mock. 这时系统中原有的 UserCenterRpc 类型的 bean 会被生成的 mock bean 给替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;定义 mock bean 的行为. 之后, 当业务逻辑执行到 &lt;code&gt;userCenterRpc.getUser(10000001)&lt;/code&gt; 时, 将不会执行真正的 user center rpc 操作, 而是直接返回我们给定的 &lt;code&gt;USER1&lt;/code&gt;, 达到 mock 的效果.&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sidebarblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;是否要对所有的依赖调用进行 mock?&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;显然, 这是一个非常繁琐的操作, 一定程度上违反了 &quot;易书写&quot; 的原则.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我的观点: &lt;strong&gt;能不用依赖就不用依赖&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果依赖提供的测试环境稳定, 依赖方能够一直提供你所需要的初始数据, 并且依赖方允许无意义的测试写入, 直接进行真是的依赖是最简单的方案.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当无法持久稳定的提供我们测试所需要的功能时, 并且 mock 能够提供最方便, 再选择 mock.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以 mock 是一个解决依赖问题的手段, 并不是个强制性的规则.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_测试哪些代码&quot;&gt;5. 测试哪些代码&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;究竟要测试哪些代码, 就我的经验来说, 主要测试两部分代码: 业务逻辑层, 接口层.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两个部分的测试中, 测试重点是不同的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_业务逻辑层&quot;&gt;5.1. 业务逻辑层&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;业务逻辑层就是通常所说的 &lt;code&gt;business&lt;/code&gt; 或者 &lt;code&gt;service&lt;/code&gt; 层. 是业务逻辑的 interface 层.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于审批流来说, 就是针对 &lt;code&gt;ProcessDefineService&lt;/code&gt; 中 &lt;strong&gt;定义流程&lt;/strong&gt; 的方法写测试, 对 &lt;code&gt;ProcessService&lt;/code&gt; 中 &lt;strong&gt;发起流程&lt;/strong&gt;, &lt;strong&gt;撤回流程&lt;/strong&gt; 等方法写测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于商店系统来说, 就是对 &lt;code&gt;OrderFlowBusiness&lt;/code&gt; 中 &lt;code&gt;createOrder&lt;/code&gt;, &lt;code&gt;cancelOrder&lt;/code&gt; 等方法做测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
这里的测试核心是逻辑的正确性, 考虑代码分支覆盖.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_对外接口层&quot;&gt;5.2. 对外接口层&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对外接口层, 一般是 http 的 web 前端接口, 或者提供出来的供其他服务进行远程调用的服务 api 接口.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
对外接口层的测试, 核心是接口定义的测试.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;保证正确的参数能够通过; 错误的参数或者业务异常情况, 能够正确返回接口定义中声明的错误编码或信息.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;测试重点是 &lt;strong&gt;不同的响应结果&lt;/strong&gt;, 而不是业务逻辑的每个分支.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-tip&quot; title=&quot;Tip&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
接口测试用例, 也能够检测接口兼容性升级的正确性. 比如接口添加了一个字段, 当字段没有传递时, 后端服务是否有设定默认值来兼容.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_其他场景的测试&quot;&gt;6. 其他场景的测试&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在测试中, 也遇到过一些写测试比较困难的场景. 比如 异步逻辑测试 和 并发逻辑测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面说一说我对着两个场景测试的经验.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_异步逻辑测试&quot;&gt;6.1. 异步逻辑测试&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;异步测试的问题在于经常不知道什么时候真正能拿到测试结果.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如我提交了一个支付请求, 而系统内部对收到支付请求后, 会直接返回请求接收的答复. 真正的出款, 入款操作, 都是异步执行, 完成后进行通知回调的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有几种处理方式:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;等&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;sleep 一段时间. 这是最简单的一个方式, 绝大多数情况下异步操作都是预期能很快执行完, 是够用的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但如果不能预估异步执行的时间, 或者时间太长, 再或者异步操作可能不会留下方便观测的结果(比如发送了短信, 执行了请求, 但是没有写入数据的逻辑).&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步改同步&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;设置代码开关, 在测试时同步执行. 这对开发时也很有利, 可以方便的跟踪执行流程.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但问题是跟线上真是环境有差异, 经常会有一些只有在异步情况下才会发生的错误. 异步改同步可能会漏掉这类错误.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点到为止&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;测试到异步任务提交即可. 这应该是最标准的异步测试方式了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如我测试业务中, 里面有一步需要提交一个异步任务, 去执行其他的业务逻辑.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么就是用 spring boot test 提供的 @SpyBean, 使用 BBD (Behavior Driven Development) 的方式检测 &lt;code&gt;SyncTaskService.submit()&lt;/code&gt; 方法是执行, 并且传入的 task 是我期望的. 代码类似于:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;BDDMockito.verify(syncTaskService, BDDMockito.times(1)).submit(argument -&amp;gt; {
    argument.taskId == 101 &amp;amp;&amp;amp; argument instance of
})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;异步的逻辑执行的测试单独写, 则直接手动执行特定参数的异步任务, 来测试执行结果.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_并发逻辑测试&quot;&gt;6.2. 并发逻辑测试&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;测试并发逻辑的难点在于不能稳定复现. 通常单元测试执行时不会有并发, 那么逻辑中并发场景的问题就无法被测试出.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个需要一定的预见性: 业务逻辑哪些地方需要有并发测试? 只有先确定哪里可能会有并发问题, 才能进行测试.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如说同一个账户的扣款请求, 比如同一个商品的购买减库存.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如何测试呢?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为并发的测试不能稳定复现, 所以这个测试一定不是 100% 能触发问题, 只能增加触发问题的概率.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;怎么增大触发并发问题出现的概率? 很简单, 增加次数.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;开启多个线程, 并发调用一块业务逻辑, 完成后检查正确性. 如果正确, 重复这一过程. 可以设定一个重复次数或者测试时间, 当次数或者时间达到时, 没有出现并发问题, 那么我们就认为这个并发测试是通过的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock tip&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-tip&quot; title=&quot;Tip&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
并发测试是跟常规测试分开的, 通常进行构建前检测的时候是不执行的, 因为太费时间.
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_总结&quot;&gt;7. 总结&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上就是我对写项目测试的经验.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;提出了测试的两个核心要求:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;可重复执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易书写.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了达到这两个要求, 采取的可实施的方案:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;为单测准备独立的环境 - 可重复执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用表达力更强的语言来书写测试 - 易书写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建单元测试的基础类 - 易书写&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中, 在&lt;strong&gt;创建单元测试的基础类时&lt;/strong&gt;, 主要做三件事情:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;数据模板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务操作的便捷方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mock 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在测试内容上, 分为两大类: 1. 业务逻辑; 2. 对外接口. 这两种测试测重点也不一样.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后, 介绍了异步, 并发这两种比较复杂的测试场景的测试方式.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sidebarblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;div class=&quot;title&quot;&gt;到底写多少测试才够?&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;覆盖所有测试 case 是个费时费力的工作.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;根据测试覆盖率的报告, 可以看到哪些分支和代码没有覆盖.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但也不用纠结于完全覆盖, 首先让测试能够覆盖正常流程. 剩下的可以慢慢添加.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>在 windows 系统下使用 linux 命令行做开发</title>
      <link>http://blog.yangxiaochen.com/blog/tools/linux-in-windows.html</link>
      <pubDate>星期一, 11 二月 2019 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/tools/linux-in-windows.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_manjaro_deepin&quot;&gt;2. manjaro &amp;amp; deepin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_虚拟机&quot;&gt;3. 虚拟机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_ubuntu_子系统&quot;&gt;4. ubuntu 子系统&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_安装&quot;&gt;4.1. 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用&quot;&gt;4.2. 使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我的开发主力机器是一台2014年的13寸 macbook pro. 几年来一直战斗力良好. 但是平时上班比较远, 有时候加班晚点, 回家的时候就不想背这个电脑.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有时回到家中想干点什么, 家里一台老旧的神舟战神笔记本被封存已久, 每次拿出来都要翻箱倒柜, 还要在收拾回去, 而且, 性能也比较落后, 摆到桌子上也占地方.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;年前就把这个笔记本咸鱼出手了, 自己 DIY 了一个小型台式机, 放到桌子下面, 配合我去年买的显示器, 作为家中的常备电脑, 偶尔还能打打游戏.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是习惯了 macOS 下的开发体验, 很多操作习惯用命令行来做, 又很依赖 oh-my-zsh, 装一些开发工具也方便. 在 window 下没有了熟悉的命令行怎么办.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_manjaro_deepin&quot;&gt;2. manjaro &amp;amp; deepin&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先想到的是装 linux 系统, 试用了比较流行的 manjaro 和 deepin, 开始感觉还不错, 但是要装一些沟通工具时, 总会出现这样那样的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这么多年来, 每次想要使用一个 linux 发行版来做开发环境, 最终的结果都是折腾两天然后删掉分区..&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_虚拟机&quot;&gt;3. 虚拟机&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;windows 上装 linux 虚拟机, 使用 windows 的沟通工具, 在 linux 下做开发, 体验不如原生, 且切换麻烦, 有一点微妙的卡顿, 让我在虚拟机里下载 idea 做开发, 想想都卡. 数据交换也是问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_ubuntu_子系统&quot;&gt;4. ubuntu 子系统&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;试过种种之后, 了解到在 Windows 10 里, 有 Windows Subsystem for Linux（WSL）这一特性, 支持在 windows 下运行 bash, 来操作一个 linux 系统.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_安装&quot;&gt;4.1. 安装&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;windows 10 商店中搜索 linux, 可以看到很多个 linux 发行版, 像 ubuntu, suse 等. 选择最熟悉的 ubuntu 安装.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 menu:控制面板[程序 &amp;gt; 启用或关闭 windows 功能 ] 中, 勾选 &lt;code&gt;适用于linux 的 windows 子系统&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_使用&quot;&gt;4.2. 使用&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;win + R&lt;/code&gt; 打开运行, 输入 &lt;code&gt;bash&lt;/code&gt; 或者 &lt;code&gt;wsl&lt;/code&gt; 或者 &lt;code&gt;ubuntu&lt;/code&gt;, 就进入了 linux 命令行.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以通过 &lt;code&gt;/mnt/&amp;lt;盘号&amp;gt;/&lt;/code&gt; 来访问 windows 的目录.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;span class=&quot;line-through&quot;&gt;在 window 下, 可以使用 &lt;a href=&quot;http://cmder.net/&quot;&gt;cmder&lt;/a&gt; 来改善终端.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在windows下, 可以使用 &lt;a href=&quot;https://github.com/eugeny/terminus&quot;&gt;terminus&lt;/a&gt; 来改善终端.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上图:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/img/tools/linux-in-windows/screen.png&quot; alt=&quot;screen&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>groovy技巧 for java 开发者</title>
      <link>http://blog.yangxiaochen.com/blog/groovy/groovy-tips-for-javaer.html</link>
      <pubDate>星期六, 5 五月 2018 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/groovy/groovy-tips-for-javaer.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_语法格式&quot;&gt;语法,格式&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_基础&quot;&gt;基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_对象&quot;&gt;对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_方法调用&quot;&gt;方法调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_null_check&quot;&gt;null check&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_字符串&quot;&gt;字符串&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_引号&quot;&gt;引号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_list&quot;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_map&quot;&gt;map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_流式操作&quot;&gt;流式操作&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_each_遍历&quot;&gt;each 遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_grep_过滤&quot;&gt;grep 过滤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_collect_转换&quot;&gt;collect 转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_groupby_列表转_map&quot;&gt;groupBy 列表转 map&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_io&quot;&gt;io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_命令行_command&quot;&gt;命令行 command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_更多&quot;&gt;更多&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文旨在对有 java 基础的程序员在几分钟内了解 groovy 不同于 groovy 的技巧, 方便快速使用到 groovy 带来的便捷.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_语法格式&quot;&gt;语法,格式&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_基础&quot;&gt;基础&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每句语法后不需要分号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;兼容绝大多数 java 语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非强类型语言, 使用推导类型, 可以使用 &lt;code&gt;def&lt;/code&gt; 来定义变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_对象&quot;&gt;对象&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;class Person {
    String name
    final int age
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;属性和对象默认为 public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性会自动生成 getter 和 setter.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;调用 &lt;code&gt;person.name&lt;/code&gt; 等同于调用 &lt;code&gt;person.getName()&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;final 只有 get 方法.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用带参数名的构造方法&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def person = new Person(name: &quot;John&quot;, age: 18)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_方法调用&quot;&gt;方法调用&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;方法调用可以不写括号, 下面两句是一样的&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;println(&quot;haha&quot;)
println &quot;haha&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_null_check&quot;&gt;null check&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;person.name ?: &apos;default name&apos;

person.school?.name ?: &apos;null school or null name&apos;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_字符串&quot;&gt;字符串&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 中字符串字面量有两种:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def s1 = &quot;world&quot;
def s2 = &quot;hello $s1&quot;

assert s2 == &quot;hello world&quot; // true&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;s1 是 String 类型, s2 是 GString 类型, 因为 s2 中有 &lt;code&gt;$&lt;/code&gt; 形式的插入值&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;觉大多数情况下, 可以忽略两种类型的差异.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 中字符串可以通过 &lt;code&gt;==&lt;/code&gt; 来判断字符串相等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_引号&quot;&gt;引号&lt;/h4&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单引号 &lt;code&gt;&apos;&lt;/code&gt; 的字符串, 就是纯字符串 &lt;code&gt;java.lang.String&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双引号 &lt;code&gt;&quot;&lt;/code&gt; 的字符串, 可以有插入值, 如 &lt;code&gt;assert &quot;hello $1&quot; == &quot;hello world&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三引号 &lt;code&gt;&apos;&apos;&apos;&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, 是多行形式, 比如&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def s1 = &quot;&quot;&quot;hello
world&quot;&quot;&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_list&quot;&gt;list&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 提供了方便的 list 定义方式, 这个方式的 list 默认是 ArrayList 形式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;// 定义 list
def letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]

assert letters[0] == &apos;a&apos;
assert letters[1] == &apos;b&apos;

assert letters[-1] == &apos;d&apos;
assert letters[-2] == &apos;c&apos;

letters[2] = &apos;C&apos;
assert letters[2] == &apos;C&apos;

// 添加一个元素
letters &amp;lt;&amp;lt; &apos;e&apos;
assert letters[ 4] == &apos;e&apos;
assert letters[-1] == &apos;e&apos;

// 根据下标取子集
assert letters[1, 3] == [&apos;b&apos;, &apos;d&apos;]
// 根据范围去子集
assert letters[2..4] == [&apos;C&apos;, &apos;d&apos;, &apos;e&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_map&quot;&gt;map&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;groovy 提供了方便的 map 定义方式, 这个方式的 map 默认是 LinkedHashMap 形式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def colors = [red: &apos;#FF0000&apos;, green: &apos;#00FF00&apos;, blue: &apos;#0000FF&apos;]

assert colors[&apos;red&apos;] == &apos;#FF0000&apos;
assert colors.green  == &apos;#00FF00&apos;

colors[&apos;pink&apos;] = &apos;#FF00FF&apos;
colors.yellow  = &apos;#FFFF00&apos;

assert colors.pink == &apos;#FF00FF&apos;
assert colors[&apos;yellow&apos;] == &apos;#FFFF00&apos;

assert colors instanceof java.util.LinkedHashMap&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_流式操作&quot;&gt;流式操作&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;java8 的 stream 操作带来很多便利, groovy 除了能使用 java8 的 stream 外, 还有自己的一套更为方便的流式操作&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_each_遍历&quot;&gt;each 遍历&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].each { it -&amp;gt;
    println &quot;$it&quot;
}
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].eachWithIndex { it, i -&amp;gt;
    println &quot;$i: $it&quot;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_grep_过滤&quot;&gt;grep 过滤&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def list = [1, 2, 3, 4, 5]
assert list.grep {it &amp;gt; 3} == [4, 5]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_collect_转换&quot;&gt;collect 转换&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;def list = [1, 2, 3, 4, 5]
assert list.collect { (it * 2) as String } == [&quot;2&quot;, &quot;4&quot;, &quot;6&quot;, &quot;8&quot;, &quot;10&quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_groupby_列表转_map&quot;&gt;groupBy 列表转 map&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;assert [
        [name: &apos;Clark&apos;, city: &apos;London&apos;], [name: &apos;Sharma&apos;, city: &apos;London&apos;],
        [name: &apos;Maradona&apos;, city: &apos;LA&apos;], [name: &apos;Zhang&apos;, city: &apos;HK&apos;],
        [name: &apos;Ali&apos;, city: &apos;HK&apos;], [name: &apos;Liu&apos;, city: &apos;HK&apos;],
].groupBy { it.city } == [
        London: [[name: &apos;Clark&apos;, city: &apos;London&apos;],
                 [name: &apos;Sharma&apos;, city: &apos;London&apos;]],
        LA    : [[name: &apos;Maradona&apos;, city: &apos;LA&apos;]],
        HK    : [[name: &apos;Zhang&apos;, city: &apos;HK&apos;],
                 [name: &apos;Ali&apos;, city: &apos;HK&apos;],
                 [name: &apos;Liu&apos;, city: &apos;HK&apos;]],
]

// 对于常见的把一个列表建立 id 索引
assert [
        [id: 1, name: &apos;Clark&apos;, city: &apos;London&apos;], [id: 2, name: &apos;Sharma&apos;, city: &apos;London&apos;],
        [id: 3, name: &apos;Maradona&apos;, city: &apos;LA&apos;]
].groupBy { it.id }.collectEntries { key, value -&amp;gt; [key, value.first] } == [
        1: [id: 1, name: &apos;Clark&apos;, city: &apos;London&apos;],
        2: [id: 2, name: &apos;Sharma&apos;, city: &apos;London&apos;],
        3: [id: 3, name: &apos;Maradona&apos;, city: &apos;LA&apos;]
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_io&quot;&gt;io&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;new File(&quot;a.txt&quot;).eachLine { line -&amp;gt;
    println line
}

def out = new File(&quot;out.txt&quot;)
out &amp;lt;&amp;lt; &quot;hello world\n&quot;
out &amp;lt;&amp;lt; &quot;something&quot;


File data = new File(fileName)
data.newReader(&quot;GBK&quot;).lines().skip(1).each { line -&amp;gt;
    out &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &quot;\n&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_命令行_command&quot;&gt;命令行 command&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看例子&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;if(args.size() &amp;lt; 1 ) {
    println &quot;need pid&quot;
    return
}
def pid = args[0]

def sout = new StringBuilder(), serr = new StringBuilder()
def proc = &quot;top -b -n 1 -H -p ${pid}&quot;.execute()

proc.consumeProcessOutput(sout, serr)
proc.waitFor()

def begin = false
def countLimit = 10
def count = 0
sout.eachLine { line -&amp;gt;
    if (line.trim().size() == 0) {
        return
    }
    if (begin &amp;amp;&amp;amp; count &amp;lt;= countLimit) {
        println line
        def row = line.trim().split(&quot; +&quot;)
        def tid = String.format(&quot;nid=0x%x&quot;, row[0].toInteger())
        println tid

        def sout1 = new StringBuilder(), serr1 = new StringBuilder()
        def p1 =  (System.getenv(&quot;JAVA_HOME&quot;)+&quot;/bin/jstack -l ${pid} &quot;).execute() | [&quot;grep&quot;, tid ,&quot;-A 20&quot;].execute()
        p1.consumeProcessOutput(sout1, serr1)
        p1.waitFor()

        serr1.eachLine { println it }
        def lines = sout1.readLines()

        if (lines.size() &amp;gt; 0) {
            println lines[0]
            lines[1..-1].takeWhile { !it.startsWith(&quot;\&quot;&quot;) }.each { println it }
        }

        println()
        count++
    }
    if (!begin &amp;amp;&amp;amp; line.trim().toUpperCase().startsWith(&quot;PID&quot;)) {
        begin = true
    }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_更多&quot;&gt;更多&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;参考实例: &lt;a href=&quot;http://www.groovy-lang.org/groovy-dev-kit.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/groovy-dev-kit.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;db 操作: &lt;a href=&quot;http://www.groovy-lang.org/databases.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/databases.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;json 操作: &lt;a href=&quot;http://www.groovy-lang.org/json.html&quot; class=&quot;bare&quot;&gt;http://www.groovy-lang.org/json.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>spring 中 aspectj 扫描内容太多导致的启动时加载缓慢</title>
      <link>http://blog.yangxiaochen.com/blog/stackoverflow/spring-aspectj-slow.html</link>
      <pubDate>星期四, 3 五月 2018 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/stackoverflow/spring-aspectj-slow.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_现象&quot;&gt;现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_发现问题&quot;&gt;发现问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_解决&quot;&gt;解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_现象&quot;&gt;现象&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我在一个现有的项目中, 引入 jooq. 这个项目本身是使用的 mybatis, 我引入 jooq, 想并行使用, 之后逐渐替换.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;引入 jooq 之后, 启动过程中发现中间停顿了 2-3 分钟. 也没有日志输出.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_发现问题&quot;&gt;发现问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;dump 出主线程的堆栈, 一直是 aspectj 的代码块, 在判断一个 target 是否需要被进行切面代理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;debug 模式启动, 到这个位置时, 在上面 dump 堆栈显示过的位置打断点.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;发现是一个表达式为&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;的 PointCut 在检测 &lt;code&gt;DefaultDSLContext`&lt;/code&gt; 类中的每一个方法是否需要进行切面代理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 &lt;code&gt;DefaultDSLContext&lt;/code&gt; 是 jooq 的入口类, 为了方便我们使用 jooq, 这个类里有大量的方法重载和泛型, 为了支持 jooq 的 22 度强类型, 方法都有 1 - 22 个参数.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以对每一个方法匹配时, 都要获取方法签名, 每一个方法的参数列表类型, 如果是泛型, 还有额外操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_解决&quot;&gt;解决&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过 spring aspectj 部分的文档和源码, 总结有以下结论:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;切面与代码的匹配是一个非常耗时的工作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配的表达式越精确约好.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如何做呢, spring aspectj 的文档给出了一些建议:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一般来说, 切面声明有以下集中类型&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;Kinded designators, 比如 execution, get, set, call, handler. 特定类型代码的切面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scoping designators, 比如 within, withincode. 一组切面, 包含了多种类型的代码, 但是有一个范围.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contextual designators, 比如 this, target, @annotation. 可能需要切面的上下文来帮助进行匹配检测.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;单独使用 Kinded designators 或者 Contextual designators 都是可以完成功能的, 但可能会影响织入性能, 因为要做额外的处理和分析.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Scoping designators 可以非常快的判断目标是否在范围内, 避免不必要的分析处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以通常写切面定义时, 最好加上 Scoping designators.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后, 我把切面定义修改为:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;within(com.lianjia.xxx.platform..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;结果界面无效, 因为我要切的目标是 mybatis 的 mapper, 因为这个 mapper 实际上是 com.sun.proxy.Proxy 对象. 最终改成&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;within(com.sun.proxy..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;@Pointcut(&quot;!within(org.jooq.impl..*) &amp;amp;&amp;amp; execution(* com.lianjia.xxx.platform.*.dao..*.*(..))&quot; )&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;spring 启动是到织如阶段时, 对 DefaultDSLContext 的实例进行判断织如时, 可以通过 fastMatch 直接判断不行, 就不用对方法逐个检查了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最终结果启动耗时减少了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_后记&quot;&gt;后记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其实 &lt;code&gt;execution(* com.lianjia.xxx.platform.&lt;strong&gt;.dao..&lt;/strong&gt;.*(..))&lt;/code&gt; 应该也是可以分析出范围的, 还没有细究是出于什么考虑没有做判断.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家可以对现有项目中的切面进行优化, 尝试减少启动时间.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;aop 是个好东西, 但是也带来复杂性, 可读性, 性能上的隐患. 严格一点来说, 要刨根问底, 保证项目的配置启动过程是完全掌控在手的, 避免黑盒(即不知道为啥, 反正这么配就能 run 起来了, 没有啥问题出现)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;代理对象和正常对象的切入方式会有不同, 需要注意.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>2018 北京 qcon 大会笔记</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/2018-beijing-qcon.html</link>
      <pubDate>星期二, 24 四月 2018 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/2018-beijing-qcon.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第一场_阿里巴巴微服务技术实践&quot;&gt;第一场: 阿里巴巴微服务技术实践&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_历史背景&quot;&gt;历史背景&lt;/a&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_all_in_one&quot;&gt;all in one&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_code_share&quot;&gt;code share&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_api&quot;&gt;api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_问题&quot;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_出现&quot;&gt;&quot;Pandora&quot; 出现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_问题&quot;&gt;&quot;Pandora&quot; 问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_pandora_boot_来解决上面的问题&quot;&gt;&quot;pandora boot&quot; 来解决上面的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_其他内容&quot;&gt;其他内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第二场_51信用卡在微服务架构下的监控平台架构实践&quot;&gt;第二场: 51信用卡在微服务架构下的监控平台架构实践&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第三场_京东阿基米德微服务平台&quot;&gt;第三场: 京东阿基米德微服务平台&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_jsf&quot;&gt;JSF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_containermesh&quot;&gt;ContainerMesh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_调用图谱&quot;&gt;调用图谱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_应用集市&quot;&gt;应用集市&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_能力地图&quot;&gt;能力地图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结_2&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_第四场_saga分布式事务解决方案与实践&quot;&gt;第四场: Saga分布式事务解决方案与实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_end&quot;&gt;end&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;4月22日下午去听了半天的 Qcon 软件开发大会分享. 主要是服务化探索的内容.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第一场_阿里巴巴微服务技术实践&quot;&gt;第一场: 阿里巴巴微服务技术实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一场虽然名字是&quot;阿里巴巴微服务实践&quot;, 但主要讲的是一个名为 &quot;Pandora&quot; 的服务隔离框架, 和为了这个框架能够方便使用的 &quot;Pandora boot&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_历史背景&quot;&gt;历史背景&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;服务化在阿里的过程:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_all_in_one&quot;&gt;all in one&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最早很自然都是 all in one, 一个大的系统所有功能都在一个项目里.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_code_share&quot;&gt;code share&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后在09-12年, 做项目拆分, 但是是通过代码共享, 即业务功能写完后, 发布成 jar 包, 供几个项目引用.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里我不得不吐槽, 我在15年也是这么做的, 现在接手的新项目也是这么做的. 显然是很不爽的, 因为修改一个业务逻辑, 就要生成新的 jar 包发布出去, 然后凡是依赖这个 jar 包的应用都要进行更新.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;反过来说, 当你在关注一个应用时, 需要修改它的逻辑, 发现逻辑放在底层的 jar 包里, 需要另开一个项目更改, 很烦.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我最初这么做的想法, 无非是想避免同样的逻辑在不同的系统里写多次, 尤其是数据存取的那些逻辑, 毕竟在 java 里写 pojo mapper 很繁琐, 不能没个项目里都维护一份.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;现在看来, 这种写法非常教条化. 在工作中也遇到有的同学严格照搬分层标准, 对同一个实体封装的 po, vo, dto, 对一个实体的不同纬度的的查询, 就一定要在一个包里, 哪怕这个查询就是为了某一个应用而写的特殊查询, 也要写在公共的包里. 我感觉这很教条, 不灵活, 忽视了功能和业务的聚集, 而仅仅考虑它们是描述同一实体的代码.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_api&quot;&gt;api&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;12年到15, 16年. 就向每个系统代码相互独立, 系统间通过 api 进行交互.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这也就是我们现在通常所认为的微服务.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_问题&quot;&gt;问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在以上服务化演进过程中, 就产生了一些中间件来支持每个应用. 比如 HSF中间件, 消息中间件, tddl, tair, ons 等阿里内部的中间件系统.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样业务系统就会因为这些中间件的 client 端或者 sdk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;产生了一下问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中间件统一运维, 统一更新, 要求业务方应用更新 client 和 sdk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间件 client 或 sdk 的依赖与业务方应用所需要的依赖冲突.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如某个中间件 client 用到 netty 是 4.0.* , 而业务方应用的功能需要依赖 netty 4.1.*&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同中间件之间的所需依赖冲突&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_出现&quot;&gt;&quot;Pandora&quot; 出现&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;Pandora&quot; 就是这种背景产生下的隔离容器.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是基于 java 的 classloader 体系, 通过在 tomcat 等容器上配置自定义的 pandora classloader, 实现加载不同的中间件及其依赖的 class 时, 到不同的目录来查找.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在业务应用部署时, 一个包含了所有中间件依赖的 &quot;Pandora&quot; 目录会部署在项目目录下.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_问题&quot;&gt;&quot;Pandora&quot; 问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;想一下, 就是知道这一套东西用起来很麻烦:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地开发需要引入这样一堆组件.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加特殊的虚拟机参数, 容器配置.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不引用这个 &quot;pandora&quot; 组件, 则需要自己用 maven 添加中间件所需依赖. 等到上线时才发现自己使用的依赖跟 &quot;pandora&quot; 里的依赖版本不一致造成运行时错误.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用创建麻烦, 找兄弟项目拷贝.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中第四点我们也有同样的问题. 新建项目就是拷贝代码, 一些不好的结构, 过期的依赖, 不合理的配置都会迁移过来&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_pandora_boot_来解决上面的问题&quot;&gt;&quot;pandora boot&quot; 来解决上面的问题&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解决项目新建问题:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有一个类似于 &lt;a href=&quot;http://start.spring.io&quot; class=&quot;bare&quot;&gt;http://start.spring.io&lt;/a&gt; 的一站式应用创建页面. 勾选后直接下载一个完整的初始项目压缩包&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决开发依赖的问题:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;pandora&quot; 发布 middleware-sdk包, 包含了所有中间件的依赖, 但全都移除了方法体和实现, 只保留 class 和方法签名, 非常小, 供开发时的编译使用.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决本地开发运行:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;项目引入&quot;pandora boot&quot;, 所有项目第一句, &lt;code&gt;PandoraBootstrap.run(args)&lt;/code&gt;, 这也是收 springboot 启发, 在打包后, pandora-boot 会启动自己的 pandoraboot classloader 来管理类的加载, 实现不同中间件类加载的依赖隔离.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决中间件 sdk 的插件化:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;利用 spring-boot 的 starter 的方式, 引入不同的中间件依赖. 纳入 pandora-boot 的管理.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这几个事情听上去比较简单做起来还是挺复杂的! 就拿 pandora boot 这个自定义类加载来说, 既要考虑打成 jar 包之后的类加载方式和路径, 又要考虑开发时直接从 main 函数启动的类加载方式和路径.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_其他内容&quot;&gt;其他内容&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;演讲者也简单介绍一下他们的微服务中心, 主要是中间件, 容器管控, 监控, 提供一些应用管理能力. 介绍不多.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第二场_51信用卡在微服务架构下的监控平台架构实践&quot;&gt;第二场: 51信用卡在微服务架构下的监控平台架构实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个分享主要就是讲微服务监控, 分享者是51信用卡微服务监控平台的负责人.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个涉及业务比较少, 主要讲的是监控技术.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;微服务监控主要是: 日志监控, 链路监控, 指标监控.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;他们的监控平台通过拉业务日志, 又接受 push 事件的方式获取需要监控的内容, 使用的是一个 prometheus 的指标统计框架&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是由于微服务之后, 相互调用的日志和事件变多了, 又是金融项目, 要求记录详细, 机器扛不住了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以他们做了平台化:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&quot;拉取&quot; 和 &quot;推送&quot; 分别建立了不同的服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把获取到的监控内容发到转换服务器处理成 prometheus 支持的格式, 根据应用存到不同的存储实例上.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之后又做些优化点:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将时序型数据(用来做指标, 统计的那种, 比如一次 pv 打点) 和 非时序型数据(用来查看的, 比如日志) 分别用 Cassandra 和 es 存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标的 key 长度占用空间: 使用 bitmap 做枚举, 减小单个指标长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 druid 来解决预聚合, 维度合并, 减少指标数量.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后还讲到了智能诊断:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当报警发生时, 会取报警前后日志, 尤其会去查找 ERROR, Exception 关键字.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有链路日志, 还会进行排序, 方便查看.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个监控的介绍打开了一些眼界, 毕竟作为业务开发者, 对监控这方面了解并不多. 这里列举的坑和解决办法可以在以后工作中提前考虑到.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第三场_京东阿基米德微服务平台&quot;&gt;第三场: 京东阿基米德微服务平台&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;阿基米德是京东一系列服务化支持框架的总称. 这次分享介绍了京东内部为了支持微服务所示用的各种框架和技术.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jsf&quot;&gt;JSF&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东服务框架, 微服务基础, 负责服务发现和注册, rpc 调用, 类似于 dubbo, 同时能够做到异地多活.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_containermesh&quot;&gt;ContainerMesh&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之前听过 ServiceMesh, 说是微服务的未来. 简略了解是提供一个微服务的容器, 具有检测死活, 流量控制, 注册与发现等功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总之, 是不需要每个服务自身再去关心去哪里注册和发现服务, 调用权限, 熔断, 监控等, 只需要做好你的服务放进来.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;极大的简化了服务部署的成本, 每个服务只需关心自己要发布什么功能, 要调用哪些功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东这个也是这个思路, 基于 google 的 Istio 开发. 包含在了自定义 linux 镜像里.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个仅仅是了解, 没有实践过, 这个算是服务化运维的范畴. 所以服务化不只是开发人员的工作, 更是运维人员的工作.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们其实也可以试试成熟的云平台上的容器服务. 公司也确实需要统一微服务的基础设施.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_调用图谱&quot;&gt;调用图谱&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;微服务统一基础设施后, 收集到的日志, 指标都可以统一处理, 形成调用图谱, 包含调用关系, 流量统计, 耗时等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如同玲姐的 dkimi 的效果.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_应用集市&quot;&gt;应用集市&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是我认为的亮点之一: 把大家的服务的信息集中起来, 分门别类. 一个服务是什么, 有哪些功能, 开发团队, 版本迭代都集中在应用集市上. 形成了公司内信息共享.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;同时, 一个功能可能有多个应用提供, 大家在选择的时候就能比较, 还可以反馈, 点赞, 评价.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不好用的服务, 不好的服务态度, 都会导致你的服务被淘汰. 而优秀的会在各方评价建议中不断进化.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个想法非常亮, 他们也在开发中, 说是五月要上线. 不知道推广起来怎么样.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_能力地图&quot;&gt;能力地图&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这又是个亮点! 看图:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/img/2018-beijing-qcon/能力地图.png&quot; alt=&quot;能力地图&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过微服务细分, 微服务添加自己的业务标签, 结合调用图谱, 就能形成可视的业务描述.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如下一个订单, 会经过那些功能模块的处理.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能让开发人员更直观熟悉项目, 也能让非开发人员(产品, 测试)对项目有所了解, 方便沟通, 价值很大!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结_2&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;京东这一套东西很实用, 想法也非常好. 他们是基础架构部一个专门的服务化治理组来做这些事情, 具体规模不太清楚.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_第四场_saga分布式事务解决方案与实践&quot;&gt;第四场: Saga分布式事务解决方案与实践&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一场是一个实际技术应用的分享. 讲了一个使用 saga 方式解决分布式事务的库 ServiceComb. 演讲者是这个库的发起人, 目前已经维护到 apache 了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;分布式事务场景下, saga 其实是一个很容易想到的方案: 使用事件来触发业务逻辑执行, 再某一步出错后, 倒序向前执行 undo 事件. 通过最终一致性来保障事务.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但目前的问题是, 没有一个公认的, 成熟的 saga 实现. 反正我接触的都没用过, 大家都是自己写异步事件通知, 保证幂等, 加入补偿.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;他们就是想做这个事. 项目也是在开发中.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;说几点提到的比较有价值的地方:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务外柔内刚.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;意思是一个实例内部, 通过数据库保证刚性事务; 实例之间, 通过最终一致性保障柔性事务. 深以为然, 其实我们做的时候也是这么做的.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要期望框架能够做回滚操作&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这是 saga 最长被挑战的部分, 有人就问了, 我用你这个框架, 出了错数据能够自动回滚吗. 这显然是想多了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;补偿操作, undo 操作, 都是要自己写.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以认为是你如果对一个 saga 事件要写一段业务逻辑, 就要同时把补偿和回滚的逻辑写了. 这个其实挺难得, 要考虑的很全面.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决隔离性的问题&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如分布式条件下对订单的操作, 要对订单加分布式锁, 来让对同一个订单的操作隔离.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个业务操作伴随一组 saga 事件&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如下单, 就有生成订单, 扣减库存等一些列事件. 这些事件看成是一个事务, 而不是互相独立, 需要统一saga协调器管理:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;saga start &amp;#8594; order create &amp;#8594; inventory 扣减 &amp;#8594; saga end&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐了论文:&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aphyr/dist-sagas/blob/master/sagas.pdf&quot;&gt;Distributed Sagas - Caitie McCaffrey&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://microservices.io/patterns/data/saga.html&quot;&gt;Microservice saga pattern - Chris Richardson&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_end&quot;&gt;end&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上是半天的收获, 其实也关注了点 团队建设与工程师个人成长 分会场的 ppt, 感觉也很不错, 以后再说吧.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>pac4j 简介</title>
      <link>http://blog.yangxiaochen.com/blog/java/pac4j-introduction.html</link>
      <pubDate>星期日, 15 四月 2018 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/pac4j-introduction.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_什么是_pac4j&quot;&gt;什么是 pac4j&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_重要组件和概念&quot;&gt;重要组件和概念&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_client&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_authenticator&quot;&gt;&lt;strong&gt;authenticator&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_authorizer&quot;&gt;&lt;strong&gt;authorizer&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_matcher&quot;&gt;&lt;strong&gt;matcher&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_config&quot;&gt;&lt;strong&gt;config&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_user_profile&quot;&gt;&lt;strong&gt;user profile&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_web_context&quot;&gt;&lt;strong&gt;web context&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_security_filter&quot;&gt;&lt;strong&gt;security filter&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_callback_controller&quot;&gt;&lt;strong&gt;callback controller&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_logout_controller&quot;&gt;&lt;strong&gt;logout controller&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_流程&quot;&gt;流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_例子&quot;&gt;例子&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_spring_mvc_使用_pac4j_cas_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 进行登录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_spring_mvc_使用_pac4j_cas_和_buji_pac4jpac4j_for_shiro_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 和 buji-pac4j(pac4j for shiro) 进行登录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_什么是_pac4j&quot;&gt;什么是 pac4j&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;pac4j 是一个 java 的安全引擎.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在一套标准的 interface 下,&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;提供了很多种&lt;strong&gt;认证机制&lt;/strong&gt;: form 表单登录, JWS, cas, OAuth 等等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了很多收&lt;strong&gt;授权和权限检查机制&lt;/strong&gt;: role/permissions, CORS, CSRF, HTTP Security headers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了&lt;strong&gt;跟很多框架的集成方式&lt;/strong&gt;: springboot, play, shiro, spring security&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这些认证方式都是可插拔的, 你可以同时使用其中的一种或几种.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如, 最常见的情况, 就是我们用 spring boot + cas 单点登录 + role/permissions&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_重要组件和概念&quot;&gt;重要组件和概念&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_client&quot;&gt;&lt;strong&gt;client&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;引入不同的认证包会包含不同的 Client 类, 每一种 Client 类就代表一种登录和认证方式. 比如:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 pac4j-cas, 里面就是 CasClient&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_authenticator&quot;&gt;&lt;strong&gt;authenticator&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Authenticator 是 client 的一个组件, 用来 validate credentials, 并且用来创建 user profile.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_authorizer&quot;&gt;&lt;strong&gt;authorizer&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是用来检测 user profiles 是否能够通过授权. pac4j 内置了很多 authorizer:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;StrictTransportSecurityHeader
XContentTypeOptionsHeader
XFrameOptionsHeader
XSSProtectionHeader
CacheControlHeader
CsrfAuthorizer
CsrfTokenGeneratorAuthorizer
CorsAuthorizer
IsAnonymousAuthorizer
IsAuthenticatedAuthorizer
IsFullyAuthenticatedAuthorizer
IsRememberedAuthorizer&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们也可以自己实现, 添加到 config 中的 authorizerMap&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_matcher&quot;&gt;&lt;strong&gt;matcher&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;matcher 通常用来判断一个请求, 是否要经过登录或认证.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;开发者可以在 config 中定义很多 matcher, 并定义每个请求路径要经过哪些 matcher.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果一个请求经过所有 matcher 判断结果都为 true, 那么才能进行认证检测&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果为 false, 则直接授权访问&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_config&quot;&gt;&lt;strong&gt;config&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;config 配置了要用到的 clients, authorizers, matchers&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_user_profile&quot;&gt;&lt;strong&gt;user profile&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;代表一个认证后的用户, 包括 id, 属性, 角色, 权限等.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_web_context&quot;&gt;&lt;strong&gt;web context&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;是对一个请求的抽象, 包含了 request, response, session, 还有 pac4j 提供的其他的来辅助描述这次请求的数据.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_security_filter&quot;&gt;&lt;strong&gt;security filter&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;security filter 或者其他拦截 http 请求的机制. 根据 client 的不同来进行认证检查, 授权检查, 从而保护一个 url 地址.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果是没有认证的用户, 则尝试登录操作&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_callback_controller&quot;&gt;&lt;strong&gt;callback controller&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对与 &quot;间接 client&quot; indirect client, 比如需要在一个特殊页面进行登录, 而不是每个请求直接携带认证信息的 client.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在完成登录操作后需要调用 callback controller 最终完成登录操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_logout_controller&quot;&gt;&lt;strong&gt;logout controller&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行登出操作&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_流程&quot;&gt;流程&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常是一个请求过来, 访问一个 url A, 如果 A 需要被保护, 那么开发人员会设置需要先经过 &quot;security filter&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果 &quot;security filter&quot; 能从 &quot;web context&quot; 里获取到 &quot;user profile&quot;, 且 &quot;user profile&quot; 是登录状态, 那么通过认证, 允许访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果没有 &quot;user profile&quot;, 那么从 config 中获取改应用所支持的登录方式, 即配置的各种 clients.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先用 direct clients 来判断能否登录, 如果此时 http context 里包含了这类 client 所需要的登录信息, 比如 token, 则能够被授权成功访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果不行, 进行 indirect client 的登录方式, 跳转的特定的登录页.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在特定的登录页登录成功后, 回跳转回 &quot;callback controller&quot; 进行最后的登录操作, 即获取 &quot;user profile&quot; 并保存.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当退出是, 访问 &quot;logout controller&quot;, 执行退出.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_例子&quot;&gt;例子&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_spring_mvc_使用_pac4j_cas_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 进行登录&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_spring_mvc_使用_pac4j_cas_和_buji_pac4jpac4j_for_shiro_进行登录&quot;&gt;spring mvc 使用 pac4j-cas 和 buji-pac4j(pac4j for shiro) 进行登录&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;ShiroCasProperties&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;cas.shiro.login-url: http://passport.xxx.com:8088/cas/login
cas.shiro.callback-url: /callback
cas:
  shiro:
    filter-chain-definition-map:
      /page1: securityFilter
      /callback: callbackFilter
      /logout: logout&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;config 配置:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public Config config() {
    final CasConfiguration configuration = new CasConfiguration(shiroCasProperties.getLoginUrl());
    final CasClient casClient = new CasClient(configuration);
    casClient.setUrlResolver(new RelativeUrlResolver());
    final Clients clients = new Clients(shiroCasProperties.getCallbackUrl(), casClient);
    final Config config = new Config(clients);
    config.setSessionStore(new J2ESessionStore());
    return config;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;shiroFilter 配置:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Bean
public ShiroFilterFactoryBean shiroFilterFactoryBean() {

    final Config config = config();


    ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
    securityManager.setRealm(new Pac4jRealm());
    shiroFilter.setSecurityManager(securityManager);
    shiroFilter.setFilterChainDefinitionMap(shiroCasProperties.getFilterChainDefinitionMap());
    shiroFilter.setFilters(new LinkedHashMap&amp;lt;String, Filter&amp;gt;() {{
        CallbackFilter callbackFilter = new CallbackFilter();
        callbackFilter.setConfig(config);
        put(&quot;callbackFilter&quot;, callbackFilter);
        SecurityFilter securityFilter = new SecurityFilter();
        securityFilter.setConfig(config);
        securityFilter.setClients(&quot;CasClient&quot;);
        put(&quot;securityFilter&quot;, securityFilter);
        LogoutFilter logoutFilter = new LogoutFilter();
        logoutFilter.setConfig(config);
        logoutFilter.setCentralLogout(true);
        put(&quot;logout&quot;, logoutFilter);
    }});
    return shiroFilter;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;完整源码见: TODO&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>jooq 介绍</title>
      <link>http://blog.yangxiaochen.com/blog/db/jooq-intro.html</link>
      <pubDate>星期三, 4 四月 2018 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/db/jooq-intro.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_对比&quot;&gt;对比&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_jpa_hibernate&quot;&gt;jpa, hibernate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_mybatis&quot;&gt;mybatis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jdbc_template&quot;&gt;jdbc template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_我们的现状&quot;&gt;我们的现状&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jooq_是怎么做的&quot;&gt;JOOQ 是怎么做的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_使用方式&quot;&gt;使用方式&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_sql_builder_作为_sql_的构造器&quot;&gt;sql builder, 作为 sql 的构造器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_sql_executor_更进一步_作为_sql_执行器&quot;&gt;sql executor, 更进一步, 作为 sql 执行器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_typesafe_sql_builder_and_executor_作为强类型的_sql_构建和执行器&quot;&gt;typesafe sql builder and executor, 作为强类型的 sql 构建和执行器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_curd&quot;&gt;curd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_mapper&quot;&gt;mapper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_特性总结&quot;&gt;特性总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_缺点&quot;&gt;缺点&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_性能&quot;&gt;性能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_商业化&quot;&gt;商业化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_jdk_要求&quot;&gt;jdk 要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_学习成本&quot;&gt;学习成本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;几乎每一个 java 程序员都要跟数据库打交道. 最常用的就是通过 java 的 jdbc 来跟数据库进行交互操作.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 jdbc 本身比较底层, 写起来比较繁琐, 于是产生了很多数据库抽象层的框架或者工具. 比如 JPA, Hibernate, Mybatis 等等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;今天介绍的 JOOQ 也是这样一个框架.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_对比&quot;&gt;对比&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们拿出最常用的一些数据抽象层框架来做比较: jpa, hibernate, mybatis, jdbc template.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jpa_hibernate&quot;&gt;jpa, hibernate&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;善于 CURD&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于针对单一对象的基础增删改查, 支持很到位, 这也是他们的立身之本.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ORM 依赖重&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于复杂查询, 关联查询, 配置复杂, 依靠对象 mapping 不灵活&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐藏了 sql&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;sql是大家都很熟悉的, 通过 sql 我们能够很直观的评估语句的性能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而这个框架隐藏了 sql, 不能直观知道我们对数据库切实执行了什么操作.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jSQL, HQL&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两个自创的类SQL语法应对复杂查询, 但是增加了学习成本.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;综上所述, 你要想在项目中用好 jpa 和 hibernate, 你需要有一个熟悉这两种框架的专家.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;即使这样, 在应对复杂查询的时候依然非常蹩脚.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_mybatis&quot;&gt;mybatis&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;mybatis 在一定程度上解决了一些 jpa 和 heibernate 不善于复杂查询和连表查询的问题, 这也是 mybatis 现在被广泛使用的原因.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家都看重 mybatis 能够自主掌控 sql 的能力.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但同时, mybatis 也有自己的问题.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;xml 繁杂&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;xml 本身就是一种复杂的格式, 加之 mybatis 要定义 ResultMap, 动态 sql 等.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;改动时需要在代码跟 xml 间来回切换.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当一个字段改动时, 通常要 db &amp;#8594; model &amp;#8594; xml 改 sql &amp;#8594; xml 改 ResultMap 一套改一遍.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然可以codegen, 但复杂的不支持&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过代码生成插件可以解决上面那一些问题, 但是复杂的查询无法生成, 还需要自己写.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而且自己写的 sql 还不能在生成的 xml 和 dao 里, 不然重新生成时会有问题.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过注解定义查询&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看上去写起来也不简单, 我是没有试过.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jdbc_template&quot;&gt;jdbc template&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jdbc template 是 spring jdbc 提供的一个简单数据访问层框架, 以简单方便著称.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jdbcTempate 通过直接代码中写 sql, 然后定义 RowMapper 来将每一行的数据转化成需要的对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不保证 Typesafe&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写字符串形式的 sql, 需要人工保证字段名字都不写错.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 java 语言强类型的特性, 取出数据时需要指定类型.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RowMapper, dao 要自己实现, 重复工作多.&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为没有代码生成的机制, RowMapper, dao 需要自己实现, 那么通常来说, 有多少数据对象, 就要生成多少 RowMapper 和 dao&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_总结&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 java 是一个面向对象的语言, 所以很多框架都是用面向对象的方式来抽象数据访问.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然而, 借用 jooq 文档里的一句话:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SQL was never meant to be object-oriented. SQL was never meant to be anything other than&amp;#8230;&amp;#8203; SQL!&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;传统 ORM 解决的问题是 &lt;code&gt;程序中对象&lt;/code&gt; &amp;#8592;&amp;#8594; &lt;code&gt;数据库存储&lt;/code&gt; 的对应, 提供了一套面向对象的封装, 屏蔽了 jdbc 的复杂性.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 jdbc template 等非 orm 的框架提供了完全控制 sql 的能力但无法提供 ORM 提供的强类型映射, 需要开发人员大量的重复编码.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_我们的现状&quot;&gt;我们的现状&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在我们的项目中, 几乎无法避免要使用到关系型数据库, 无法避免要使用 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是, 我们对 sql 的使用可以分成两种类型:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;50% ~ 80% 的 CURD&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;基础的 CURD 是项目中最常见的使用方式, 增删改查一个实体.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们在写业务逻辑的时候, 就是获取各种实体数据, 然后通过计算更改数据, 再将数据保存.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;20% ~ 50% query&lt;/p&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果项目中只有 CURD, 那么生活将会非常美好. 然而项目中总是免不了需要复杂的 sql 来实现的功能.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如列表查询, 往往需求比较个性化, 一行的数据可能涉及多个数据表.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这种需求虽然现在可以通过冗余存储的方式来解决, 但通常还是用连表查询配合缓存来完成, 有时还会涉及到聚合查询, 可变条件等情况.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;传统 ORM 对于这种情况就会显得力不从心.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_jooq_是怎么做的&quot;&gt;JOOQ 是怎么做的&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 是要来解决上面问题的. JOOQ 通过大量的流式 API 来灵活构建一个 SQL. 下面通过 JOOQ 的几种使用方式来体验下 JOOQ 的特性:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_使用方式&quot;&gt;使用方式&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sql_builder_作为_sql_的构造器&quot;&gt;sql builder, 作为 sql 的构造器&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    String s = DSL.select(DSL.field(&quot;id&quot;), DSL.field(&quot;title&quot;), DSL.field(&quot;published_in&quot;))
            .from(&quot;book&quot;).getSQL();
    System.out.println(s);
}

{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .getSQL();
    System.out.println(s);
}

{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .where(DSL.field(&quot;book.author_id&quot;).eq(2))
            .and(&quot;published_in = 1990&quot;)
            .getSQL();
    System.out.println(s);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不需要数据源, 不需要代码生成, 使用 &lt;code&gt;org.jooq.impl.DSL&lt;/code&gt; 来构建 sql 语句, 来看一下输出结果:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-console&quot; data-lang=&quot;console&quot;&gt;select id, title, published_in from book
select * from book join language as `a` on (book.language_id = a.id)
select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过 jooq 的 api, 可以构建出满足我们需要的简单或复杂的 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_sql_executor_更进一步_作为_sql_执行器&quot;&gt;sql executor, 更进一步, 作为 sql 执行器&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jooq 构建 sql 之后, 可以作为 sql 的执行器来运行 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;首先, 利用数据源建立 DSLContext 对象, 下面需要执行的例子都会使用这个对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;DSLContext sql;

@Before
public void before() {
    MysqlDataSource mysqlDataSource = new MysqlDataSource();
    mysqlDataSource.setDatabaseName(&quot;jooq_test&quot;);
    mysqlDataSource.setUser(&quot;root&quot;);
    mysqlDataSource.setPassword(&quot;&quot;);
    sql = DSL.using(mysqlDataSource, SQLDialect.MYSQL);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行构建好的 sql 语句&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    String s = DSL.using(SQLDialect.MYSQL).select()
            .from(&quot;book&quot;)
            .join(DSL.table(&quot;language&quot;).as(&quot;a&quot;))
            .on(&quot;book.language_id = a.id&quot;)
            .where(DSL.field(&quot;book.author_id&quot;).eq(2))
            .and(&quot;published_in = 1990&quot;)
            .getSQL();
    sql.execute(s, 2);
    sql.resultQuery(s, 2).fetch();
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;11:44:36.067 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))
11:44:36.068 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = 2 and (published_in = 1990))
11:44:36.660 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = ? and (published_in = 1990))
11:44:36.660 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select * from book join language as `a` on (book.language_id = a.id) where (book.author_id = 2 and (published_in = 1990))
11:44:36.760 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+
11:44:36.760 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                          |published_in|language_id|new_field|  id|cd  |description|
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahaha|        1990|          2|        0|   2|de  |Deutsch    |
11:44:36.764 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------+------------+-----------+---------+----+----+-----------+&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以上是我们通过 jooq api 和自己拼写 sql 字符串的方式执行 sql.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_typesafe_sql_builder_and_executor_作为强类型的_sql_构建和执行器&quot;&gt;typesafe sql builder and executor, 作为强类型的 sql 构建和执行器&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这一步我们要借助 jooq 的 code generator 来生成数据库的描述文件.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;code generator 有 gradle 和 maven 的插件可以使用. 我是用的是 gradle 插件, 我的测试使用配置如下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-gradle&quot; data-lang=&quot;gradle&quot;&gt;plugins {
    id &apos;nu.studer.jooq&apos; version &apos;2.0.9&apos;
    id &apos;java&apos;
}

dependencies {

    jooqRuntime(&apos;mysql:mysql-connector-java:5.1.44&apos;)

    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;
    testCompile &apos;org.slf4j:slf4j-api:1.7.21&apos;
    testCompile &apos;ch.qos.logback:logback-core:1.2.3&apos;
    testCompile &apos;ch.qos.logback:logback-classic:1.2.3&apos;

    testCompile(&apos;org.jooq:jooq:3.10.6&apos;)
    testCompile(&apos;mysql:mysql-connector-java:5.1.44&apos;)
}

jooq {
    sample(sourceSets.main) {
        jdbc {
            driver = &apos;com.mysql.jdbc.Driver&apos;
            url = &apos;jdbc:mysql://localhost:3306/test&apos;
            user = &apos;root&apos;
            password = &apos;&apos;
        }
        generator {

            database {
                name = &apos;org.jooq.util.mysql.MySQLDatabase&apos;
                inputSchema = &apos;jooq_test&apos;
                outputSchemaToDefault = true

            }

            generate {
                relations = true
                deprecated = false
                records = true
                immutablePojos = true
                fluentSetters = true
                daos = true
                // ...
            }
            target {
                packageName = &apos;com.yangxiaochen.jooq&apos;
                // directory = ...
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-console&quot; data-lang=&quot;console&quot;&gt;./gradlew generateSampleJooqSchemaSource&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;生成代码.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;生成之后, 就可以使用了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{
    Result&amp;lt;Record3&amp;lt;Integer, Integer, String&amp;gt;&amp;gt; result = sql.select(BOOK.ID, BOOK.AUTHOR_ID, LANGUAGE.DESCRIPTION)
        .from(BOOK).join(LANGUAGE)
            .on(BOOK.LANGUAGE_ID.eq(LANGUAGE.ID))
            .where(BOOK.PUBLISHED_IN.eq(1990))
            .fetch();
    Integer id = result.get(0).getValue(BOOK.ID);
    Integer authorId = result.get(0).get(&quot;author_id&quot;, Integer.class);
    String desc = result.get(0).value3();
    System.out.println(id + &quot; &quot; + authorId + &quot; &quot; + desc);

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:06:40.515 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = ?
12:06:40.516 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = 1990
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------+
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|description|
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Deutsch    |
12:06:41.312 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
4 2 Deutsch&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以看到, jooq 通过生成数据库描述代码来保证强类型, 当数据库发生变动, 可以重新生成.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_curd&quot;&gt;curd&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 针对 CURD 生成基本代码, 来避免重复编码. JOOQ 对 CURD 的支持主要氛围 record 和 dao 两种方式, 可以一起使用:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;BookRecord bookRecord = sql.selectFrom(BOOK).where(BOOK.ID.eq(4)).fetchOne();
System.out.println(bookRecord);
bookRecord.setTitle(bookRecord.getTitle() + &quot;ha&quot;);
bookRecord.store();

BookRecord bookRecord1 = sql.newRecord(BOOK);
bookRecord1.setAuthorId(2);
bookRecord1.setLanguageId(1);
bookRecord1.setTitle(&quot;hello&quot;);
bookRecord1.setPublishedIn(2018);
bookRecord1.store();

System.out.println(bookRecord1);

BookDao bookDao = new BookDao(sql.configuration());
List&amp;lt;Book&amp;gt; books = bookDao.fetchByAuthorId(2);
System.out.println(books.get(0));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:18:55.420 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`id` = ?
12:18:55.422 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`id` = 4
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                              |published_in|language_id|new_field|
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahahahaha|        1990|          2|        0|
12:18:56.134 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------------------------------+------------+-----------+---------+
+----+---------+-----------------------------------+------------+-----------+---------+
|  id|author_id|title                              |published_in|language_id|new_field|
+----+---------+-----------------------------------+------------+-----------+---------+
|   4|        2|Bridahahahahahahahahahahahahahahaha|        1990|          2|        0|
+----+---------+-----------------------------------+------------+-----------+---------+
12:18:56.198 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : update `book` set `book`.`title` = ? where `book`.`id` = ?
12:18:56.199 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : update `book` set `book`.`title` = &apos;Bridahahahahahahahahahahahahahahahaha&apos; where `book`.`id` = 4
12:18:56.240 [main] DEBUG org.jooq.tools.LoggerListener - Affected row(s)          : 1
12:18:56.250 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : insert into `book` (`author_id`, `title`, `published_in`, `language_id`) values (?, ?, ?, ?)
12:18:56.250 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : insert into `book` (`author_id`, `title`, `published_in`, `language_id`) values (2, &apos;hello&apos;, 2018, 1)
12:18:56.268 [main] DEBUG org.jooq.tools.LoggerListener - Affected row(s)          : 1
12:18:56.270 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id` from `book` where `book`.`id` = ?
12:18:56.271 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id` from `book` where `book`.`id` = 19
12:18:56.291 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  19|
12:18:56.292 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+
+----+---------+-----+------------+-----------+---------+
|  id|author_id|title|published_in|language_id|new_field|
+----+---------+-----+------------+-----------+---------+
|  19|        2|hello|        2018|          1|   {null}|
+----+---------+-----+------------+-----------+---------+
12:18:56.305 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`author_id` in (?)
12:18:56.306 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `book`.`title`, `book`.`published_in`, `book`.`language_id`, `book`.`new_field` from `book` where `book`.`author_id` in (2)
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|title                                |published_in|language_id|new_field|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   3|        2|O Alquimista                         |        1988|          4|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Bridahahahahahahahahahahahahahahahaha|        1990|          2|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  10|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  11|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  12|        2|hello                                |        2018|          1|        0|
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-------------------------------------+------------+-----------+---------+
12:18:56.326 [main] DEBUG org.jooq.tools.LoggerListener -                          : |...7 record(s) truncated...
Book (3, 2, O Alquimista, 1988, 4, 0)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_mapper&quot;&gt;mapper&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 还提供了内置的映射功能, 方便我们进行对象的转换&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; public static class R {
    public Integer id;
    public Integer authorId;
    public String description;

    @Override
    public String toString() {
        return &quot;R{&quot; +
                &quot;id=&quot; + id +
                &quot;, authorId=&quot; + authorId +
                &quot;, description=&apos;&quot; + description + &apos;\&apos;&apos; +
                &apos;}&apos;;
    }
}

@Test
public void mapping() {

    List&amp;lt;R&amp;gt; r = sql.select(BOOK.ID, BOOK.AUTHOR_ID, LANGUAGE.DESCRIPTION)
            .from(BOOK).join(LANGUAGE)
            .on(BOOK.LANGUAGE_ID.eq(LANGUAGE.ID))
            .where(BOOK.PUBLISHED_IN.eq(1990)).fetch().into(R.class);

    r.forEach(it -&amp;gt; System.out.println(it));
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;12:23:00.964 [main] DEBUG org.jooq.tools.LoggerListener - Executing query          : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = ?
12:23:00.965 [main] DEBUG org.jooq.tools.LoggerListener - -&amp;gt; with bind values      : select `book`.`id`, `book`.`author_id`, `language`.`description` from `book` join `language` on `book`.`language_id` = `language`.`id` where `book`.`published_in` = 1990
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener - Fetched result           : +----+---------+-----------+
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener -                          : |  id|author_id|description|
12:23:01.862 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
12:23:01.863 [main] DEBUG org.jooq.tools.LoggerListener -                          : |   4|        2|Deutsch    |
12:23:01.863 [main] DEBUG org.jooq.tools.LoggerListener -                          : +----+---------+-----------+
R{id=4, authorId=2, description=&apos;Deutsch&apos;}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_特性总结&quot;&gt;特性总结&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 提供了方便流式 API 用于构建各种各样的 SQL&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过代码生成数据库描述文件, 提供了类型安全保障, 代码与数据库的映射&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过生成 record, dao 等方式支持了 curd, 无需再写基础代码.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;内置映射功能方便了对象之间的转化.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 还有其他很多特性比如: 反过来通过代码描述生成数据库, 支持 xml 读写 等等. 不在本文讨论范围.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_缺点&quot;&gt;缺点&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 也有自身的缺点和局限, 或者说在使用时需要考虑的地方&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_性能&quot;&gt;性能&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;JOOQ 在提供了方便的同事, 在以下几个阶段都会有额外的性能开销.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;construct jOOQ queries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;render SQL strings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bind values to prepared statements&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fetch results&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上面这些开销, 可以自己来设置一些缓存来减小开销, 比如保存和复用 Query 对象.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而且, 这个开销并不大, 引用官方文档的描述:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jOOQ&amp;#8217;s overhead compared to plain JDBC is typically less than 1ms per query.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个查询的额外开销是 1ms 以内.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_商业化&quot;&gt;商业化&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;jooq 是个商业软件, 售价不菲. 但我们可以使用开源版本.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;商业版本针对的是商业数据库比如 oracle, sqlServer 等, 并且会提供技术支持.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_jdk_要求&quot;&gt;jdk 要求&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比较新的开源版 jooq 要求 jdk8 以上&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_学习成本&quot;&gt;学习成本&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;
* 生成器配置比较复杂. 需要一个找一个同事来阅读文档称为配置专家, 当然也可以直接找一些比较通用的配置, 比如我这次进行测试的这个配置就可以满足大多数的需求.
* DSL写法需要看文档. 但文档很全, 比如想知道 &lt;code&gt;group by&lt;/code&gt; 怎么写直接文档中搜索就好.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;示例完整源码 &lt;a href=&quot;https://github.com/yxc023/code-examples/blob/master/java/jooq/src/test/java/com/yangxiaochen/example/jooq/JOOQTest.java&quot; class=&quot;bare&quot;&gt;https://github.com/yxc023/code-examples/blob/master/java/jooq/src/test/java/com/yangxiaochen/example/jooq/JOOQTest.java&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>方法论总结</title>
      <link>http://blog.yangxiaochen.com/blog/design-and-thinking/methodology.html</link>
      <pubDate>星期日, 5 十一月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/design-and-thinking/methodology.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_项目构建和组织&quot;&gt;项目构建和组织&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_why_gradle&quot;&gt;why gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_why_not_use_gradle&quot;&gt;why not use gradle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_controller_参数接收与验证_exception_handle&quot;&gt;controller 参数接收与验证, exception handle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_unit_test_mock&quot;&gt;unit test, mock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_领域驱动在审批流的一些使用&quot;&gt;领域驱动在审批流的一些使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_一些心得和方法论&quot;&gt;一些心得和方法论&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_完结&quot;&gt;完结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_项目构建和组织&quot;&gt;项目构建和组织&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_gradle&quot;&gt;why gradle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可读性好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件生态丰富&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活定义脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更快更智能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很多开源项目是 gradle 构建&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_why_not_use_gradle&quot;&gt;why not use gradle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;maven 语法定义更严格&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总结: gradle 进阶有一定学习成本, 重在积累.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_controller_参数接收与验证_exception_handle&quot;&gt;controller 参数接收与验证, exception handle&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用 spring mvc + validator 验证方法参数.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定类型的参数接收, 不用自己显示调用 json 转换.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一异常处理, 对 spring mvc error 的自定义处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api 文档, swagger
&amp;gt; adoc, 转为 csv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;debug 输出堆栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一接口验证?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_unit_test_mock&quot;&gt;unit test, mock&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不爱写测试 &amp;#8594; 尝到甜头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试代码 == 项目代码, 封装测试基础设施&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建数据case, 不能避免.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BDD&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_领域驱动在审批流的一些使用&quot;&gt;领域驱动在审批流的一些使用&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;service层组织&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常组织&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领域对象能够反映更可视化的实体关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能将设计切实的落实到代码. eg. completeJob(Long jobId)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_一些心得和方法论&quot;&gt;一些心得和方法论&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调研和定位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口设计角度问题, 从使用者角度出发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api 是否要抛出 exception&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重构一往无前没有回头路, 方向正确最重要&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&quot;_完结&quot; class=&quot;sect0&quot;&gt;完结&lt;/h1&gt;

	</description>
    </item>
    <item>
      <title>spring boot mvc 文件上传错误</title>
      <link>http://blog.yangxiaochen.com/blog/java/spring-mvc-multipart-error.html</link>
      <pubDate>星期二, 5 九月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/spring-mvc-multipart-error.html</guid>
      	<description>
	&lt;p&gt;NOTE: 本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;今天有一个项目，是从 tomcat 迁移到 spring boot 的。&lt;/p&gt;
&lt;p&gt;实测中发现，文件上传不进来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public JsonResult createBpmn(@RequestParam Long businessId, @RequestParam(value = &amp;quot;file&amp;quot;, required = false) MultipartsFile bpnmFile) {
  // 此时 bpmnFile == null 
  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;排查&lt;/h2&gt;
&lt;p&gt;文件上传的处理逻辑是在 &lt;code&gt;DispatherServlet.checkMultipart()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;protected HttpServletRequest checkMultipart(HttpServletRequest request) throws MultipartException {
		if (this.multipartResolver != null &amp;amp;&amp;amp; this.multipartResolver.isMultipart(request)) {
			if (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != null) {
				logger.debug(&amp;quot;Request is already a MultipartHttpServletRequest - if not in a forward, &amp;quot; +
						&amp;quot;this typically results from an additional MultipartFilter in web.xml&amp;quot;);
			}
			else if (hasMultipartException(request) ) {
				logger.debug(&amp;quot;Multipart resolution failed for current request before - &amp;quot; +
						&amp;quot;skipping re-resolution for undisturbed error rendering&amp;quot;);
			}
			else {
				try {
					return this.multipartResolver.resolveMultipart(request);
				}
				catch (MultipartException ex) {
					if (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != null) {
						logger.debug(&amp;quot;Multipart resolution failed for error dispatch&amp;quot;, ex);
						// Keep processing error dispatch with regular request handle below
					}
					else {
						throw ex;
					}
				}
			}
		}
		// If not returned before: return original request.
		return request;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;debug 可以看到当前项目中使用的用来支持上传的组件 &lt;code&gt;multipartResolver&lt;/code&gt;  是 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; 类型&lt;/p&gt;
&lt;p&gt;简单看了下这个类型的 resolver 逻辑是从 request 的 inputStream 中读取上传文件。&lt;/p&gt;
&lt;p&gt;但是发现这里 request 的 inputStream 是空的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;DispatherServlet.doDispatch()&lt;/code&gt; 方法开头，也就是所有请求要进行 contoller 分发时，request 的 inputStream 也就已经空了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
		HttpServletRequest processedRequest = request;
		HandlerExecutionChain mappedHandler = null;
		boolean multipartRequestParsed = false;

// 此时有断点，使用 IDEA 的 debug 工具 执行 IOUtil.toString(request.getInputStream)
// 发现输出为空
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这说明 inputStream 被读过了&lt;/p&gt;
&lt;p&gt;然后就在 Request 对象的 getInputStream 方法上打了断点。&lt;/p&gt;
&lt;p&gt;发现是在一个 filter 的逻辑里，最终调用了 getInputStream 方法，从调用栈的方法名字们看，也有 uploadFile 字眼&lt;/p&gt;
&lt;p&gt;这个 filter 是 &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; , 看了 doc 和代码。这个 filter 的作用大概是：因为现在浏览器只支持 get 和post，为了能支持更多的方法诸如 put ，delete 等，就约定了一个参数名叫 _method 来指定这些不支持的方法，比如 _mothod=put , 就是这次请求在之后的处理中会被当做 put 来处理。&lt;/p&gt;
&lt;p&gt;这个 filter 读取了 inputStream，并把文件加入到了 request 的属性 parts 中。这里的 request 是 tomcat 的实现的，因为内置容器是 tomcat。&lt;/p&gt;
&lt;p&gt;这就有问题了，这个 filter 把 inputStream 给读了，后面的 multipartResolver 就读不到了。&lt;/p&gt;
&lt;p&gt;这个 filter 的 doc 中有一段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NOTE: This filter needs to run after multipart processing in case of a multipart POST request, due to its inherent need for checking a POST body parameter. So typically, put a Spring org.springframework.web.multipart.support.MultipartFilter before this HiddenHttpMethodFilter in your web.xml filter chain.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说我们要把 &lt;code&gt;MultipartFilter&lt;/code&gt; 写在前面，前置执行。&lt;/p&gt;
&lt;p&gt;但是，看了一眼 &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; 可是 &lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt; 中定义的，按道理说，这个是个标准化的，不应该由我们在做什么处理才能用拿到 upload 的 file。&lt;/p&gt;
&lt;p&gt;其实，如果 multipartResolver 如果直接从 request 的 parts 属性中拿 file 不就行了，不从 inputSream 中读。spring boot 一套应该是把这些都搞定得了。&lt;/p&gt;
&lt;p&gt;后来看 &lt;code&gt;MultipartAutoConfiguration&lt;/code&gt; ，里面注册了个 multipartResolver，但类型是 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;看了 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt; 的实现，果然是从 request 的 parts 属性中取。&lt;/p&gt;
&lt;p&gt;所以，原因出来了：&lt;/p&gt;
&lt;p&gt;是在项目迁移的过程中遗留了 mvc 的 xml 配置，里面配置了 multipartResolver，类型指定为 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; , 去掉后就ok了。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;spring mvc 提供了两种 multipartResolver：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CommonsMultipartResolver&lt;/code&gt;：从 request 的 inputStream 中读取文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandardServletMultipartResolver&lt;/code&gt;：使用 &lt;code&gt;HttpServletRequest.getParts()&lt;/code&gt; 方法来获取文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;spring boot 使用的自动配置的一个 filter &lt;code&gt;HiddenHttpMethodFilter&lt;/code&gt; 会比较早的时候读取 request 的 inputStream，导致 &lt;code&gt;CommonsMultipartResolver&lt;/code&gt; 无法在获取到数据。所以 spring boot mvc 默认是用 &lt;code&gt;StandardServletMultipartResolver&lt;/code&gt;，用错 resolver 会导至上传文件读不到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HttpServletRequest.getParts()&lt;/code&gt; 方法是 servlet 3.0 之后获取  &lt;code&gt;multipart/form-data&lt;/code&gt; 类型的请求数据的一个标准方法，凡是实现了 servlet 3.0 的服务器都支持，可以尽量使用 StandardServletMultipartResolver&lt;/p&gt;
&lt;/blockquote&gt;

	</description>
    </item>
    <item>
      <title>gradle简明教程</title>
      <link>http://blog.yangxiaochen.com/blog/java/gradle-simple-introduction.html</link>
      <pubDate>星期一, 24 七月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/gradle-simple-introduction.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_前言&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_安装&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_打开一个_gradle_项目&quot;&gt;打开一个 gradle 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_新建一个_gradle_项目&quot;&gt;新建一个 gradle 项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_常见问题&quot;&gt;常见问题&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_插件选择&quot;&gt;插件选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_build速度慢&quot;&gt;build速度慢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_如何debug&quot;&gt;如何debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_私服使用和包管理混乱引起的问题&quot;&gt;私服使用和包管理混乱引起的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_常用命令或参数&quot;&gt;常用命令或参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_依赖冲突处理&quot;&gt;依赖冲突处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_交流&quot;&gt;交流&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_前言&quot;&gt;前言&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;本文没有 gradle 与 maven 对比，也没有深入 gradle 实现。只有 gradle 从 0 开始使用的说明。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个 gradle 项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引入一个 gradle 项目&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交流
&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_简介&quot;&gt;简介&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gradle 是一个构建工具。负责管理项目依赖，组织项目结构，完成项目构建的工作。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_安装&quot;&gt;安装&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;从 官网 下载，解压即可，并将 bin/gradle 命令加入到 path 中。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_打开一个_gradle_项目&quot;&gt;打开一个 gradle 项目&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通常, 大家首次接触 gradle 是遇到一个 gradle 作为构建工具项目.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;观察基于 gradle 构建的项目结构, 通常有以下几个文件:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;build.gradle                      // 重要, 构建脚本文件，主要的构建配置都在这里写
gradlew                           // gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
gradlew.bat                       // gradle wrapper 执行脚本文件的 windows 版
gradle
|- wrapper
   |- gradle-wrapper.properties   // 重要, 描述了 gradlew 使用的 gradle 版本
   |- gradle-wrapper.jar          // gradlew 执行时用到的 jar, 无需关注
settings.gradle                   // 项目配置，指明根项目名字和引入的 module&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;./gradlew tasks&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;能够列出所有可用的构建命令. 这时如果是第一次运行 gradle, 且本地没有缓存过 gradle-wrapper.properties 中描述的 gradle 版本, 则会去 gradle-wrapper.properties 指的的 url 去下载 gradle.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是这个官方地址的 gradle 下载通常会比较慢, 所以如果是要给同事分享 gradle 项目时, 可以把 gradle 提前下载到内网, 然后将 gradle-wrapper.properties 中的下载地址改成内网的地址.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;使用 idea 打开这个项目, 也就是 open build.gradle 文件, 就可以引入项目了.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_新建一个_gradle_项目&quot;&gt;新建一个 gradle 项目&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;新建一个文件夹作为项目文件夹&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
mkdir project-example
cd project-example
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 gradle 初始化&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
gradle init
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;然后目录下会生成这些文件&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
build.gradle     // 构建脚本文件，主要的构建配置都在这里写
gradle           // 存放gradle wrapper 执行配置和工具的文件夹，
gradlew          // gradle wrapper 执行脚本文件，用来在没有安装 gradle 的情况下执行 gradle 命令。当然，第一次执行时会下载 gradle。
gradlew.bat      // gradle wrapper 执行脚本文件的 windows 版
settings.gradle  // 项目配置，指明根项目名字和引入的 module
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 build.gradle 文件，结果像下面这样&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
/*
声明插件，声明插件的方式有两种，下面这种是 2.* 版本之后的新的定义方式。可以声明两种插件：
1. 官方内置插件，如 java，idea。
2. 在 gradle 插件中心注册过的插件，如第三个就是，这种要还要声明版本。
声明插件的目的是因为插件会提供很多 task，而每一个 task 就是一段构建脚本，可以执行不同的任务。比如 compileJava，test 等。
*/
plugins {
    id &apos;java&apos;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明 group 和 版本，而 project 的名字在 settings.gradle 文件中，而子 module ，或者又称为 sub projects 的名字通常和文件夹名字一样。
*/
group &apos;com.yangxiaochen.gradle&apos;
version &apos;1.0.0-SNAPSHOT&apos;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明依赖仓库，这里使用的是 jcenter，也可以使用其他的如 mavenCentral 等。也可以声明多个，会按顺序查找。
*/
repositories {
    jcenter()
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/*
声明依赖
*/
dependencies {
    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;
    testCompile &apos;junit:junit:4.12&apos;
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;   编辑 settings.gradle 文件如下，声明了project name
   ```
   rootProject.name = &apos;project-example&apos;
   // include &apos;sub-project&apos;
   ```
4. 用 idea open build.gradle 文件.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_插件选择&quot;&gt;插件选择&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;内置插件都在官方文档中有说明，除了内置插件外, 可以 [Search Gradle plugins](&lt;a href=&quot;https://plugins.gradle.org/)，gradle&quot; class=&quot;bare&quot;&gt;https://plugins.gradle.org/)，gradle&lt;/a&gt; 插件的官方仓库。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_build速度慢&quot;&gt;build速度慢&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;速度慢一般来说是依赖更新慢，因为众所周知的原因，国内使用国外的仓库速度并不乐观，所以可以替换`repositories`, 使用阿里云的仓库&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;repositories {
  maven {
  	url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再者, 有的同学使用私服, 可能是公司搭建的. 这个有时候会有不稳定, 且有时需要认证的情况. 看稍后的章节.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_如何debug&quot;&gt;如何debug&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gradle 运行中的提示并不算很友好, 尤其在链接仓库和下载jar包时, 在连接有问题的时候, 经常没有提示(新版本的可能好一些.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;经常使用&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;gradle idea -i
gradle idea -id

还可以加入 --no-daemon 参数来避免daemon启动产生的日志干扰
gradle idea -id --no-daemon
一般来说就能定位到构建问题.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;来获取更多的信息. 比较常见的卡住是因为`仓库链接不上`, &lt;code&gt;jar包下载链接不上, 又不返回 response (私有仓库偶尔有问题)&lt;/code&gt;, &lt;code&gt;资源下载缓慢&lt;/code&gt;, &lt;code&gt;仓库需要认证登陆&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;仓库连接不上: 检查仓库地址, 检查网络.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源无法连接又没有response: 这种通常会在上面打出的日志中体现, 请求一个 url 便没有响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载缓慢: 更换仓库, 或者忍耐下第一次, 以后会好很多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 IDEA 刷新有问题时, 可以执行这个命令debug, 一般这个命令能成功, 那么 IDEA 刷新通常也能成功. (请注意版本问题, 命令行里执行的 gradle 版本需要跟 IDEA 里配置的 gradle 版本一致)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_私服使用和包管理混乱引起的问题&quot;&gt;私服使用和包管理混乱引起的问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;私服使用中会有以下问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;不稳定, 偶尔服务无响应.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置出错, 无法 proxy maven 主仓库. 或者出现私服中存在第三方包但是却不完整到时无法下载.&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;一般来说会尝试把第三方仓库配置到私服之前:&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
maven {
  url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;maven {
  url &quot;http://你家私服地址/&quot;
  credentials {
    username &quot;xxx&quot;
    password &quot;xxx&quot;
  }
  authentication {
  	basic(BasicAuthentication)
  }
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;这样先去第三方查找, 再到私服查找.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;私服有认证. 可以参照第二条私服的认证方式. 其中&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
  authentication {
  	basic(BasicAuthentication)
  }
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;是可选填的, 不填的话会自动识别认证方式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包方式不完整. 有的同学上传包的时候虽然包含了编译后的jar包, pom文件, 但是有时却没有把source包上传, gradle 默认是会下载source的, 如果没有, 私服返回404还好, 最怕会卡主(遇到过私服虽然没有这个文件却迟迟不返回response的情况.), 所以, 如果遇到这种问题, 可以:&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;```
idea {
	module {
		downloadJavadoc = false
		downloadSources = false
	}
}
```&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;不让 IDEA 刷新的时候下载源码和文档, 万不得已还是不要用.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_常用命令或参数&quot;&gt;常用命令或参数&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--refresh-dependencies&lt;/code&gt;   刷新依赖，刷新那些SNAPSHOT的依赖，类似于 maven 的 -U 参数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle tasks&lt;/code&gt; 列出所有可执行的task&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle tasks --all&lt;/code&gt; 列出所有可执行的task, 并附加上 mudole&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle help --task taskName&lt;/code&gt;  查看一个task的帮助, 不过并不是所有task都有, 因为task都是可以自己来实现的.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;gradle idea -id&lt;/code&gt; 用来debug IDEA进行刷新时遇到的问题, 一般这个任务能成功, 刷新就能成功. 注意使用的 gradle 版本要一致.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--no-daemon&lt;/code&gt; 不是使用daemon进行构建. daemon的作用是不用每次 build 都再启动一个进程, 节省时间. 但却会在我们 debug 问题的时候不停的生产日志, 产生干扰.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_依赖冲突处理&quot;&gt;依赖冲突处理&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以通过命令来查看一个项目的依赖&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;gradle webapp:dependencies --configuration=compile&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不同于maven的&lt;strong&gt;最近&lt;/strong&gt;原则，gradle 依赖使用的是&lt;strong&gt;最新&lt;/strong&gt;原则. 比如你构建处于依赖顶层的 module , 那么版本会优先使用这个顶层module 的`build.grale` 中定义的版本. 所以可以在顶层module 中强制定义版本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;依赖排除, 通常可以使用&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) {
    exclude module: &quot;spring-boot-starter-logging&quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样的语法, 还有更为粗暴直接的:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;&lt;code&gt;configurations {
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-classic&apos;
    all*.exclude group: &apos;ch.qos.logback&apos;, module: &apos;logback-core&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;官方文档相当的详细，且附有很多example，配合 gradle 安装包里的 example 源文件阅读&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_交流&quot;&gt;交流&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;欢迎加入群 661035226，gradle，spring，activiti 交流&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Java web 项目异常设计实践</title>
      <link>http://blog.yangxiaochen.com/blog/java/exception-in-action.html</link>
      <pubDate>星期一, 10 七月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/exception-in-action.html</guid>
      	<description>
	&lt;h1&gt;异常实践&lt;/h1&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文是我在项目中设计和处理异常的一些实践，主要是围绕着常见的web项目，欢迎大家指正。&lt;/p&gt;
&lt;p&gt;本文分为两个个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异常设计&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2&gt;异常设计&lt;/h2&gt;
&lt;p&gt;通常考虑异常设计时大致分为三个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口层&lt;/li&gt;
&lt;li&gt;业务层&lt;/li&gt;
&lt;li&gt;类库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接口层就是我们通常说的 controller 层，以及提供 rpc 服务的接口层。&lt;/p&gt;
&lt;p&gt;业务层就是主要的业务代码模块，主要是 service 层。&lt;/p&gt;
&lt;p&gt;类库主要是指一些公共模块，可以在各个项目中使用的，比如 json，分布式锁等。&lt;/p&gt;
&lt;h3&gt;业务层&lt;/h3&gt;
&lt;p&gt;在业务层，我们主要是要设计&lt;strong&gt;业务异常&lt;/strong&gt;。什么是业务异常？业务异常就是我们能够人为的判断出业务逻辑走到某一个位置是不对的。比如，我们要根据一个 uid 来修改一个 user 的 name，但我们发现并没有这个 uid 对应的 user 数据，这时候就应该抛出一个业务异常。在发生业务异常时，要避免抛出 npe，RuntimeException 等其他内置异常，以方便上层来分辨到底是业务错误还是程序 bug。&lt;/p&gt;
&lt;p&gt;我一般会设计一个业务异常的基类 &lt;code&gt;ServiceException&lt;/code&gt;，将所有业务异常以这种类型来抛出，并带有必要的 message。&lt;/p&gt;
&lt;p&gt;为了把用户可读的消息和开发人员可读的消息区别开，&lt;code&gt;ServiceException&lt;/code&gt; 还需要实现一个接口 &lt;code&gt;UserMessage&lt;/code&gt;，并实现其中方法 &lt;code&gt;getUserMessage()&lt;/code&gt;来返回用户可读的信息，而 getMessage() 可以携带更详细的开发人员可读的错误信息&lt;/p&gt;
&lt;p&gt;设计一个 &lt;code&gt;ServiceErrorException&lt;/code&gt;，继承 &lt;code&gt;ServiceException&lt;/code&gt;。&lt;code&gt;ServiceErrorException&lt;/code&gt; 的主要目的是为了表明这个异常的错误程度高，需要记录 error。&lt;/p&gt;
&lt;p&gt;以上就定型了业务异常的基本结构，上面一些特殊设计会在&lt;strong&gt;异常处理&lt;/strong&gt;中用到，我们后面来说，再做前后对照。我们可以根据需要来实现若干子类来表示业务层中不同模块的错误。&lt;/p&gt;
&lt;h3&gt;接口层&lt;/h3&gt;
&lt;p&gt;对于接口层，特别是rpc调用，比如我们的dubbo调用，需要把api的jar包放在调用方。我们需要把异常类给包括进去，但调用方不能也不应该拿到我们业务层的 &lt;code&gt;ServiceException&lt;/code&gt;，所以需要在接口层定义新的业务异常类型，比如，就叫&lt;code&gt;ApiServiceException&lt;/code&gt;，放在api的jar包里给调用方。&lt;/p&gt;
&lt;p&gt;接口实现需要把业务层的&lt;code&gt;ServiceException&lt;/code&gt;给catch到，重新封装为&lt;code&gt;ApiServiceException&lt;/code&gt;抛出。&lt;/p&gt;
&lt;p&gt;这样，调用方在判断调用时发生的异常时，有三种可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rpc框架异常。比如又dubbo框架抛出的异常，这一版两种可能：1. 网络异常，我们需要重试；2. 调用未能达成，这种一般是接口没有匹配上，在开发测试时都可以发现的错误，改掉即可。所以，当发生rpc框架异常时，调用方的策略就应该是重试。&lt;/li&gt;
&lt;li&gt;ApiServiceException。这表示被调用方出现了业务异常，调用方也需要作为业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。这表示被调用方的程序有bug报出了异常透传给了调用方，这是调用方应及时联系接口实现方来修补bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就能够分类准确应对rpc过程中的异常情况。&lt;/p&gt;
&lt;p&gt;http方式的接口层也可以这么做，不过由于api并不对外，所以也可以完全由自身来处理异常类型，详见&lt;strong&gt;异常处理&lt;/strong&gt;部分。&lt;/p&gt;
&lt;h3&gt;类库&lt;/h3&gt;
&lt;p&gt;作为类库，因为通常没有业务意义，所以在发生逻辑上的异常时，根本不可能知道需要怎么处理，这就需要直接向上抛出，到交给业务层处理。&lt;/p&gt;
&lt;p&gt;类库需要将自身的逻辑上的异常，同一封装。比如，处理 Json 的类库，异常最终抛出时，都被封装成为&lt;code&gt;JsonParseException&lt;/code&gt; 或 &lt;code&gt;JsonSerializeExcption&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样调用方使用类库时，异常会有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类库封装的自定义异常。这种是调用时出现的逻辑错误，调用方以业务异常来处理。&lt;/li&gt;
&lt;li&gt;其他异常。可以认为是类库bug。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;p&gt;有了以上的异常设计，那么处理时就可以按照以下流程。&lt;/p&gt;
&lt;p&gt;以 http 请求的 ExceptionHandler 为例，所有 http 请求异常都会放在这里处理，过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ex 异常传入。&lt;/li&gt;
&lt;li&gt;装饰 ex 异常，&lt;code&gt;ex = new WebApiException(...,ex)&lt;/code&gt;，其包含有 &lt;code&gt;message&lt;/code&gt;，&lt;code&gt;isLogError&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;如果 ex 是非 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = “系统内部错误”&lt;/code&gt;，&lt;code&gt;isLogError = true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 ex 是 &lt;code&gt;ServiceException&lt;/code&gt;，那么&lt;code&gt;message = ex.getUserMessage()&lt;/code&gt;；更进一步，如果是 &lt;code&gt;ServiceErrorException&lt;/code&gt;，那么&lt;code&gt;isLogError = true&lt;/code&gt;，否则 &lt;code&gt;isLogError = false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ex.isLogError == true&lt;/code&gt;，记录 error log，否则，记录 warn log。&lt;/li&gt;
&lt;li&gt;判断 http 请求是页面请求，还是ajax请求。&lt;/li&gt;
&lt;li&gt;如果是页面请求。500转错误页，显示 &lt;code&gt;ex.getMessage()&lt;/code&gt;，如果是debug环境或者是请求带有debug参数，也把错误堆栈输出在页面上。&lt;/li&gt;
&lt;li&gt;如果是 ajax 请求。返回表示错误的 json 消息，同样，如果是debug环境或者是请求带有debug参数，消息中带上堆栈信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上，就是一个简单而有效的异常处理机制。&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>spring &amp; spring mvc 初始化介绍</title>
      <link>http://blog.yangxiaochen.com/blog/java/spring-spring-mvc-initalize.html</link>
      <pubDate>星期四, 30 三月 2017 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/spring-spring-mvc-initalize.html</guid>
      	<description>
	&lt;p&gt;NOTE: 本文为原创, 转载请注明出处 &lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/p&gt;
&lt;!-- # spring &amp; spring mvc 初始化介绍 --&gt;
&lt;h2&gt;web项目的结构&lt;/h2&gt;
&lt;h3&gt;java servlet 技术&lt;/h3&gt;
&lt;p&gt;java servlet 技术是 java 的一个 web 服务规范, 提供了统一的 servlet api 供各个容器厂商实现, 以保证一个 java web 项目可以运行在不同厂商的服务器下.&lt;/p&gt;
&lt;p&gt;请看实例简单复习下 servlet, listner, filter&lt;/p&gt;
&lt;p&gt;listner, filter 会在 web 容器启动时执行 init 方法&lt;/p&gt;
&lt;p&gt;servlet 会在第一次访问时进行初始化. 当然也可以设置 init on start&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3&gt;非 servlet 规范的 java web 项目&lt;/h3&gt;
&lt;p&gt;使用netty作为服务器lib, 加入 http 协议的处理层,  自行完成处理 http 请求读写&lt;/p&gt;
&lt;h3&gt;spring mvc 的的封装&lt;/h3&gt;
&lt;p&gt;我们最常用到的 spring mvc 框架就是对 servlet 技术的封装, 在 web.xml 中加入实现 &lt;code&gt;Listenner&lt;/code&gt; 的 &lt;code&gt;SpringContextListener&lt;/code&gt; 和实现了 &lt;code&gt;Servlet&lt;/code&gt; 的 &lt;code&gt;DispatcherServlet&lt;/code&gt;, 来对spring 和 spring mvc 进行初始化.&lt;/p&gt;
&lt;h2&gt;spring context 结构&lt;/h2&gt;
&lt;p&gt;spring context 是整个 spring 的核心, 通常也被叫做 spring 容器. 通常讲的 spring 初始化过程, 就是初始化 spring context 的过程.&lt;/p&gt;
&lt;p&gt;根据应用不同, 使用的 spring  context 类型也不同&lt;/p&gt;
&lt;h3&gt;继承树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/context继承.png&quot; alt=&quot;context继承.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;常见的 war 包形式的 web 应用, 使用的是 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;spring boot 默认使用的是 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;重要组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 通用组件, 负责 bean 注册和初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Environment&lt;/code&gt; 通用组件 , 包含系统参数, 启动参数等. 还有对启动参数解析后的属性, 比如 profile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplicationListener&lt;/code&gt;s 通用组件, 保存注册进来的context事件listener&lt;/li&gt;
&lt;li&gt;一些 context 状态标志, parent&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletContext&lt;/code&gt;, &lt;code&gt;ServletConfig&lt;/code&gt; WebApplicationContext类里特有的&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些特定的参数. 在特定context类型中, 比如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/** Default config location for the root context */
public static final String DEFAULT_CONFIG_LOCATION = &amp;quot;/WEB-INF/applicationContext.xml&amp;quot;;

/** Default prefix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_PREFIX = &amp;quot;/WEB-INF/&amp;quot;;

/** Default suffix for building a config location for a namespace */
public static final String DEFAULT_CONFIG_LOCATION_SUFFIX = &amp;quot;.xml&amp;quot;;	
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;spring context 初始化过程概念概览&lt;/h2&gt;
&lt;p&gt;一个 spring context 的初始化过程大致分为以下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取并设置系统参数, 环境变量, 获取一些初始化 context 需要的组件, 比如 ApplicationContextInitializer 等.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个属于context 初始化的前置逻辑, 由应用自己控制, 我们也可自己来写, 用来给后面 context 初始化做准备&lt;/p&gt;
&lt;p&gt;这一步根据应用不同差别很大, 比如传统 war 包的 ContextLoadListner 和 spring boot 的 SpringApplication 中的逻辑就很不同.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;create context&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据应用不通, 创建不同的 context&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;configure context&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用第1步获得的参数和组件, 来配置创建好的 context&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;context.refresh&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;核心步骤, context 初始化的具体过程就在这里.&lt;/p&gt;
&lt;p&gt;包括分门别类的加载各种特殊的 bean, 然后加载普通的ben&lt;/p&gt;
&lt;h2&gt;spring 初始化过程实例概览(非 spring boot 的传统war包)&lt;/h2&gt;
&lt;h3&gt;ContextLoaderListener&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt; 配置在 web.xml 中, 在容器启动时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/ContextLoaderListener.png&quot; alt=&quot;ContextLoaderListener.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3) 决定spring web app context类型. 不指定的情况下默认策略创建 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16) 以 bean 的 configuration 文件, 就是一般我们说的xml文件 为入口, 加载 &lt;code&gt;BeanDefinition&lt;/code&gt; 到 bean factory. 注意仅仅是加载 bean 的描述, 而没有实例化这些 bean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;17) 实例化执行所有的 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;, 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中和 context 的 &lt;code&gt;beanFactoryPostProcessors&lt;/code&gt; 字段中查找.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;是意图在 bean factory 加载了所有定义的 bean 定义之后, 且在这些 bean 实例化之前, 做一些操作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一步通常在调用各个 processor 时, 产生新的 bean 定义到 bean factory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;18) 注册 &lt;code&gt;BeanPostProcessor&lt;/code&gt; , 从 &lt;code&gt;BeanDefinition&lt;/code&gt; 中查找.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt; 会在之后每个 bean 实例化之后调用, 用来对 bean 做一些其他操作, 比如放入一些参数:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 &lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt; 的作用就是注入 &lt;code&gt;@Autowired&lt;/code&gt; 字段.&lt;/p&gt;
&lt;p&gt;生成动态代理对象也是通过  &lt;code&gt;BeanPostProcessor&lt;/code&gt; 实现的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;21) &lt;code&gt;onRefresh&lt;/code&gt; 是用来初始化其他的特殊的 bean, 这部分逻辑通常在特殊的 context 子类实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如在 spring boot 中使用的 &lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt; 中, 会在这里初始化并启动内嵌服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;22) 将在  &lt;code&gt;BeanDefinition&lt;/code&gt; 中的, 还有之前设置到context属性中的  &lt;code&gt;ApplicationListener&lt;/code&gt; 加到广播列表中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;23) 将  &lt;code&gt;BeanDefinition&lt;/code&gt;  中其他的非懒加载的 bean 实例化.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;24) 实例化并调用 &lt;code&gt;LifecycleProcessor&lt;/code&gt; , 然后广播 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;26) 将 context 放到 &lt;code&gt;ServletContext&lt;/code&gt; 的 attribute 属性里, 之后 &lt;code&gt;DispatcherServlet&lt;/code&gt; 初始化会用到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;*以上说的 bean 均为 singleton 的 scope&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;DispatcherServlet&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 配置在 web.xml 中, 在第一次访问时初始化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.yangxiaochen.com/image/blog/DispatcherServlet.png&quot; alt=&quot;DispatcherServlet.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;部分较为重要步骤解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5) 以 &lt;code&gt;ContextLoaderListener&lt;/code&gt;创建的 context 为 parent, 创建新的 &lt;code&gt;XmlWebApplicationContext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;8) 创建一个 &lt;code&gt;ContextRefreshListener&lt;/code&gt; , 加入到 context 中, 监听 &lt;code&gt;ContextRefreshedEvent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;9) refresh 过程跟&lt;code&gt;ContextLoaderListener&lt;/code&gt; 一样, 不同的是在查找 bean 时, 能够查到 parent context 的 bean, 供新的 context 初始化使用.&lt;/li&gt;
&lt;li&gt;10) 触发  &lt;code&gt;ContextRefreshedEvent&lt;/code&gt; , 初始化 spring mvc 的组件, 添加到 &lt;code&gt;DispatcherServlet&lt;/code&gt; 中.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一些特殊类型Bean的初始化时机 (待完善, 请持续补充)&lt;/h2&gt;
&lt;h3&gt;BeanFactoryPostProccesor&lt;/h3&gt;
&lt;p&gt;context refresh 之后, 初始化好 factory 之后, 会先执行 context 自身的 factory post 操作, 然后就会执行  &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt;  这种类型 bean 所定义的 factory post 操作.&lt;/p&gt;
&lt;h3&gt;BeanDefinitionRegistryPostProcessor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 的子类, 执行优先级比 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 要高. 通常可以通过 order 来控制&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt; 类型的执行顺序, 还跟这个 bean 定义的时机有关, 在 prepare context 阶段定义的总会最先执行.&lt;/p&gt;
&lt;p&gt;通常自定义的 xml 和 bean 配置 会在这个阶段被定义到 factory.&lt;/p&gt;
&lt;h3&gt;BeanPostProccesor&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 都执行完之后实例化, 并 apply 到 factory ,  在一个 bean 初始化之后会被调用.&lt;/p&gt;
&lt;h3&gt;Aware&lt;/h3&gt;
&lt;p&gt;如 &lt;code&gt;ApplicationContextAware&lt;/code&gt; , 实现这个接口的 bean 会由一个 &lt;code&gt;BeanPostProccesor&lt;/code&gt; 类型的  &lt;code&gt;ApplicationContextAwareProcessor&lt;/code&gt; 在初始化之后 set 一个 application context&lt;/p&gt;
&lt;p&gt;Aware 相关类的很多, 都类似&lt;/p&gt;
&lt;h3&gt;ApplicationListener&lt;/h3&gt;
&lt;p&gt;用来监听 context 生命周期中各个事件的类, 可以在 prepare 和 refresh 阶段注入&lt;/p&gt;
&lt;h3&gt;ApplicationContextInitializer&lt;/h3&gt;
&lt;p&gt;prepare context 阶段执行, 在 context refresh之前执行. 可以对 context 注入 &lt;code&gt;BeanFactoryPostProccesor&lt;/code&gt; 和 &lt;code&gt;ApplicationListener&lt;/code&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Java异常规范</title>
      <link>http://blog.yangxiaochen.com/blog/java/exception-pattern.html</link>
      <pubDate>星期四, 29 九月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/exception-pattern.html</guid>
      	<description>
	&lt;h1&gt;异常规范&lt;/h1&gt;
&lt;h2&gt;异常介绍&lt;/h2&gt;
&lt;h4&gt;Throwable&lt;/h4&gt;
&lt;p&gt;所有Exception和Error的父类.&lt;/p&gt;
&lt;h4&gt;Error&lt;/h4&gt;
&lt;p&gt;致命错误. 项目自身存在问题, 诸如格式有问题, 编译版本不对, 堆栈溢出等, 项目在出现ERROR的情况下是不应该运行的. 同时, 程序遇到Error时, 程序不需要, 通常也是没有能力做处理的, 只能够停止程序针对项目或者运行环境做人工处理才行.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4&gt;Exception&lt;/h4&gt;
&lt;p&gt;区别于Error, 是程序可以自己处理的异常. Exception的子类中, 特殊的RuntimeException被称为&lt;strong&gt;运行时异常&lt;/strong&gt;, 也叫&lt;strong&gt;非受检异常&lt;/strong&gt;; 其他的子类包括Exception类本身都叫&lt;strong&gt;受检异常&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;受检异常&lt;/h5&gt;
&lt;p&gt;Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。&lt;/p&gt;
&lt;h5&gt;非受检异常(运行时异常)&lt;/h5&gt;
&lt;p&gt;不需要强制catch或者throw的异常.&lt;/p&gt;
&lt;h2&gt;程序中如何使用异常&lt;/h2&gt;
&lt;p&gt;程序中我们主要关注&lt;strong&gt;受检异常&lt;/strong&gt;和&lt;strong&gt;运行时异常&lt;/strong&gt;的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些原则, 这些原则并不独立, 互相之间有照应或者补充:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发生可恢复错误的抛出受检异常，程序错误就抛出运行时异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用运行时异常. 从保障代码简洁, 清晰, 有意义的角度上来说.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意绝对不是无脑把受检异常换为运行时异常.&lt;/p&gt;
&lt;p&gt;很多时候我们要延迟处理异常: 比如我们的一个受检异常在层次很深的地方抛出, 但是我们在代码层次很高的地方才能做处理, 那么受检异常会出现在代码调用的每一层. 这非常繁琐, 也不清晰.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谨慎抛出受检异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;受检异常是不受欢迎的.&lt;/p&gt;
&lt;p&gt;除非你认为你是在强调这个异常, 调用者在大多数情况下需要重点关注这个异常并catch这个异常并做处理.&lt;/p&gt;
&lt;p&gt;使用运行时异常带来的简洁并不能够弥补开发人员忽略了这个异常带来的问题时.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为定位是类库的模块, 尽量使用运行时异常, 并对java低层异常封装, 抛出类库特有的概括性的异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当站在调用者的角度, 可以获悉这个类库有哪几种异常, 出现时代表什么了.&lt;/p&gt;
&lt;p&gt;移位类库的调用很多时候跟业务没有关系, 当出现错误时, 通常是因为我们的代码漏洞造成的, 这并不能简单通过try_catch进行恢复, 所以尽量不使用受检异常.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为定位是服务的模块, 可以使用一些受检异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为当调用服务出现错误, 一般是一个可以解释的业务错误, 如果是想要调用者非常注意的错误, 可以使用受检异常.&lt;/p&gt;
&lt;p&gt;服务的调用一般代码层次比较浅, 并且是和业务比较相关的.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务异常需要单独封装成新的异常来表达一类或者一个模块的业务错误, 可以使用受检异常. 但也参照1, 2, 3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以把一些非业务异常封装成为业务异常, 如果你知道在这个地方这种非业务异常在业务上可以表达一些含义.&lt;/p&gt;
&lt;p&gt;比如某个位置抛出了json解析异常, 我们可以说传入的某个数据格式是错误的.&lt;/p&gt;
&lt;p&gt;为了给大家建立异常体系结构, 业务异常定义为受检异常, 强制让大家关注下.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非业务异常, 代码底层异常, 如果出现的话可以定义为代码bug的, 使用运行时异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使没有catch住的后果是在系统运行时抛给了用户, 也不应该catch. 当然在项目中需要一个最高层次的异常处理, 对非业务异常统一catch记录报警而不要暴露给用户&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务异常如果可以, 不要跨层(跨模块)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;controller -&amp;gt; service -&amp;gt; adaptor -&amp;gt; UC dubbo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;UC dubbo 抛出的异常, 应该在adaptor或者service做处理封装新的异常, 不要让controller直面UC dubbo的异常.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异常应该携带更多信息.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尤其对业务异常来说, 知道异常发生时的业务数据是很重要的, 方便查找定位问题.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在api层(controller层), 将一些业务异常封装为API异常, 这类异常将直接给用户api异常的提示, 且有时可以认为这些异常是正常的, 不需要报警的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效的业务异常类划分和异常code定义, 有助于统一处理异常时区别异常的等级合适否需要报警.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在设计异常时请考虑这一点.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果不知道自己的异常应该是使用受检异常还是运行时异常, 使用运行时异常.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先报出错误, 不做对未知的设计&lt;/p&gt;
&lt;h2&gt;如何处理异常&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;绝对禁止catch后什么都不做!&lt;/li&gt;
&lt;li&gt;在catch之后封装成新异常抛出的时候, 不要记录日志. 因为你抛出了, 会有上层来处理记录日志, 只要没有1这种情况, 总会有信息的. 这里再记录日志就重复了.&lt;/li&gt;
&lt;li&gt;在需要时一定要使用上finally&lt;/li&gt;
&lt;li&gt;处理异常时记录的日志一般要把异常的堆栈给记录下来.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;具体实施方案&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;所有类库&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/fn-commons&quot;&gt;fn-commons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/common-search&quot;&gt;common-search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个项目, master打tag, 切新版本分支, 升级大版本, 例如1.0 -&amp;gt; 2.0&lt;/p&gt;
&lt;p&gt;目标: 基本都是用运行时异常,减轻调用负担, 看情况决定是否自定义异常. 类库尽量少记log, 尤其不能记info的log. 这个出log规范的时候再说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重点项目&lt;a href=&quot;http://git.lianjia.com/fnrd/fnrd-gte&quot;&gt;fnrd-gte&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;切个exception-refactor分支&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新类库依赖. 更改由依赖更新引起的代码错误.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中在service包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;adaptor&lt;/p&gt;
&lt;p&gt;新建一个RPCException, 继承RuntimeException, 替换现有的直接用RuntimeException抛出.&lt;/p&gt;
&lt;p&gt;RPCException可以带一些请求参数信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;api包&lt;/p&gt;
&lt;p&gt;强烈建议使用&lt;a href=&quot;http://git.lianjia.com/fnrd/api-common&quot;&gt;api-common&lt;/a&gt;, 不过涉及较多, 可以逐步改改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;impl包, 核心流程逻辑&lt;/p&gt;
&lt;p&gt;重点处理的位置, 挨个文件看, 然后从低向上重构&lt;/p&gt;
&lt;p&gt;定义FlowException作为主要流程业务异常, 统一处理时将会使用其中msg通知用户, &lt;strong&gt;非FlowException将会统一封装友好提示&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;可以定义更加细致的异常继承FlowException异常, 以应对更细致的需要.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;event, listner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易, 金融业务相关的增删改查service等.&lt;/p&gt;
&lt;p&gt;可以新定义FnServiceExcetion, TeServiceException, 也作为一类业务异常.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;controller&lt;/p&gt;
&lt;p&gt;选择性的对一些异常封装, WebApiException, msg直接给用户显示.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

	</description>
    </item>
    <item>
      <title>git实际开发语句</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-use.html</link>
      <pubDate>星期一, 4 七月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-in-use.html</guid>
      	<description>
	&lt;!-- # git实际使用指南 --&gt;
&lt;h2&gt;dev上工作git指南&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切到&lt;code&gt;dev&lt;/code&gt;分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b bug/JRTE-333-问题描述
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/JRTE-333-需求描述
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.....
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提交分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起&lt;code&gt;merge request&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;登陆git.lianjia.com发起
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一切正常, 就结束了. 如果发现&lt;code&gt;merge request&lt;/code&gt;有冲突, 不能合并, 转 &lt;code&gt;7&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;merge request&lt;/code&gt;有冲突&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到&lt;code&gt;dev&lt;/code&gt;, 更新之.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git co dev
git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切回你的分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git co [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rebase! 难以理解而又复杂的一步. 但做过一次你就会了!&lt;/p&gt;
&lt;p&gt;进行rebase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git rebase dev&lt;/code&gt; 的意思是将&lt;code&gt;你的分支&lt;/code&gt;上的每一次提交, 应用到&lt;code&gt;dev&lt;/code&gt;分支的尾部.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果提示有冲突, 转&lt;code&gt;7.5&lt;/code&gt;. 如果没有冲突:&lt;/p&gt;
&lt;p&gt;因为你push过你的分支, 所以&lt;code&gt;远程你的分支&lt;/code&gt;和&lt;code&gt;本地你的分支&lt;/code&gt;已经不一致了. 所以强行覆盖&lt;code&gt;你的远程分支&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push -f origin [你的分支名字]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你就发现你的&lt;code&gt;merge request&lt;/code&gt;显示可以自动合并了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冲突, 然后根据提示执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add [冲突文件]
git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果还有冲突, 转&lt;code&gt;7.5&lt;/code&gt;, 如果没有, 转&lt;code&gt;7.4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如果出现以下情况, 很有可能你就错了&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;把&lt;code&gt;dev&lt;/code&gt;上的代码merge到分支:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git merge dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;dev&lt;/code&gt;上merge分支代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在dev上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在任何分支上执行&lt;code&gt;git pull&lt;/code&gt;发现不是&lt;code&gt;fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;合并为一次提交&lt;/h2&gt;
&lt;h3&gt;方法一&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始version]
git add .
git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法二, 保证没有冲突, 且合并为一次提交!&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;4. 提交分支&lt;/code&gt; 时, 先更新&lt;code&gt;dev分支&lt;/code&gt;, 然后在&lt;code&gt;你的分支&lt;/code&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase dev -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把除了第一个&lt;code&gt;pick&lt;/code&gt;全改成&lt;code&gt;s&lt;/code&gt;或者&lt;code&gt;squash&lt;/code&gt;. 提示很全, 试试吧.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git分支管理与使用规范</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-in-action.html</link>
      <pubDate>星期二, 21 六月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-in-action.html</guid>
      	<description>
	&lt;!-- # git分支管理与使用规范 --&gt;
&lt;h2&gt;分支管理&lt;/h2&gt;
&lt;h3&gt;flow&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git flow&lt;/li&gt;
&lt;li&gt;github flow&lt;/li&gt;
&lt;li&gt;gitlab flow&lt;/li&gt;
&lt;li&gt;fn flow&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h3&gt;分支与开发定义&lt;/h3&gt;
&lt;h4&gt;主要分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;master&lt;/p&gt;
&lt;p&gt;线上分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;develop&lt;/p&gt;
&lt;p&gt;常规开发分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;masterfix&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 一直存在&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;辅助分支&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;feature/*&lt;/p&gt;
&lt;p&gt;功能开发分支, 从develop分支而来, 然后合并入develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;release/*&lt;/p&gt;
&lt;p&gt;上线分支, 从develop分支而来, 然后合并入master, 并应用到develop, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hotfix/*&lt;/p&gt;
&lt;p&gt;线上bug修改分支, 从masterfix分支而来, 然后合并入masterfix, 最终删除.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;如何使用各种分支&lt;/h3&gt;
&lt;h4&gt;init&lt;/h4&gt;
&lt;p&gt;一个项目初始有master分支, 需要新建立一个develop分支和masterfix分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git br -b develop 
git push origin develop

git br -b masterfix
git push origin masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;feature&lt;/h4&gt;
&lt;p&gt;常规功能开发需要从develop分支checkout出feature分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b feature/GET-1008-添加用户查询列表 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发完毕后合并回develop分支&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git pull // 先更新develop
git merge feature/GET-1008-添加用户查询列表 --no-ff
git push origin develop

git branch -d feature/GET-1008-添加用户查询列表
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Release&lt;/h4&gt;
&lt;p&gt;开发完毕, 准备发布:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b release/1.0.0 [develop]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在发布分支上处理一些发布操作, 比如更改版本号, 上线前测试, 问题修改等等. 当分支可以进行上线发布后:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge release/1.0.0 --no-ff 
git tag -a 1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此release完成, 但是需要将在release分支上的修改应用到develop上.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge release/1.0.0 --no-ff

git branch -d release/1.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, 我们可以激活masterfix分支, 同步一下已经上线的master分支, 为修改将要出现的线上bug做准备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge master // 在正常情况下, 这里一定是fast-faward
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;hotfix&lt;/h2&gt;
&lt;p&gt;当出现bug时, 我们需要从master或者是masterfix分支上分出hotfix分支来修改bug.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b hotfix/修改空指针 masterfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完毕后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout masterfix
git merge hotfix/修改空指针 --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;期间可以进行多次hotfix, 最后当masterfix测试后没有问题, 准备上线:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在master上打下当前上线的tag&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag -a 1.0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样, 这些修改要应用到develop分支上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout develop
git merge masterfix --no-ff
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;分支与环境对应?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;master    --  online&lt;/li&gt;
&lt;li&gt;release   --  off&lt;/li&gt;
&lt;li&gt;develop   --  ci&lt;/li&gt;
&lt;li&gt;masterfix --  online-bug-fix&lt;/li&gt;
&lt;li&gt;feature   --  local, dev&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;h2&gt;使用规范&lt;/h2&gt;
&lt;h3&gt;鼓励开分支&lt;/h3&gt;
&lt;p&gt;鼓励本地开分支开发, 独立功能独立分支.&lt;/p&gt;
&lt;h3&gt;将分支上提交合并&lt;/h3&gt;
&lt;p&gt;分支上开发的commit建议合并为一个commit, 这样易读, 方便主分支管理.&lt;/p&gt;
&lt;p&gt;一种最简单直接的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset [分支开始处]
git commit -m &amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方法, 在feature分支上执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i develop // 将feature分支的修改应用到develop上

// 后续操作
http://www.ruanyifeng.com/blog/2015/08/git-use-process.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;保留分支信息&lt;/h3&gt;
&lt;p&gt;在不同分支合并时使用 &lt;code&gt;--no-ff&lt;/code&gt; 参数生成merge commit&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commit e562022b423f7bf29f77927dea4d13cb05230681
Merge: d88f815 799b7f8
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:41 2016 +0800

    Merge branch &apos;feature/welcome&apos; into develop

commit 799b7f87b99d5f5c49acf2edd8a6a363ff44f29f
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:10:11 2016 +0800

    也修改auth

commit 18e7893f1583559003f7a4bb41fd03b937b3ed42
Author: 杨晓辰 &amp;lt;yangxiaochen@yangxiaochendemacbook-pro.local&amp;gt;
Date:   Tue May 31 17:08:04 2016 +0800

    修改 auth
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;减少以及消除无意义的分支内merge&lt;/h3&gt;
&lt;p&gt;同一分支更新时要避免产生无意义的merge&lt;/p&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;h3&gt;冲突提交&lt;/h3&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;常用操作&lt;/h3&gt;
&lt;p&gt;回滚&lt;br /&gt;
git reset --hard [version]  // 丢弃版本后的所有修改&lt;br /&gt;
git reset [version]         // 保留版本后的所有已提交修改&lt;br /&gt;
git reset --soft [version]  // 保留版本后的所有已提交修改到commit stage&lt;/p&gt;
&lt;p&gt;补充提交&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提交tag到服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;日志与diff&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sourcetree // 软件
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-workflow.html&quot;&gt;Git 工作流程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/08/git-use-process.html&quot;&gt;合并commit&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>git-flow实践</title>
      <link>http://blog.yangxiaochen.com/blog/git/git-flow-in-action.html</link>
      <pubDate>星期日, 12 六月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/git/git-flow-in-action.html</guid>
      	<description>
	&lt;!-- # git-flow 操作实践 --&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;brew install git-flow
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2&gt;init&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ git flow init

Initialized empty Git repository in ~/project/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [master]
Branch name for &amp;quot;next release&amp;quot; development: [develop]

How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时会在当前目录执行git init操作. 并且生成4个分支名字, 并且默认在develop分支上, develop分支就是我们主要工作的地方.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
* develop
master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们除了要把master分支推到远端仓库, develop同样也要推到远端仓库 &lt;code&gt;git push origin develop&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Feature branches&lt;/h2&gt;
&lt;p&gt;开始一个新功能添加, 或者是一般bug修复, 或者是其他功能. 我们需要开一个feature分支. 我们在本地的主要工作都是要开feature分支完成的. ** 不要在develop 分支上开发. **&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature start authentication
Switched to a new branch &apos;feature/authentication&apos;

Summary of actions:
- A new branch &apos;feature/authentication&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;feature/authentication&apos;

Now, start committing on your feature. When done, use:

    git flow feature finish authentication
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后你可以做自己的修改了, 完成后, 需要将feature合并回develop分支.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow feature finish authentication
Switched to branch &apos;develop&apos;
Updating 9060376..00bafe4
Fast-forward
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch feature/authentication (was 00bafe4).

Summary of actions:
- The feature branch &apos;feature/authentication&apos; was merged into &apos;develop&apos;
- Feature branch &apos;feature/authentication&apos; has been removed
- You are now on branch &apos;develop&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;多个开发者进行开发时, 会出现每个人本地的develop分支不一致的情况, 这样在每次拉取远端develop分支时, 会出现很多merge提交. 关于这个问题, 在最后的&lt;code&gt;减少以及消灭无用的merge commit&lt;/code&gt;章节中说明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;releases&lt;/h2&gt;
&lt;p&gt;在没有使用git-flow工具时, 发布是一件很繁琐的事情, 要保留一个用于releases的分支, 打tag等. 使用git-flow可以用简单命令解决.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release start 0.1.0
Switched to a new branch &apos;release/0.1.0&apos;

Summary of actions:
- A new branch &apos;release/0.1.0&apos; was created, based on &apos;develop&apos;
- You are now on branch &apos;release/0.1.0&apos;

Follow-up actions:
- Bump the version number now!
- Start committing last-minute fixes in preparing your release
- When done, run:

    git flow release finish &apos;0.1.0&apos; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你将开始一个发布, 一般可以直接finishi&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow release finish 0.1.0
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
authentication.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 authentication.txt
Deleted branch release/0.1.0 (was 1b26f7c).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Release branch has been merged into &apos;master&apos;
- The release was tagged &apos;0.1.0&apos;
- Release branch has been back-merged into &apos;develop&apos;
- Release branch &apos;release/0.1.0&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时develop分支回合并到master分支, 并打tag. 之后我们只要把master和tag都推到远端仓库即可.&lt;/p&gt;
&lt;h2&gt;Hotfixing production code&lt;/h2&gt;
&lt;p&gt;紧急bug修复, 在已经发布的代码上更正. 会从master开出hotfix分支, 然后合并回master, 也会合并回develop.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix start assets
Switched to a new branch &apos;hotfix/assets&apos;

Summary of actions:
- A new branch &apos;hotfix/assets&apos; was created, based on &apos;master&apos;
- You are now on branch &apos;hotfix/assets&apos;

Follow-up actions:
- Bump the version number now!
- Start committing your hot fixes
- When done, run:

    git flow hotfix finish &apos;assets&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改问题, 之后提交:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git flow hotfix finish assets
Switched to branch &apos;master&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Switched to branch &apos;develop&apos;
Merge made by the &apos;recursive&apos; strategy.
assets.txt | 1 +
1 file changed, 1 insertion(+)
create mode 100644 assets.txt
Deleted branch hotfix/assets (was 08edb94).

Summary of actions:
- Latest objects have been fetched from &apos;origin&apos;
- Hotfix branch has been merged into &apos;master&apos;
- The hotfix was tagged &apos;0.1.1&apos;
- Hotfix branch has been back-merged into &apos;develop&apos;
- Hotfix branch &apos;hotfix/assets&apos; has been deleted
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在往下阅读之前, 你最好将以上的命令实践一遍, 感受git-flow的操作与分支流向. 推荐SourceTree来跟踪变化.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;减少以及消灭无用的merge commit&lt;/h2&gt;
&lt;p&gt;如果是一个人使用git-flow, 你会发现你所有的commit以及commit log都是有意义的. 你所有的更改, feature合并都是有明确记录的.&lt;/p&gt;
&lt;p&gt;但是在多人使用下, 大家各自在本地开发, 往develop分支上merge, 那么就会出现每个人的develop分支不一致. 那么当一个人把自己的develop分支push到远端时, 其他人pull的时候就会出现分支合并, 产生 &amp;quot;Merge branch &apos;develop&apos; of remote into develop&amp;quot; 的类似commit.&lt;/p&gt;
&lt;p&gt;很多时候, 合并时没有冲突, 自动完成. 这种merge产生的commit是没有意义的, 而且会让分支看起来混乱.&lt;/p&gt;
&lt;p&gt;按照以下规则可以减少甚至消除这种无意义的commit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地在往develop分支进行合并时, ** &lt;code&gt;先在develop上执行git pull&lt;/code&gt; **, 当你没有在本地对develop分支有commit时, 执行&lt;code&gt;git pull&lt;/code&gt;是会发生Fast-forward合并的, 这种默认并不产生commit.&lt;/li&gt;
&lt;li&gt;将feature合并到develop上.&lt;/li&gt;
&lt;li&gt;push develop. 将你的修改提交到远端.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多数时候, 如果多个人分开执行以上操作, 是不会有问题的.&lt;/p&gt;
&lt;p&gt;如果多个人同时进行以上操作, 那么在进行第三步的时候, 是push不上去的, 需要先pull, 那么又会产生所谓的无意义commit, 该怎么办呢:&lt;/p&gt;
&lt;p&gt;这时不要用&lt;code&gt;git pull&lt;/code&gt;来拉取更改, 改为使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将远端代develop拉下来, 然后从本地develop上跟远端develop分叉的地方开始, 将本地的commit一个个应用到远端develop的末端, 使之成为一条直线, 从而没有了merge commit.&lt;/p&gt;
&lt;p&gt;关于冲突, rebase的时候也会有冲突:&lt;/p&gt;
&lt;p&gt;比如远端 &lt;code&gt;a-&amp;gt;b-&amp;gt;c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;你的 &lt;code&gt;a-&amp;gt;b-&amp;gt;d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进行rebase之后 &lt;code&gt;a-&amp;gt;b-&amp;gt;c-&amp;gt;e&lt;/code&gt;, 其中&lt;code&gt;e&lt;/code&gt;的更改内容和log就是你的&lt;code&gt;d&lt;/code&gt;, 如果有冲突, 冲突的修改也是提现在&lt;code&gt;e&lt;/code&gt;中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改完冲突, 我们会进行commit提交冲突修改. &lt;strong&gt;不要使用&lt;code&gt;git commit -m&lt;/code&gt;, 请直接使用&lt;code&gt;git commit&lt;/code&gt;, git会识别你这是一个冲突提交.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然, 操作的疏忽依然会产生无意义的commit, 但这并不致命, 注意就好.&lt;/p&gt;
&lt;p&gt;如果真的要消灭无意义commit: 在你&lt;code&gt;git pull&lt;/code&gt;之后发现自动合并了, 那么用&lt;code&gt;git reset --hard [刚刚你本地的提交commit version]&lt;/code&gt;进行本地版本回滚, 然后再&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我对rebase的理解也不是很多, 以上只是应用中的使用体会, 肯定还存在很多没有想到的情况和处理不当的地方, 请大家多提出来指正, 共同讨论.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&quot;&gt;http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&quot;&gt;https://git-scm.com/book/zh/v1/Git-分支-分支的衍合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

	</description>
    </item>
    <item>
      <title>java 多线程同步的几种写法</title>
      <link>http://blog.yangxiaochen.com/blog/java/thread-coordinate-n-methods.html</link>
      <pubDate>星期四, 14 四月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/java/thread-coordinate-n-methods.html</guid>
      	<description>
	&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回字的四种写法&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;假设有三个比较耗时的非cpu密集型任务, 最后的结果分些需要这三个任务的结果相加, 使用多线程并发可以让三个任务同时进行.
&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面是几种写法:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;package com.yangxiaochen;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Semaphore;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;/**
 * @author yangxiaochen
 * @date 16/4/14 上午12:17
 */
public class ForkJoinTest {&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m1() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m1&quot;);
    return 1;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m2() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m2&quot;);
    return 2;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;public int m3() {
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(&quot;m3&quot;);
    return 3;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    public static void main(String[] args) throws ExecutionException, InterruptedException {
        type0();
//        type1();
//        type2();
//        type3();
//        type4();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type0() throws InterruptedException {
    ForkJoinTest test = new ForkJoinTest();
    class Holder {
        int a;
        int b;
        int c;
    }
    Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t1 = new Thread(() -&amp;gt; h.a = test.m1());
t1.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t2 = new Thread(() -&amp;gt; h.b = test.m2());
t2.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Thread t3 = new Thread(() -&amp;gt; h.c = test.m3());
t3.start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    t1.join();
    t2.join();
    t3.join();
    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type4() throws InterruptedException {
    Semaphore semaphore = new Semaphore(0);&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTest test = new ForkJoinTest();
class Holder {
    int a;
    int b;
    int c;
}
Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.a = test.m1();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.b = test.m2();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.c = test.m3();
    semaphore.release();
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    semaphore.acquire(3);
    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type3() throws InterruptedException {
    ForkJoinTest test = new ForkJoinTest();
    class Holder {
        int a;
        int b;
        int c;
    }
    Holder h = new Holder();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.a = test.m1();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.b = test.m2();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(() -&amp;gt; {
    h.c = test.m3();
    synchronized (test) {
        if (h.a != 0 &amp;amp;&amp;amp; h.b != 0 &amp;amp;&amp;amp; h.c != 0) {
            test.notify();
        }
    }
}).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;synchronized (test) {
    test.wait();
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    System.out.println(h.a + h.b + h.c);
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type2() throws InterruptedException, ExecutionException {
    ForkJoinTest test = new ForkJoinTest();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;FutureTask&amp;lt;Integer&amp;gt; f1 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m1());
FutureTask&amp;lt;Integer&amp;gt; f2 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m2());
FutureTask&amp;lt;Integer&amp;gt; f3 = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; test.m3());&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;new Thread(f1).start();
new Thread(f2).start();
new Thread(f3).start();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    System.out.println(f1.get() + f2.get() + f3.get());
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;private static void type1() throws InterruptedException, ExecutionException {&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTest test = new ForkJoinTest();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;ForkJoinTask&amp;lt;Integer&amp;gt; f1 = ForkJoinTask.adapt(() -&amp;gt; test.m1()).fork();
ForkJoinTask&amp;lt;Integer&amp;gt; f2 = ForkJoinTask.adapt(() -&amp;gt; test.m2()).fork();
ForkJoinTask&amp;lt;Integer&amp;gt; f3 = ForkJoinTask.adapt(() -&amp;gt; test.m3()).fork();&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;        System.out.println(f1.join() + f2.join() + f3.join());
    }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>从一个丢失的iphone看互联网信息安全</title>
      <link>http://blog.yangxiaochen.com/blog/secure/a-lost-iphone-secure.html</link>
      <pubDate>星期一, 4 四月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/secure/a-lost-iphone-secure.html</guid>
      	<description>
	&lt;!-- # 一个真实故事 --&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;妹子把手机丢了...是在上公交车时, 妹子第二个上车, 头一个上去的黑色羽绒服男上车后问师傅是否去XX地, 师傅说不去, 黑羽绒服男就又挤下了车. 上车坐定一会, 妹子就发现手机不见了. 再打关机. 妹子说上车前确定手机还在 ,可以肯定就是那个黑衣服男偷得.&lt;/p&gt;
&lt;p&gt;之后补卡, 改密码等等善后事宜暂且不表. 且说说后续一些列发展引起我对互联网安全的思考.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2&gt;开端&lt;/h2&gt;
&lt;p&gt;用iphone手机的用户都知道, 一个iphone由一个appleid激活, 如果不进行反激活, 是无法登陆其他appleid的. 所以妹子就打开了丢失模式. 当丢失的手机打开联网时定位并且锁定. 小偷不知道appleid的密码, 就无法解锁手机, 也就无法转手卖出.&lt;/p&gt;
&lt;p&gt;头几天鸟无音信.&lt;/p&gt;
&lt;p&gt;在一两周后, 妹子邮箱接连收到邮件, 内容大概是:&lt;/p&gt;
&lt;p&gt;&amp;gt; 您的iphone正在尝试解锁刷机, 如果是您操作, 请忽略; 如果不是您操作, 请登录&lt;a href=&quot;#&quot;&gt;Apple ID 服务中心&lt;/a&gt;进行取消操作. 该操作将在12小时后被允许.&lt;/p&gt;
&lt;p&gt;署名是 &lt;code&gt;Apple ID Service&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;还好妹子是对这种事情无从下手, 问我怎么办, 我比较警惕, 说转发给我, 我接到后打开, 发现这个邮件的格式和内容很正式. 但是很明显有以下几个问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邮件来源地址不是&lt;code&gt;apple.com&lt;/code&gt;, 而是一个其他的地址.&lt;/li&gt;
&lt;li&gt;邮件中登陆Apple ID 中心的链接也不是官方的.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开这个链接, 是个和&lt;code&gt;查找 iphone&lt;/code&gt;登录界面完全一样的页面. 当然, 这是个伪造的钓鱼网站, 如果妹子自己打开这个并输入了appleid和密码, 那么账号密码就已经陷落了.&lt;/p&gt;
&lt;p&gt;&amp;gt;注意: 如果是手机邮箱, 那么发件人的地址默认是隐藏的. 而且, 打开链接后网页的url也是隐藏的. 所以, 如果是手机打开邮件, 很难分辨真假.&lt;/p&gt;
&lt;p&gt;可见, 被偷iphone手机, 由于其激活机制的特殊性, 产生了一条很色的产业链:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;小偷偷到手机后, 无法解锁, 只能卖给下线. 下线是大型的收购商, 来收购被偷的iphone, 然后进行批量的邮件进行钓鱼, 骗取密码解锁手机.&lt;/p&gt;
&lt;p&gt;于是我告诉妹子, 这种邮件都不要乱点, 不要输入你任何信息.&lt;/p&gt;
&lt;h2&gt;继续&lt;/h2&gt;
&lt;p&gt;陆续几天, 还是有同样的伪造刷机警告发来, 妹子都置之不理. 直到开始受到新的类型的邮件, 大概内容:&lt;/p&gt;
&lt;p&gt;&amp;gt; 你的手机在我们公司, 我们无法解锁, 所以按照我们的收购价800块卖给你. 请看&lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt;, &lt;a href=&quot;#&quot;&gt;店铺地址&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;妹子经过上一波教训, 已经对互联网有一定的畏惧心理, 所以丝毫没动, 转发给我.&lt;/p&gt;
&lt;p&gt;我收到后打开, 明显的, 日然是来历不明的邮箱地址. 而且, 店铺地址的链接也是来历不明的.&lt;/p&gt;
&lt;p&gt;虽然是来历不明的链接, 我还是想点进去看看, 于是, 我进行了点击. 结果是:&lt;/p&gt;
&lt;p&gt;空白页面...&lt;/p&gt;
&lt;p&gt;为什么是空白页面呢, 怎么不是钓鱼网站了? 于是我打开chrome开发者模式, 重新打开链接, 有很多请求, 我意识到, 这可能是xss攻击.&lt;/p&gt;
&lt;p&gt;有一个XXX.qq.com域名的请求, 中间进行了重定向, 然后又发送一个特殊url的请求, 这个url暂不公开, 可以假设为 xsssite.net&lt;/p&gt;
&lt;p&gt;因为妹子的appleid用的是qq邮箱. 所以如果对qq.com域名下的一个网页注入脚本的话, 当用户打开这个网页, 很可能能拿到这个用户的登录信息.&lt;/p&gt;
&lt;p&gt;由于这次我是从转发的邮件打开的链接, 所以泄露的是我的登录信息, 所以并无大碍.(跨站脚本只是获取了你的登录状态, 能够一段时间内伪造登录状态, 而并不是获取了你的密码)&lt;/p&gt;
&lt;p&gt;xsssite.net这个域名的请求包含的很多内容, 且这个网站就是一个xss攻击的平台. 关于这个xss攻击位置, 如何获取登录状态, 传递了哪些信息, 我还尚未去详细查看, 以后分享给大家.&lt;/p&gt;
&lt;p&gt;我很感叹, 这个产业链远比我想象的发达:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小偷 -&amp;gt; 网络诈骗技术者 -&amp;gt; 黑客
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;结果&lt;/h2&gt;
&lt;p&gt;后来, 由于一些事情, 还是在妹子的登录状态打开一个这种连接, 对方登陆了妹子的邮箱, 从而重置了appleid密码, 当然期间有apple的邮件, 但是妹子以为是假的, 直接忽略掉了. 我没有及时得到消息, 还是让对方得逞了.&lt;/p&gt;
&lt;h1&gt;故事之后的反思&lt;/h1&gt;
&lt;p&gt;前面讲了妹子的遭遇, 我又想起近几年几次密码泄露, 信息泄露的事件, 深感互联网安全非常重要, 豺狼虎视眈眈, 但是绝大多数人丝毫没有防范意识. 所以我想了一些关于互联网安全的知识, 提示, 以及应对措施. 给大家普及一下.&lt;/p&gt;
&lt;h4&gt;互联网危险到何种程度&lt;/h4&gt;
&lt;p&gt;请看&lt;a href=&quot;WooYun.org&quot;&gt;乌云网&lt;/a&gt;, 白客们所发现的各种系统漏洞. 触目惊心.&lt;/p&gt;
&lt;p&gt;几年前csdn的数据库泄露事故, 余威犹在. 后续几次京东, 7k7k等网站的大量用户密码泄露都是这次事故的后遗症.&lt;/p&gt;
&lt;p&gt;黑色产业链早已超乎你我的想象. 道高一尺魔高一丈. 你的一切都时时刻刻被攻击者盯着, 不要有侥幸心理.&lt;/p&gt;
&lt;h4&gt;关于密码&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;密码与社会工程学&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;社会工程学: 一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段取得自身利益的手法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子, 最简单的社会工程学案例, 就是根据你的生日来推测你的银行卡密码. 根据人们慵懒的习惯, 尝试&lt;code&gt;123456&lt;/code&gt;, &lt;code&gt;asd123&lt;/code&gt;, &lt;code&gt;abcd&lt;/code&gt; 等方便输入的习惯来推测你的密码. 所以说, 根据你的个人信息, 比如生日, 身份证号, 门牌号, 亲友生日, 名字拼写, 短语拼写等任何对你有意义的字符序列, 都会被认为是你的潜在密码. 依靠计算机的自动化, 计算效率, 可以不停的对大量的用户数据进行尝试破解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以我们应该避免使用和自身信息有关的密码&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全并不在你的掌握之中&lt;/p&gt;
&lt;p&gt;使用随机的, 比较复杂的密码, 就可以确保账号安全了么? 很遗憾, 不是的.&lt;/p&gt;
&lt;p&gt;因为你的密码不仅仅是你自己要保管, 你所注册的网站, 应用也需要保管. 所以, 你所使用的网站, 应用是否在安全上做足了必要的功夫, 是很重要的.&lt;/p&gt;
&lt;p&gt;前几年CSDN数据库泄露, 大量用户资料被盗, 令人震惊的是他们的密码是明文的....&lt;/p&gt;
&lt;p&gt;根据用户们懒惰的习惯, 不愿意记很多密码, 于是可以假设用户们都喜欢用同一套用户名密码来登陆所有网站,应用. 一时间, 大量网站,应用被撞库成功.&lt;/p&gt;
&lt;p&gt;原则上, 网站是不会保存明文密码的, 他们所保存的是对你的密码进行不可逆加密后的密文, 每次你登陆输入密码, 网站会对输入的密码进行同样的不可逆加密, 然后与保存的密文进行对比来验证正确性. 这样在网站数据库泄露时, 用户密码至少不会以明文显示在盗窃者面前.&lt;/p&gt;
&lt;p&gt;同时, 网站也不应该仅仅用md5简单加密. 如今对于简单通用的加密手段, 黑客已经有数量庞大的样本来进行比较, 所以, 简单通用加密的效果已经接近明文了.所以, 加密时加入随机的salt, 是常用的方法.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免所有账号都是同一密码. 可以简单分成几级账号密码, 你的关键应用比如qq号, 支付宝, 邮箱等的密码, 一定不要与注册小网站的密码一样.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要轻易进行注册, 尤其对于小网站, 他们的技术相对于薄弱, 安全工作做得不够. 建议小网站都使用第三方认证的方式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二步验证&lt;/p&gt;
&lt;p&gt;在输入密码后, 需要再进行一次密码验证.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One Time Password: 一次性密码, 每个密码只在一次, 或者很短的时间内有效. 下次登录或认真, 就会用不同的密码.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个已经非常常见了, 比如常见的手机验证码, 暴雪战网的安全令牌.&lt;/p&gt;
&lt;p&gt;如果你的账号可以开通二步验证, 强烈推荐开通, 虽然每次耽误点时间, 但是可以对你的账号进行非常好的保护.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apple ID, Google账号, QQ邮箱(使用qq安全中心) 等都支持二步验证, 建议都去开通一下吧&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;关于常用邮箱&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;你的安全老巢&lt;/p&gt;
&lt;p&gt;你的邮箱有多重要? 如果你的邮箱被别人登陆:&lt;br /&gt;
1. 首先, 你的个人信息被别人一览无余. 而且, 有的同学还喜欢用邮箱来作为记事本.&lt;br /&gt;
2. 可以随时重置你的各种网站, 应用的密码!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立密码&lt;/p&gt;
&lt;p&gt;如果你使用网易, QQ, 新浪等不管是什么邮箱, 要设置独立密码! 如同妹子邮箱被登录的教训. 如果你在网易, QQ, 新浪的账号登录状态被xss攻击获得, 那么攻击者可以直接进入你的邮箱!&lt;/p&gt;
&lt;p&gt;这些大网站, 大企业的安全做得很好不用担心? 我承认, 这些大企业的核心业务是没有问题的, 关键在于这些企业家大业大, 设计的方面非常多, 部门也非常多, 甚至分布在不同的地点, 所以不可能所有的地方都能做好安全措施. 妹子这个例子中, 应该是QQ的大粤网中论坛的漏洞, 被进行了xss攻击.&lt;/p&gt;
&lt;p&gt;话说回来, 林子大, 什么鸟都有, 你不能保证这些企业当中有黑客的存在. 就像你找人做了个保险箱, 你不能保证这个人是不是留了一把钥匙, 或者在保险箱你不知道地方做了个机关. 尤其对这些企业的非核心业务的技术人员, 并不事都是经过严格考核进来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要轻易在浏览器中从邮箱中打开连接&lt;/p&gt;
&lt;p&gt;切记, 邮箱中的不确定连接不要轻易就打开, 尤其实在浏览器环境下使用邮箱的时候. 预防xss攻击.&lt;/p&gt;
&lt;p&gt;如果打开链接, 发现有异常, 查看请求记录, 如果有疑似xss攻击, 果断退出登录状态, 修改密码. 然后把该链接提交给出现漏斗的网站.(技术工作者)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要在浏览器中打开链接, 请使用&amp;quot;隐身窗口中打开&amp;quot;, 据我所知Chrome, 以及使用Chrome内核的浏览器基本都支持&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;关于手机号&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;你的安全命门
&lt;p&gt;当你的手机丢了, 第一件事, 补卡. 让丢失的卡不能再使用.&lt;/p&gt;
&lt;p&gt;当你的手机落入别人手中, 又能正常使用, 那么它可以使用很多应用的二步验证.&lt;/p&gt;
&lt;p&gt;作为一些应用的密保手机, 它能够充值你这些应用的密码.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;手机丢了先补卡&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;如果你对妹子的经历感兴趣, 想获取妹子收到的邮件样本, 请在评论里留下你的邮箱, 说明要获取邮件样本, 我会不定期地查看进行转发.&lt;/p&gt;
&lt;p&gt;当然, 对于产生的一些列问题我特此声明不负任何责任.&lt;/p&gt;
&lt;p&gt;如果你觉得本文对你有帮助和启发, 可以转发给其他人, 以示提醒.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>homebrew安装旧版本软件</title>
      <link>http://blog.yangxiaochen.com/blog/mac/homebrew-install-old-version-soft.html</link>
      <pubDate>星期二, 9 二月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/mac/homebrew-install-old-version-soft.html</guid>
      	<description>
	&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不需要用brew versions ,这个已经过时了.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;很多有重要版本的软件都已经区分版本的设定formulae了
参见项目地址 &lt;a href=&quot;https://github.com/Homebrew/homebrew-versions&quot; class=&quot;bare&quot;&gt;https://github.com/Homebrew/homebrew-versions&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如nodejs   有重要的0.10.*版本&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;yangxiaochen:/usr/local$ brew search node
leafnode node node010 node04 node06 node08 nodebrew nodenv&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;node010就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;同理php也是这样分php56 php55 php54 ….&lt;/p&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>rabbitmq管理使用实践</title>
      <link>http://blog.yangxiaochen.com/blog/develop/rabbitmq-in-action.html</link>
      <pubDate>星期一, 8 二月 2016 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/develop/rabbitmq-in-action.html</guid>
      	<description>
	&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot;&gt;Table of Contents&lt;/div&gt;
&lt;ul class=&quot;sectlevel3&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_原创_转载请注明出处httpsblog_yangxiaochen_comhttpsblog_yangxiaochen_com&quot;&gt;原创, 转载请注明出处[https://blog.yangxiaochen.com](https://blog.yangxiaochen.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_poi&quot;&gt;poi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_业务事件流&quot;&gt;业务事件流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_日志流&quot;&gt;日志流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_其他&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_rabbitmq_规范&quot;&gt;rabbitmq 规范&lt;/a&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_使用规范&quot;&gt;使用规范&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#_0_使用原则&quot;&gt;0. 使用原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_1_datasourceexchanges&quot;&gt;1. datasourceExchanges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_2_durable_queues_exchanges&quot;&gt;2. durable queues, exchanges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#_3_temp_queues_exchagnes&quot;&gt;3. temp queues, exchagnes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_原创_转载请注明出处httpsblog_yangxiaochen_comhttpsblog_yangxiaochen_com&quot;&gt;原创, 转载请注明出处[&lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;](&lt;a href=&quot;https://blog.yangxiaochen.com&quot; class=&quot;bare&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;)&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&amp;lt;!-- more -&amp;#8594;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;# MQ数据源&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&lt;code&gt;datasource &amp;#8594; topic exchange&lt;/code&gt;&lt;/code&gt;, 数据源已固定格式发入exchange, exchange类型为topic,既可以使用路由route_key, 又可以进行通配. 不要将生产者, 消费者用在同一队列上, 这样耦合度高, 消息无法复用.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据源只关心输入exchange, 对后续消费者无需关心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新加,修改数据源需要备案记录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者一般情况下使用临时队列, 必要情况下使用持久队列. 队列从数据源的exchange中订阅数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成. 防止程序改动造成的废弃的exchange, queue仍然存在在rabbitmq中.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命名统一.&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:[sth.sth]
queueName: [消费者程序名称]:[exchangeName].[subject]
route_key: [exchangeName].[subject]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
exchangeName: datasource:dispatch.event
queueName: autoDispatch:dispatch.event.orderCreate
route_key: dispatch.event.orderCreate&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_poi&quot;&gt;poi&lt;/h3&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:poi&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_业务事件流&quot;&gt;业务事件流&lt;/h3&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName: datasource:dispatch.event&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_日志流&quot;&gt;日志流&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_其他&quot;&gt;其他&lt;/h3&gt;

&lt;/div&gt;
&lt;h1 id=&quot;_rabbitmq_规范&quot; class=&quot;sect0&quot;&gt;rabbitmq 规范&lt;/h1&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_使用规范&quot;&gt;使用规范&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_0_使用原则&quot;&gt;0. 使用原则&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;数据源已固定格式发入exchange, exchange类型为topic.数据源只关心输入exchange.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改数据源, 持久队列, 持久内部exchange需要备案记录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者一般非必要情况下使用临时队列. 队列从数据源的exchange中订阅数据.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中不要生成持久的exchange, queue. 而是在管理界面生成.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_1_datasourceexchanges&quot;&gt;1. datasourceExchanges&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;datasource:[datasourceName]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
datasource:poi
datasource:dispatch.event&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git@gitlab.supaide.cn:sys/rabbitmq.git
datasources.txt&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;备案说明详见文件内部格式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_2_durable_queues_exchanges&quot;&gt;2. durable queues, exchanges&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;queueName
[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;exchangeName
x:[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;例:
autoDispatch:dispatch.event.orderCreate
x:autoDispatch:dispatch.event.*&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git@gitlab.supaide.cn:sys/rabbitmq.git
durableQueues.txt&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;备案说明详见文件内部格式.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_3_temp_queues_exchagnes&quot;&gt;3. temp queues, exchagnes&lt;/h3&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;命名&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;gen.[appName]:[routingKey]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;or&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;默认随机名称&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录备案&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;无需备案&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>css 定位指南</title>
      <link>http://blog.yangxiaochen.com/blog/frontend/css-position.html</link>
      <pubDate>星期二, 8 十一月 2011 00:00:00 +0800</pubDate>
      <guid isPermaLink="false">blog/frontend/css-position.html</guid>
      	<description>
	&lt;h4&gt;原创, 转载请注明出处&lt;a href=&quot;https://blog.yangxiaochen.com&quot;&gt;https://blog.yangxiaochen.com&lt;/a&gt;&lt;/h4&gt;
&lt;h2&gt;前置知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解html各个标签&lt;/li&gt;
&lt;li&gt;对css各种属性有一些了解&lt;/li&gt;
&lt;li&gt;理解盒子模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;正文&lt;/h2&gt;
&lt;p&gt;对于网页制作的新手来说, 了解了html各种标签的含义, 并不能够制作出像网上那些绚丽的网页.&lt;br /&gt;
一个网页的制作过程, 要经过一下几个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计&lt;/li&gt;
&lt;li&gt;布局分析&lt;/li&gt;
&lt;li&gt;编写html, 并用css布局&lt;/li&gt;
&lt;li&gt;css来进行各个布局区块内部的样式编写&lt;/li&gt;
&lt;li&gt;js来编写动态效果和其他功能脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们这里研究的是第三部分: 当我们确定了布局, 如何用html和css把布局描述出来&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;html编写&lt;/p&gt;
&lt;p&gt;html是用来表达文档结构的,当看到一个h1标签, 不应该去想这一标签让文字放大加粗, 而应该想这个标签引用的文字, 是一个一级标题, 这才是html的初衷. html中不应该出现描述样式的属性如&lt;code&gt;width&lt;/code&gt;, &lt;code&gt;sytle&lt;/code&gt;等.&lt;/p&gt;
&lt;p&gt;html不应该去思考样式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档流&lt;/p&gt;
&lt;p&gt;怎么定位? 很多人直接就开始讲定位的属性和方法. 其实, 要真正理解定位, 就要先了解文档流.&lt;/p&gt;
&lt;p&gt;什么是文档流? 写出来的html文档的顺序, 就是文档流的顺序. 当不加任何修饰的时候, 页面上显示出来的时候, 和你html代码是很相像. 也就是说, 所写的html文档的各个元素, 是按这个默认顺序排列下来的.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位&lt;br /&gt;
有了这个基础,再来看定位:定位有两种方式.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;float定位&lt;/p&gt;
&lt;p&gt;float有两个值:&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;. 分别表示向左向右浮动. 一旦一个元素采用了float进行定位, 那么这个元素将脱离文档流. 意思是这个元素虽然在页面上还看得到, 但是已经不据占位置了, 后面的元素会补上来.&lt;/p&gt;
&lt;p&gt;那么它会到哪呢? 飘走了… 一个较为明确的说法是: 因为任何一个元素可以成为一个盒子模型, 那么这个元素有个边框, 浮动的框可以根据float的值是&lt;code&gt;left&lt;/code&gt;还是&lt;code&gt;right&lt;/code&gt;进行向左或向右移动, 直到它的外边缘碰到父元素的边框或另一个同级元素的边框为止.&lt;/p&gt;
&lt;p&gt;float的块级元素将不占一正行, 宽度为内容实际宽度.&lt;/p&gt;
&lt;p&gt;在这个元素后面的文档流部分会顶上来, 取代这个元素的位置. 但是后面那个元素里的内容, 比如说文字, 会围绕在上面那个浮动元素周围. 这个效果不是很好表达,大家可以自己做个试验. 定义两个div, 里面都写上文字, 注意第二个div里的文字要比第一个多(这样才能环绕), 让后给第一个加CSS属性:&lt;code&gt;float:left&lt;/code&gt;. 然后就看到效果了.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;position定位&lt;/p&gt;
&lt;p&gt;position有四个值:&lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先说static,这个是默认值,每个元素如果没有定义position属性,就等于是这个值.所以,不解释了,可以说就是没有定位方式.&lt;/p&gt;
&lt;p&gt;关键是其他的三种.选择其中任何一个后,就可以按自己需求布局了.这时候你可以用CSS中的四个属性:&lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;. 比如&lt;code&gt;top:100px&lt;/code&gt;, 表示相对于”相对元素”(稍后解释这个相对元素)的顶部有&lt;code&gt;100px&lt;/code&gt;的距离.其他以此类推.&lt;/p&gt;
&lt;p&gt;相对元素是什么? &lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;fix&lt;/code&gt;这三个值决定了这个相对元素:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;relative&lt;/p&gt;
&lt;p&gt;元素会相对于自身原来在文档流的位置进行偏移. 这时定义&lt;code&gt;top:100px&lt;/code&gt;就表示相对它本来应该在的位置向下偏移了&lt;code&gt;100px&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;absolute&lt;/p&gt;
&lt;p&gt;元素框从文档流完全删除, 并相对于其包含块定位.&lt;/p&gt;
&lt;p&gt;包含块定义:&lt;/p&gt;
&lt;p&gt;这个包含块并不一定是直接父元素, 一个元素可能被包在好几层块之内. 距离最近的,postion属性为absolute relative fixed 三者之一的祖先元素.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fixed&lt;/p&gt;
&lt;p&gt;元素框的表现类似于将 position 设置为 &lt;code&gt;absolute&lt;/code&gt;，不过其包含块是视窗本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;练习与参考&lt;/h2&gt;
&lt;p&gt;以上是定位的理论, css的学习是一个不断熟练的过程, 写的时候可以参照成熟网站的类似布局, 通过chrome开发者模式来研究别人的页面写法很有裨益.&lt;/p&gt;
&lt;p&gt;另外[CSS禅意花园]这本书值得一看, 虽然比较老, 但是里面的一些基础知识, 基本css写法是值得学习的.&lt;/p&gt;

	</description>
    </item>

  </channel> 
</rss>
